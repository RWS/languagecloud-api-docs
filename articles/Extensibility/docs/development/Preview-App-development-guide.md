---
tags: [Development]
stoplight-id: i7ib8ruwpxdxr
---


# Preview Provider

## Introduction

Preview apps offer the possibility to use external preview providers within the Trados Enterprise platform.

The type of preview generated is known as "Dynamic Preview" as it can dynamically adjust depending on choices the user might make in the browser, for instance, selecting different preview sections or views from the rendered preview. The extension acts as a webserver which implements custom endpoints to serve the content to the browser. This content can be anything which the browser is able to parse and display accordingly. For more details on Dynamic Preview Concepts, please see the second section towards the end of this document.

To build a new preview app we recommend to start by using the provided [app blueprints](https://github.com/RWS/language-cloud-extensibility/tree/main/blueprints).

## Preview App Extension

A preview app needs to define at least one preview extension within its [descriptor](../../App-API.v1.json/paths/~1descriptor/get).
For example: 

```json
{
  ...
  "extensions": [
   {
  "extensionPointId": "lc.previewprovider",
  "id": "string",
  "name": "string",
  "description": "string",
  "extensionPointVersion": "string",
  "configuration": {
    "endpoints": {
      "lc.preview.startpreview": "string",
      "lc.preview.refreshpreview": "string",
      "lc.preview.updatesegment": "string",
      "lc.preview.endpreview": "string"
    },
    "supportedFileTypes": "html",
    "requiredInputFiles": {
      "bilingualDocument": false,
      "previewPackageTemplate": false,
      "nativeSourceFile": false,
      "nativeTargetFile": false,
      "nativeAnnotatedTargetFile": true
    },
    "outputType": "previewUrl"
  }
}
  ]
  ...
}
```

- `id` - unique extension identifier provided by the app Developer.
- `name` - provide a friendly and unique name. It might be shown to the end user, and may be useful to help the user distinguish between multiple extensions.
- `extensionPointVersion` - the version of the extension point that is implemented in the Extension.
- `extensionPointId` - the extension point identifier corresponding to this extensionType: **lc.previewprovider**.
- `description` - the preview extension description
- `configuration` - the extension configuration.
  - `endpoints` - the required endpoints for the preview extension.
    - `lc.previewprovider.startpreview` - the endpoint used to start the preview generation.
    - `lc.previewprovider.refreshpreview` - the endpoint used to refresh the existing preview session.
    - `lc.previewprovider.updatesegment` - the endpoint used to update a segment based on a BCM document fragment.
    - `lc.previewprovider.endpreview` - the endpoint used to clean up any state associated with a given preview session.

    For the V2 API, they are:
    - `lc.previewprovider.startpreview.v2`
    - `lc.previewprovider.refreshpreview.v2`
    - `lc.previewprovider.updatesegment.v2`
    - `lc.previewprovider.endpreview.v2`
    
  - `supportedFileTypes` - A list of FileTypeDefinitionIds which this app may be associated with
  - `requiredInputFiles` - provides details about which types of input files this extension will require for generating a preview.
    - `bilingualDocument` - request an endpoint for downloading a BCM document.
    - `previewPackageTemplate` - request an endpoint for downloading a preview Package Template.
    - `nativeSourceFile` - request an endpoint for downloading a native source file.
    - `nativeTargetFile` - request an endpoint for downloading a native target file.
    - `nativeAnnotatedTargetFile` - request an endpoint for downloading a native annotated target file.
  - `outputType` - Indicates which type of output is generated by the extension. Dynamic previews only support a URL endpoint result and thus this should be set to **previewUrl**

### Preview App Endpoints

#### StartPreview
The _startPreview_ endpoint initiates a background preview generation session
and returns after creating the background worker which generates the actual preview. The result is sent via calling the URL set in the `callbackUrl` field. An important field is the `previewSessionId` which indicates the session this preview is associated with.

If the app needs to store any state, it should associate it with this identifier. The very first call for a given session should always be _startPreview_. If other endpoints are called before this, they should return an error.

The preview content is served by the app via one or more endpoints the app implements. The content can be any format, as long as the browser hosting the preview can parse and display that content. This includes, HTML, PDF, streamed video etc.
The resulting resource identifier returned from this call should be set in the `previewResult` field of the callback response. This will be a URL pointing to the initial endpoint implementation on the extension which the Browser hosting the preview will use to retrieve the preview content. As mentioned, the preview extension can implement additional endpoints which can then be called from the hosted portion in the Browser via AJAX calls or similar.

There are currently 2 versions of the Preview API supported by Extensions:

## APIs

### API V1

  Examples: 
```html
POST /v1/start-preview
```

-   The request is as follows:

```json
{
  "previewSessionId": "string",
  "fileInformation": {
    "name": "string",
    "sourceLanguage": "string",
    "targetLanguage": "string"
  },
  "inputFiles": {
    "bilingualDocumentUrl": "string",
    "previewPackageTemplateUrl": "string",
    "nativeFileUrl": "string",
    "nativeAnnotatedFileUrl": "string"
  },
  "previewResultFileUrl": "string",
  "callbackUrl": "string",
  "scope": "source"
}
```
-   The response after setting up the background worker, would look like this:
```json
{
  "errorCode": "string",
  "message": "string",
  "details": [
    {
      "name": "string",
      "code": "string",
      "value": "string"
    }
  ]
}
```

-   The final result, which is sent on the callback, is shown below:

```json
{
  "previewSessionId": "string",
  "previewResult": "string",
  "errors": [
    {
      "errorCode": "string",
      "message": "string",
      "details": [
        {
          "name": "string",
          "code": "string",
          "value": "string"
        }
      ]
    }
  ]
}
```

Endpoint usage:

This endpoint is used to initiate a preview session on the app. When this endpoint is called, the app should generate the initial preview and associate it (internally, if any state is kept) - with the `previewSessionId`.

This should be the first endpoint called for any given session - if another endpoint is called for a given session ID before this one, an error should be returned.


Please refer to the endpoint's [documentation](../../App-API.v1.json/paths/~1lc.preview.startpreview/post) for further details.

#### RefreshPreview
The _refreshPreview_ endpoint refreshes an existing preview. The mechanism for this in entirely up to the Extension implementation in that it might keep state from the initial preview generation from _startPreview_ in order to speed up the refresh.

The request and responses (REST and Callback) are identical to the _startPreview_ endpoint.

 Example: 
```html
POST /v1/refresh-preview
```

Endpoint usage:
This endpoint is called when a preview refresh is requested by the user. Any state the app holds from the initial preview generation may be used to speed up the refresh.

Please refer to the endpoint's [documentation](../../App-API.v1.json/paths/~1lc.preview.refreshpreview/put) for further details.

#### UpdateSegment
The _updateSegment_ endpoint accepts a list of BCM document fragments along with their associated segment IDs. The Extension will generate and return an HTML rendered fragment for each BCM document fragment sent in this manner.

Example: 
```html
POST /v1/update-segment
```

-   The request is as follows:

```json
{
  "previewSessionId": "string",
  "segments": [
    {
      "segmentId": "string",
      "fragment": {}
    }
  ],
  "fileInformation": {
    "name": "string",
    "sourceLanguage": "string",
    "targetLanguage": "string"
  },
  "scope": "source"
}
```
- `previewSessionId` - unique ID of current preview session.
- `segments` - an array of segments with the following details:
  - `segmentId` - ID of segment being rendered.
  - `fragment` - BCM document JSON fragment.
- `fileInformation` - provides information relating to the file for which the rendered HTML is being generated. 
- `scope` - indicates whether the generation is happening for source or target content.

-   The response would look like this:
```json
{
  "previewSessionId": "string",
  "renderedTranslations": [
    {
      "html": "string",
      "segmentId": "string",
      "errorCode": "string"
    }
  ]
}
```
- `previewSessionId` - unique ID of current preview session.
- `renderedTranslations` - an array of rendered translations with the following details:
  - `html` - rendered HTML content for this segment.
  - `segmentId` - ID of this segment.
  - `errorCode` - Error code for this segment (App/Extension specific).

Endpoint usage:
This endpoint is called when the user is updating one or more segments in the Editor. For each segment, the extension will render an equivalent HTML fragment based on the input BCM document fragment.

Please refer to the endpoint's [documentation](../../App-API.v1.json/paths/~1lc.preview.updatesegment/post) for further details.

#### EndPreview
The _endPreview_ endpoint is called when a given preview session associated with the previewSessionId is finished. This is called so that the app may perform any required cleanup.

Example: 
```html
POST /v1/end-preview
```

```json
{
  "previewSessionId": "string"
}
```

Endpoint usage:
Called to indicate a preview session has terminated. Any required cleanup should be performed by the app.

Please refer to the endpoint's [documentation](../../App-API.v1.json/paths/~1lc.preview.endpreview/post) for further details.

### API V2

  Examples: 
```html
POST /v2/start-preview
```

-   The request is as follows:

```json
{
  "previewSessionId": "string",
  "projectId": "string",
  "scope": "target",
  "fileInformation": {
    "name": "string",
    "sourceLanguage": "string",
    "targetLanguage": "string"
  },
  "inputFiles": {
    "bilingualDocument": {"id": "string", "version": "int", "url": "string"},
    "previewPackageTemplate": {"id": "string", "version": "int", "url": "string"},
    "nativeSourceFile": {"id": "string", "version": "int", "url": "string"},
    "nativeTargetFile": {"id": "string", "version": "int", "url": "string"},
    "nativeAnnotatedTargetFile": {"id": "string", "version": "int", "url": "string"}
  },
  "callbackUrl": "string",
}
```
-   The response after setting up the background worker, would look like this:
```json
{
  "errorCode": "string",
  "message": "string",
  "details": [
    {
      "name": "string",
      "code": "string",
      "value": "string"
    }
  ]
}
```

-   The final result, which is sent on the callback, is shown below:

```json
{
  "previewSessionId": "string",
  "previewResult": "string",
  "errors": [
    {
      "errorCode": "string",
      "message": "string",
      "details": [
        {
          "name": "string",
          "code": "string",
          "value": "string"
        }
      ]
    }
  ]
}
```

Endpoint usage:

This endpoint is used to initiate a preview session on the app. When this endpoint is called, the app should generate the initial preview and associate it (internally, if any state is kept) - with the `previewSessionId`.

This should be the first endpoint called for any given session - if another endpoint is called for a given session ID before this one, an error should be returned.


Please refer to the endpoint's [documentation](../../App-API.v1.json/paths/~1lc.preview.startpreview.v2/post) for further details.

#### RefreshPreview
The _refreshPreview_ endpoint refreshes an existing preview. The mechanism for this in entirely up to the Extension implementation in that it might keep state from the initial preview generation from _startPreview_ in order to speed up the refresh.

The request and responses (REST and Callback) are identical to the _startPreview_ endpoint.

 Example: 
```html
POST /v2/refresh-preview
```

Endpoint usage:
This endpoint is called when a preview refresh is requested by the user. Any state the app holds from the initial preview generation may be used to speed up the refresh.

Please refer to the endpoint's [documentation](../../App-API.v1.json/paths/~1lc.preview.refreshpreview.v2/put) for further details.

#### UpdateSegment
The _updateSegment_ endpoint accepts a list of BCM document fragments along with their associated segment IDs. The Extension will generate and return an HTML rendered fragment for each BCM document fragment sent in this manner.

Example: 
```html
POST /v2/update-segment
```

-   The request is as follows:

```json
{
  "previewSessionId": "string",
  "segments": [
    {
      "segmentId": "string",
      "fragment": {}
    }
  ],
  "fileInformation": {
    "name": "string",
    "sourceLanguage": "string",
    "targetLanguage": "string"
  },
  "scope": "source"
}
```
- `previewSessionId` - unique ID of current preview session.
- `segments` - an array of segments with the following details:
  - `segmentId` - ID of segment being rendered.
  - `fragment` - BCM document JSON fragment.
- `fileInformation` - provides information relating to the file for which the rendered HTML is being generated. 
- `scope` - indicates whether the generation is happening for source or target content.

-   The response would look like this:
```json
{
  "previewSessionId": "string",
  "renderedTranslations": [
    {
      "html": "string",
      "segmentId": "string",
      "errorCode": "string"
    }
  ]
}
```
- `previewSessionId` - unique ID of current preview session.
- `renderedTranslations` - an array of rendered translations with the following details:
  - `html` - rendered HTML content for this segment.
  - `segmentId` - ID of this segment.
  - `errorCode` - Error code for this segment (App/Extension specific).

Endpoint usage:
This endpoint is called when the user is updating one or more segments in the Editor. For each segment, the extension will render an equivalent HTML fragment based on the input BCM document fragment.

Please refer to the endpoint's [documentation](../../App-API.v1.json/paths/~1lc.preview.updatesegment.v2/post) for further details.

#### EndPreview
The _endPreview_ endpoint is called when a given preview session associated with the previewSessionId is finished. This is called so that the app may perform any required cleanup.

Example: 
```html
POST /v2/end-preview
```

```json
{
  "previewSessionId": "string"
}
```

Endpoint usage:
Called to indicate a preview session has terminated. Any required cleanup should be performed by the app.

Please refer to the endpoint's [documentation](../../App-API.v1.json/paths/~1lc.preview.endpreview.v2/post) for further details.


## Session Management and Tenant Separation
It is up to the app to manage any session state internally and have an expiry mechanism for this.
Also, any data which is tenant specific needs to be kept separate from any other data and the app also needs to manage tenant separation concerns internally.
<br>
<br>
<br>


# Dynamic Preview Concepts

Dynamic Preview concepts are explained a little more in this section. The Preview Container/Viewer (which hosts its content in an iframe) can dynamically update parts of the preview when the user selects different "pages" inside it via a selection mechanism, such as a drop-down or something similar. The app implements an endpoint which will initially serve the starting content and also any additional "dynamic" content requested via an AJAX call or similar. In general, the content generated dynamically will be a different rendering or view of the same BCM document content. For example, applying different XSLTs to an XML could provide such dynamic content (if the native file is XML based). It might also be different sections of the previewed document, or indeed, streamed video snippets, depending on which segments etc are selected in the previewed document.


Please refer also to this document before continuing:
[Preview Provider](../../docs/development/Preview-App-development-guide.md).


The app acts as a web server for this dynamic content. Some of the concepts around this are defined here:

- Custom Preview Endpoint(s) - this is a custom endpoint on the app which supports TLS and which is used to serve the Initial Preview Content and the subsequent Dynamic Preview Content.  Depending on the implementation, the app might specify one or more of these.
- Initial Preview Content - this is the HTML/Javascript content which is first served from the custom preview endpoint. It consists of some basic HTML and Javascript content which initializes the preview and loads an initial dynamic page. The URL for this initial call is set as the value for the "src" attribute on the iframe and is in the following format: 

```json
https://my.extension/custom-endpoint?sessionId={sessionId}&tenant={tenantId}&accessToken={hard-to-guess-access-token}&page={pageId}
```
An example of such a URL is: 

```json
https://0ba1-212-17-60-65.ngrok.io/api/dynamic/v1/preview/endpoint?sessionId=1234567892&tenantId=12345&accessToken=a6f56954-7f55-440a-9919-160a2c4af91c&page=initial
```

The returned HTML/Javascript will be embedded in an iframe and there should be some Javascript mechanism to extract the access token from the current URL of the iframe and next pass it as a header in subsequent dynamic calls made from the iframe during dynamic content selection.
- Dynamic Preview Content - this is the dynamic content which is loaded based on a page selection. This can be loaded initially as part of the initialization routine of the Initial Preview Content after it checks for the hash fragment, and then also, when a user selects a given page using the page selection mechanism (via drop-down or similar). Loading the dynamic content involves making a dynamic call to the app on one of the Custom Preview Endpoints and must pass in the hash fragment as a header to the call. Mechanisms for initiating the call and updating the content might involve AJAX/JQuery or similar.
- TLS (Transport Layer Security) - the app should enable the TLS protocol on all custom endpoints. A valid certificate will be needed for this.
- Authorization/Access token - this is a hard-to-guess value which the app must generate and return as a response to the initial StartPreview request. It should be set as a hash fragment value on the returned URL. The app should provide for a TTL on this access token so that it will expire after a pre-determined time. The app should manage the TTL and any requirements around expiry of this.
- Preview Session - This is a session related to a given preview. Each session has a unique ID associated with it called "Preview Session ID" and it is sent to the app during various requests, including StartPreview. The app should use this to keep track of content related to a specific session when storing it locally.
- App storage - this could be a database or local disk-based storage etc. It is used by the app to store preview related content for specific sessions, such as files used to generate the preview, generated preview content, and any other specific data the app needs to store to work.
- Input Files - these files represent the initial data used to generate the preview. They might be a PreviewPackageTemplate, Native Source or Target files or Annotated Native Source or Target files. These files are described in more detail here:
  - PreviewPackageTemplate - this file is a zip package containing different content which is used in the generation of preview content. Examples include XML, HTML, images, CSS, XSLT, Javascript etc. The content of this file is specific to the native file format used to generate the preview.
  - Native File - this represents the native format which is being translated or previewed. Examples would be Word documents, Excel documents, XML documents, text documents etc. These files can be source or target, where the source represents the language which is being translated into other languages and the target represents the translated file (for example, source might be Japanese, and target might be French.) - This is a one-to-many relationship type, meaning that there is only one source language but possibly many more target languages.
  - Annotated Native File - This is a native source or target file which has been annotated with special characters which encode a segment identifier in the annotation. The annotations also indicate where the segment boundaries are. These are used for segment navigation between the Editor and the Preview and for updating of segments inside the preview when content has changed in the Editor.
- Output Preview Content - The generated content is stored by the app locally and a URL is created allowing access to the stored content via a Custom Preview Endpoint on the app. In essence, the app acts like a web server.
- CORS (Cross Origin Resource Sharing) - Please see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS .
- iframe - Please see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe.


## Creating a Preview Provider App

The following steps should be considered when creating a Dynamic Preview App:

- Add one or more custom endpoints in the PreviewController class
- Ensure the TLS security protocol is enabled on the app endpoints. A certificate from a trusted CA is required for this.
- Implement the endpoint functionality in the PreviewService class.
- Implement a mechanism for generating and storing hard-to-guess tokens with TTL support. When any of the custom endpoints are called, the TTL associated with that session's access token should be refreshed. When RefreshPreview is called, a new custom URL and access token with a new TTL should be generated.
- Implement the code to generate the preview from the initial files downloaded from the Trados Cloud Platform API.
- In the StartPreview implementation in the PreviewService class, ensure the background job is set up to call the preview generation implementation.
- Store the resulting initial files and the generated preview content from the above preview implementation locally or in a database.
- The response from the background job (StartPreview/RefreshPreview) should generate a URL as detailed in the previous section which points to the custom endpoint and includes the hard-to-guess access token as a hash fragment. This response should return the Initial Preview Content.
- Subsequent Dynamic Preview Content requests should respond with the relevant dynamic content after authorizing the access token sent in a header in the request. The header name can be decided by the app developer as it will be present in the Initial Preview Content HTML/Javascript and will be sent by the dynamic request (AJAX/JQuery etc) from there.
- If the access token has expired, the app should respond with a 401.
- Any calls to RefreshPreview should generate a new access token.
- Any calls to EndPreview should clean up all local data related to the given Preview Session ID.
- Implement a TTL on the local data. If EndPreview has not been called before the TTL expires, clean up all local data related to the given Preview Session ID.
- Implement UpdateSegment endpoint.
- Ensure UpdateSegment updates ALL dynamic pages generated by the app so that when a particular page is selected, it will have the updated content inside the segment.
- Implement a background job which cleans up sessions after a set interval.
- The TTLs associated with the access tokens and session cleanup should be configurable.


## Javascript API details
The Online Editor Container communicates with the Preview Viewer iframe using the Javascript postMessage mechanism. The API is detailed here in this Javascript file:
```js
"use strict";

/* Communication Protocol between the RWS Online Editor and the preview loaded into it.
 *
 * Based on passing global events back and forth (events on the window object).
 * Used for:
 *
 *      - navigation from one segment to the other (either happening on the editor and
 *        getting propagated to the preview, or happening on the preview - by clicking
 *        a segment - and getting propagated to the editor)
 *
 *      - segment updates: when the translation for a segment changes, the segment
 *        update flow will yield some piece of string (usually html content) that
 *        will be sent to the preview currently being loaded in the editor
 *
 *      - showing messages (could not navigate to the segment currently selected
 *        in editor / cannot update the translation for certain segment)
 */

    // IE compatibility
    Element.prototype.remove = function () {
        this.parentElement.removeChild(this);
}

if (!window.sdlPreviewScriptIncludeGuard) {
    //state
    var selectedSegmentId = "";
    var segmentIdToSigCache = {};
    var initialized = false;

    // events ----------------------------------------------------------------------

    var PREVIEW_SEGMENT_SELECTED = "Preview:segmentSelected";
    var PREVIEW_SHOW_MESSAGE = "Preview:showMessage";
    var UE_SEGMENT_SELECTED = "UE:segmentSelected";
    var UE_UPDATE_SEGMENT = "UE:updateSegment";
}

    // communication ---------------------------------------------------------------

    function onSegmentSelectedInEditor(segmentId) {
        setActiveSegment(segmentId);
}

    function onUpdateSegmentWithTranslation(payload) {
    var segmentId = payload.segmentId;
    var segmentSnippet = payload.snippet;
    updateSegmentWithTranslation(segmentId, segmentSnippet);
}

    function onSegmentSelectedInPreview(segmentId) {
    if (window.chrome && window.chrome.webview) {
        window.chrome.webview.postMessage({
            "type": "selectSegment",
            "segmentId": segmentId
        });
    } else {
        emitEvent(PREVIEW_SEGMENT_SELECTED, segmentId);
    }
}

    function notifyPreviewControlToApplyInitialSelection() {
    if (window.chrome && window.chrome.webview) {
        window.chrome.webview.postMessage({
            "type": "applyInitialSelection"
        });
    }
}

    function notifyNavigationFailure(segmentId) {
    if (window.chrome && window.chrome.webview) {
        window.chrome.webview.postMessage({
            "type": "cannotNavigateToSegment",
            "segmentId": segmentId
        });
    }
    else
    emitEvent(PREVIEW_SHOW_MESSAGE, "CannotNavigateToSegment");
}

    function notifyPreviewUpdateFailure() {
        emitEvent(PREVIEW_SHOW_MESSAGE, "PreviewCannotUpdate");
}

    function emitEvent(eventName, parameter) {
        window.parent.postMessage({
            "eventName": eventName,
            "payload": parameter
        }, '*');
}

    // for scroll sync on side-by-side preview
    if (window.chrome && window.chrome.webview) {
        window.onscroll = () => window.chrome.webview.postMessage({
            "type": "windowScrolled",
            "x": window.scrollX,
            "y": window.scrollY
        });
}

    // segment update --------------------------------------------------------------

    function updateSegmentWithTranslation(segmentId, segmentSnippet) {
    var sigs = segmentIdToSigCache[segmentId];
    if (!sigs || !sigs.length || sigs.length > 1) {
        notifyPreviewUpdateFailure();
    return;
    };

    var sigToReplace = sigs[0];
    var segmentSnippetDom = new DOMParser().parseFromString(segmentSnippet, "text/html");
    updateImagesInSnippet(segmentSnippetDom, sigToReplace);
    updateFieldsInSnippet(segmentSnippetDom, sigToReplace);
    sigToReplace.innerHTML = "";

    var updatedSegment = segmentSnippetDom.getElementsByTagName("segment")[0];

    while (updatedSegment.hasChildNodes()) {
        sigToReplace.appendChild(updatedSegment.firstChild);
    }
}

    function updateImagesInSnippet(segmentSnippetDom, sigToReplace) {
    var snippetImgs = segmentSnippetDom.getElementsByTagName("img");
    var sigImgs = sigToReplace.getElementsByTagName("img");

    if (snippetImgs.length > sigImgs.length) {
        notifyPreviewUpdateFailure();
    return;
    }

    if (snippetImgs.length > 0 && snippetImgs[0].dataset.preserveallimages) {
        // object and it might have multiple images
        for (let i = sigImgs.length - 1; i >= 0; i--) {
        snippetImgs[0].parentElement.insertBefore(sigImgs[i], snippetImgs[0].nextSibling);
        }
    snippetImgs[0].remove();
    } else {
        for (let i = 0; i < snippetImgs.length; i++) {
            var currentImg = snippetImgs[i];
    cloneAttributes(currentImg, sigImgs[i]);
        }
    }
}

    function updateFieldsInSnippet(segmentSnippetDom, sigToReplace) {

    var snippetSpans = segmentSnippetDom.getElementsByTagName("span");

    for (var i = 0; i < snippetSpans.length; i++) {
        var currentSpan = snippetSpans[i];
    if (currentSpan.dataset.field) {
            var fieldType = currentSpan.dataset.field;
    var fieldInDom = sigToReplace.getElementsByTagName(fieldType);

    if (fieldInDom.length !== 1) {
        notifyPreviewUpdateFailure();
    return;
            }

    currentSpan.parentElement.insertBefore(fieldInDom[0], currentSpan);
    currentSpan.remove();
        }
    }
}

    function cloneAttributes(element, sourceNode) {
    var attr;
    var attributes = Array.prototype.slice.call(sourceNode.attributes);
    while ((attr = attributes.pop())) {
        element.setAttribute(attr.nodeName, attr.nodeValue);
    }
}

    // navigation ------------------------------------------------------------------

    function setActiveSegment(segmentId) {
        clearSegmentHighlight(selectedSegmentId);
    selectedSegmentId = segmentId;

    highlightSegment(segmentId, "selected");
    scrollSegmentIntoView(segmentId);
}

    function highlightSegment(segmentId, className) {
    var elements = segmentIdToSigCache[segmentId];
    if (!elements) {
        if (initialized) notifyNavigationFailure(segmentId);
    return;
    }

    for (var i = 0; i < elements.length; i++) {
        var sig = elements[i];
    sig.setAttribute("class", className);
    }
}

    function clearSegmentHighlight(segmentId) {
    if (!segmentId) return;

    var elements = segmentIdToSigCache[segmentId];
    if (!elements) return;

    for (var i = 0; i < elements.length; i++) {
        var sig = elements[i];
    sig.setAttribute("class", "");
    }
}

    function scrollSegmentIntoView(segmentId) {
    var elements = segmentIdToSigCache[segmentId];
    if (!elements) return;

    scrollIntoViewIfNeeded(elements[0]);
}

    function scrollIntoViewIfNeeded(element) {
    if (!element) return;

    var bottomLimit = Math.min(
    document.documentElement.clientHeight,
    document.body.clientHeight
    );
    var rect = element.getBoundingClientRect();

    var overTop = rect.top < 0;
    var overBottom = rect.top + rect.height > bottomLimit;

    if (overTop || overBottom) {
        element.scrollIntoView({ block: "center", inline: "center" });
    }
}

    //Finds y value of given object
    function findPos(obj) {
    var curtop = 0;
    if (obj.offsetParent) {
        do {
        curtop += obj.offsetTop;
        } while ((obj = obj.offsetParent));
    return [curtop];
    }

    return [curtop];
}

    // others ----------------------------------------------------------------------

    function onLoad() {
        var sigs = document.getElementsByTagName("sig");
        segmentIdToSigCache = {};

    for (var i = 0; i < sigs.length; ++i) {
        var current = sigs[i];
    var id = current.getAttribute("data-segment-id");

    if (id) {
        current.onclick = onSigClick;
    current.onmouseover = onSigMouseOver;
    current.onmouseout = onSigMouseOut;

    if (segmentIdToSigCache[id]) {
        segmentIdToSigCache[id].push(current);
            } else {
        segmentIdToSigCache[id] = [current];
            }
        }
    }

    if (selectedSegmentId) setActiveSegment(selectedSegmentId);

    notifyPreviewControlToApplyInitialSelection();

    initialized = true;
}
    function onSigClick() {
    var id = this.getAttribute("data-segment-id");
    setActiveSegment(id);
    onSegmentSelectedInPreview(id);
}

    function onSigMouseOver() {
    var id = this.getAttribute("data-segment-id");
    if (id !== selectedSegmentId) highlightSegment(id, "highlighted");
}

    function onSigMouseOut() {
    var id = this.getAttribute("data-segment-id");
    if (id !== selectedSegmentId) clearSegmentHighlight(id);
}


    // entry point
    window.addEventListener("message", function (event) {
	switch(event.data.eventName) {
	  case UE_SEGMENT_SELECTED:
    onSegmentSelectedInEditor(event.data.payload);
    break;
    case UE_UPDATE_SEGMENT:
    onUpdateSegmentWithTranslation(event.data.payload);
    break;
    default:
    console.log("No handler for event: ", event.data.eventName);
	}
});
    document.addEventListener("DOMContentLoaded", onLoad);