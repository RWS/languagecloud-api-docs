{
  "README.html": {
    "href": "README.html",
    "title": "LanguageCloud-api-docs",
    "summary": "LanguageCloud-api-docs What is it? This the main repository for the Trados Cloud Public API documentation. Can I contribute? Anyone is welcome to contribute to the public Trados Cloud API documentation by making a pull request into the master repository. The documentation is split into the following sections: Articles This section hosts a series of usefull article on: how to get started with writing plug-ins for Trados Cloud how to best use the public APIs how to troubleshoot common issues API Concepts This section hosts the main guidelines on using the Public API along with the API References Getting started with your contribution The documentation is built using a static documentation generator called DocFX. The documentation content is saved in Markdown files and then built into a website using DocFX. The table of content is saved into separate toc.yml files. In order for you to make a contribution directly please follow the next steps: Create a local branch from the main repository Add your changes by modifying existing Markdown files or by adding new Markdown files Adding new files will require updating the toc.yml files. Use the guideline provided by DocFX to learn more. You can use tools such as Notepad++ or Visual Studio Code to edit the content Create a Pull Request with your changes. This pull request will be reviewed for correctness by one of our technical writers Once your pull request has been approved and committed into the main branch, an automatic pipeline will be triggered which will push your changes to the live documentation site if you wish to test your changes locally you can follow the DOCFX Installation guideline and build the entire solution locally Our documentation automatically fills in the product name and other details so you don't have to make the changes manually if we decide to update the product name. Use the 'var:VariableName' construct to tell our documentation engine to fill in the info for you. Here are the constructs available at this point: Var:ProductName - The product name, for example Trados Cloud"
  },
  "Requirements.html": {
    "href": "Requirements.html",
    "title": "Requirements",
    "summary": "Requirements Create a powershell script (convert-reference-links.ps1) that will: Find all links in markdown files in \"./articles/LCPublicAPI/docs/\" and for links that start with \"../reference/ .json/paths/\" replace with: for links that link to operations: \"../api/ -fv.html#/operations/ \" for links that link to scheams: \"../api/ -fv.html#/schemas/ \" Current links in the markdown relative paths are not correct. those are actually referencing files from the /articles/LCPublicAPI/api Second powershell script (convert-contract-links.ps1) that will: Find all links in markdown format (ex: [Translation API](../docs/translations/Translations.md)) in a provided contract file (.json file in \"/articles/Extensibility/api\" or \"/articles/LCPublicAPI/api\") and rename them to *.html Find all links in markdown format (ex: [Upload Zip File](../reference/Public-API.v1.json/paths/~1files/post)) in the given contract (same as above) and: change the url to operationId using hash, example: [Poll Upload Zip File](../reference/Public-API.v1.json/paths/~1files~1{fileId}/get) becomes [Poll Upload Zip File](#/operations/PollUploadZipFile) for schemas the path becomes #/schemas/.. if the url is relative to another contract file format a full relative path, ex: [Poll Upload Zip File](../reference/Public-API.v1.json/paths/~1files~1{fileId}/get) becomes [Poll Upload Zip File](../../LCPublicAPI/api/Public-API.v1-fv.html#/operations/PollUploadZipFile)"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Alignment.AlignmentData.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Alignment.AlignmentData.html",
    "title": "Class AlignmentData",
    "summary": "Class AlignmentData Alignment related information. Inheritance object ExtensionDataContainer AlignmentData Implements ICloneable<AlignmentData> Inherited Members ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Alignment Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class AlignmentData : ExtensionDataContainer, ICloneable<AlignmentData> Constructors AlignmentData() Declaration public AlignmentData() Properties ContentInsertDate Gets or sets the alignment content insert date. Declaration public DateTime ContentInsertDate { get; set; } Property Value Type Description DateTime IncompatibleSpanPairSet Collection of SpanPairNode incompatible alignments. Declaration public List<SpanPairNode> IncompatibleSpanPairSet { get; set; } Property Value Type Description List<SpanPairNode> ModelDate Gets or sets the alignment model creation date. Declaration public DateTime? ModelDate { get; set; } Property Value Type Description DateTime? SpanPairSet Collection of SpanPairNode alignments subject to bilingual compositionality constraints. Declaration public List<SpanPairNode> SpanPairSet { get; set; } Property Value Type Description List<SpanPairNode> TuId The TranslationUnit identifier. Declaration public int TuId { get; set; } Property Value Type Description int Methods Clone() Clones this instance. Declaration public AlignmentData Clone() Returns Type Description AlignmentData Implements ICloneable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Alignment.LiftSpan.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Alignment.LiftSpan.html",
    "title": "Class LiftSpan",
    "summary": "Class LiftSpan A class to represent a continous span of items in an ordered sequence Inheritance object ExtensionDataContainer LiftSpan Implements ICloneable<LiftSpan> Inherited Members ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Alignment Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class LiftSpan : ExtensionDataContainer, ICloneable<LiftSpan> Constructors LiftSpan() Declaration public LiftSpan() Properties Length The length of the span (number of items that it covers in the sequence). Declaration public int Length { get; set; } Property Value Type Description int StartIndex The zero-based start index of the span. Declaration public int StartIndex { get; set; } Property Value Type Description int Methods Clone() Clones this instance. Declaration public LiftSpan Clone() Returns Type Description LiftSpan Implements ICloneable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Alignment.SpanPairNode.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Alignment.SpanPairNode.html",
    "title": "Class SpanPairNode",
    "summary": "Class SpanPairNode Stores information about an alignment between a pair of LiftSpan objects. Inheritance object ExtensionDataContainer SpanPairNode Implements ICloneable<SpanPairNode> Inherited Members ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Alignment Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class SpanPairNode : ExtensionDataContainer, ICloneable<SpanPairNode> Constructors SpanPairNode() Declaration public SpanPairNode() Properties Confidence A value indicating how reliable this alignment should be considered to be. A zero value indicates that no reliability-value can be applied. Otherwise, the value should be no greater than 1, which indicates maximum reliability. Declaration public float Confidence { get; set; } Property Value Type Description float Provenance A value recording how the alignment was produced. Value Description 1 NodeAlignment 2 SeedConfirmation 3 PlaceableAlignment 4 PhraseExtractor 5 Structure 6 TrainedAligner 7 Other Declaration public int Provenance { get; set; } Property Value Type Description int SourceSpan The source LiftSpan. Declaration public LiftSpan SourceSpan { get; set; } Property Value Type Description LiftSpan TargetSpan The target LiftSpan. Declaration public LiftSpan TargetSpan { get; set; } Property Value Type Description LiftSpan Methods Clone() Clones this instance. Declaration public SpanPairNode Clone() Returns Type Description SpanPairNode Implements ICloneable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Alignment.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Alignment.html",
    "title": "Namespace Sdl.Core.Bcm.BcmModel.Alignment",
    "summary": "Namespace Sdl.Core.Bcm.BcmModel.Alignment Classes AlignmentData Alignment related information. LiftSpan A class to represent a continous span of items in an ordered sequence SpanPairNode Stores information about an alignment between a pair of LiftSpan objects."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Annotations.AnnotationContainer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Annotations.AnnotationContainer.html",
    "title": "Class AnnotationContainer",
    "summary": "Class AnnotationContainer Abstract MarkupDataContainer, marking a user annotation on the BCM. Inheritance object ExtensionDataContainer MetadataContainer MarkupData MarkupDataContainer AnnotationContainer CommentContainer TerminologyAnnotationContainer Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> Inherited Members MarkupDataContainer.AutoClonedTagPairKey MarkupDataContainer.GetAllChildren(Func<MarkupData, bool>) MarkupDataContainer.GetAllChildren<T>(Func<T, bool>) MarkupDataContainer.Add(MarkupData) MarkupDataContainer.Add(IEnumerable<MarkupData>) MarkupDataContainer.Insert(int, MarkupData) MarkupDataContainer.Remove(MarkupData) MarkupDataContainer.Clear() MarkupDataContainer.GetEnumerator() MarkupDataContainer.Clone() MarkupDataContainer.MoveToContainer(MarkupDataContainer, int, int, int) MarkupDataContainer.Equals(MarkupDataContainer) MarkupDataContainer.ToString() MarkupDataContainer.OnDeserialized() MarkupDataContainer.UniqueClone() MarkupDataContainer.CloneWithoutChildren() MarkupDataContainer.Children MarkupDataContainer.AllSubItems MarkupDataContainer.Count MarkupDataContainer.this[int] MarkupData.AcceptVisitor(BcmVisitor) MarkupData.Id MarkupData.Type MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.ParentParagraphUnit MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Annotations Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public abstract class AnnotationContainer : MarkupDataContainer, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData> Constructors AnnotationContainer() Declaration protected AnnotationContainer() Properties AnnotationId The annotation ID. Declaration [DataMember(Name = \"annotationId\", EmitDefaultValue = false)] public int AnnotationId { get; set; } Property Value Type Description int Methods Equals(MarkupData) MarkupData based equality. Declaration public override bool Equals(MarkupData other) Parameters Type Name Description MarkupData other Returns Type Description bool Overrides MarkupDataContainer.Equals(MarkupData) Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MarkupDataContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MarkupDataContainer.GetHashCode() Implements IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Annotations.CommentContainer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Annotations.CommentContainer.html",
    "title": "Class CommentContainer",
    "summary": "Class CommentContainer An AnnotationContainer representing user comments. Inheritance object ExtensionDataContainer MetadataContainer MarkupData MarkupDataContainer AnnotationContainer CommentContainer Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> ISkeletonItemReference<CommentDefinition> Inherited Members AnnotationContainer.AnnotationId MarkupDataContainer.AutoClonedTagPairKey MarkupDataContainer.GetAllChildren(Func<MarkupData, bool>) MarkupDataContainer.GetAllChildren<T>(Func<T, bool>) MarkupDataContainer.Add(MarkupData) MarkupDataContainer.Add(IEnumerable<MarkupData>) MarkupDataContainer.Insert(int, MarkupData) MarkupDataContainer.Remove(MarkupData) MarkupDataContainer.Clear() MarkupDataContainer.GetEnumerator() MarkupDataContainer.MoveToContainer(MarkupDataContainer, int, int, int) MarkupDataContainer.Equals(MarkupDataContainer) MarkupDataContainer.ToString() MarkupDataContainer.OnDeserialized() MarkupDataContainer.CloneWithoutChildren() MarkupDataContainer.Children MarkupDataContainer.AllSubItems MarkupDataContainer.Count MarkupDataContainer.this[int] MarkupData.Id MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.ParentParagraphUnit MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Annotations Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class CommentContainer : AnnotationContainer, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData>, ISkeletonItemReference<CommentDefinition> Constructors CommentContainer() Declaration public CommentContainer() Properties CommentDefinitionId Gets or sets the comment definition ID. Declaration [DataMember(Name = \"commentDefinitionId\")] public int CommentDefinitionId { get; set; } Property Value Type Description int The comment definition ID. Definition Gets the CommentDefinition. Declaration public CommentDefinition Definition { get; } Property Value Type Description CommentDefinition Type Gets the MarkupData type. Declaration [JsonProperty(\"type\")] protected override string Type { get; set; } Property Value Type Description string Overrides MarkupData.Type Methods AcceptVisitor(BcmVisitor) Accepts a visitor of type BcmVisitor. Declaration public override void AcceptVisitor(BcmVisitor visitor) Parameters Type Name Description BcmVisitor visitor The BcmVisitor used to visit this item. Overrides MarkupData.AcceptVisitor(BcmVisitor) Clone() Clones this instance. Declaration public CommentContainer Clone() Returns Type Description CommentContainer The clone. Equals(MarkupData) MarkupData based equality. Declaration public override bool Equals(MarkupData other) Parameters Type Name Description MarkupData other Returns Type Description bool Overrides AnnotationContainer.Equals(MarkupData) Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides AnnotationContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides AnnotationContainer.GetHashCode() UniqueClone() Clones this instance using a new uniqueu ID. Declaration public CommentContainer UniqueClone() Returns Type Description CommentContainer The clone. Implements IEquatable<T> ICloneable<T> IEquatable<T> ISkeletonItemReference<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Annotations.TerminologyAnnotationContainer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Annotations.TerminologyAnnotationContainer.html",
    "title": "Class TerminologyAnnotationContainer",
    "summary": "Class TerminologyAnnotationContainer An AnnotationContainer representing terminology-related annotations. Inheritance object ExtensionDataContainer MetadataContainer MarkupData MarkupDataContainer AnnotationContainer TerminologyAnnotationContainer Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> ISkeletonItemReference<TerminologyData> Inherited Members AnnotationContainer.AnnotationId MarkupDataContainer.AutoClonedTagPairKey MarkupDataContainer.GetAllChildren(Func<MarkupData, bool>) MarkupDataContainer.GetAllChildren<T>(Func<T, bool>) MarkupDataContainer.Add(MarkupData) MarkupDataContainer.Add(IEnumerable<MarkupData>) MarkupDataContainer.Insert(int, MarkupData) MarkupDataContainer.Remove(MarkupData) MarkupDataContainer.Clear() MarkupDataContainer.GetEnumerator() MarkupDataContainer.Clone() MarkupDataContainer.MoveToContainer(MarkupDataContainer, int, int, int) MarkupDataContainer.Equals(MarkupDataContainer) MarkupDataContainer.ToString() MarkupDataContainer.OnDeserialized() MarkupDataContainer.UniqueClone() MarkupDataContainer.CloneWithoutChildren() MarkupDataContainer.Children MarkupDataContainer.AllSubItems MarkupDataContainer.Count MarkupDataContainer.this[int] MarkupData.Id MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.ParentParagraphUnit MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Annotations Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class TerminologyAnnotationContainer : AnnotationContainer, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData>, ISkeletonItemReference<TerminologyData> Constructors TerminologyAnnotationContainer() Declaration public TerminologyAnnotationContainer() Properties Definition Gets the TerminologyData definition. Declaration public TerminologyData Definition { get; } Property Value Type Description TerminologyData TerminologyDataId Gets or sets the terminology data identifier. Declaration [DataMember(Name = \"terminologyDataId\")] public int TerminologyDataId { get; set; } Property Value Type Description int The terminology data identifier. Type Gets the MarkupData type. Declaration [JsonProperty(\"type\")] protected override string Type { get; set; } Property Value Type Description string Overrides MarkupData.Type Methods AcceptVisitor(BcmVisitor) Accepts a visitor of type BcmVisitor. Declaration public override void AcceptVisitor(BcmVisitor visitor) Parameters Type Name Description BcmVisitor visitor The BcmVisitor used to visit this item. Overrides MarkupData.AcceptVisitor(BcmVisitor) Equals(MarkupData) MarkupData based equality. Declaration public override bool Equals(MarkupData other) Parameters Type Name Description MarkupData other Returns Type Description bool Overrides AnnotationContainer.Equals(MarkupData) Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides AnnotationContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides AnnotationContainer.GetHashCode() Implements IEquatable<T> ICloneable<T> IEquatable<T> ISkeletonItemReference<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Annotations.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Annotations.html",
    "title": "Namespace Sdl.Core.Bcm.BcmModel.Annotations",
    "summary": "Namespace Sdl.Core.Bcm.BcmModel.Annotations Classes AnnotationContainer Abstract MarkupDataContainer, marking a user annotation on the BCM. CommentContainer An AnnotationContainer representing user comments. TerminologyAnnotationContainer An AnnotationContainer representing terminology-related annotations."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.DictionaryEx-2.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.DictionaryEx-2.html",
    "title": "Class DictionaryEx<TKey, TValue>",
    "summary": "Class DictionaryEx<TKey, TValue> A dictionary with support for: deep Equals (instead of ref comparison) deep GetHashCode (2 refs with the same values will return the same hash code). The default dictionary returns hash code based on reference. Inheritance object Dictionary<TKey, TValue> DictionaryEx<TKey, TValue> Implements IDictionary<TKey, TValue> ICollection<KeyValuePair<TKey, TValue>> IDictionary ICollection IReadOnlyDictionary<TKey, TValue> IReadOnlyCollection<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>> IEnumerable ISerializable IDeserializationCallback IEquatable<DictionaryEx<TKey, TValue>> Inherited Members Dictionary<TKey, TValue>.Add(TKey, TValue) Dictionary<TKey, TValue>.Clear() Dictionary<TKey, TValue>.ContainsKey(TKey) Dictionary<TKey, TValue>.ContainsValue(TValue) Dictionary<TKey, TValue>.GetEnumerator() Dictionary<TKey, TValue>.GetObjectData(SerializationInfo, StreamingContext) Dictionary<TKey, TValue>.OnDeserialization(object) Dictionary<TKey, TValue>.Remove(TKey) Dictionary<TKey, TValue>.Remove(TKey, out TValue) Dictionary<TKey, TValue>.TryGetValue(TKey, out TValue) Dictionary<TKey, TValue>.TryAdd(TKey, TValue) Dictionary<TKey, TValue>.EnsureCapacity(int) Dictionary<TKey, TValue>.TrimExcess() Dictionary<TKey, TValue>.TrimExcess(int) Dictionary<TKey, TValue>.Comparer Dictionary<TKey, TValue>.Count Dictionary<TKey, TValue>.Keys Dictionary<TKey, TValue>.Values Dictionary<TKey, TValue>.this[TKey] object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Collections Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class DictionaryEx<TKey, TValue> : Dictionary<TKey, TValue>, IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, ICollection, IReadOnlyDictionary<TKey, TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, ISerializable, IDeserializationCallback, IEquatable<DictionaryEx<TKey, TValue>> Type Parameters Name Description TKey TValue Constructors DictionaryEx() Initializes a new instance of the DictionaryEx<TKey, TValue> class. Declaration public DictionaryEx() DictionaryEx(DictionaryEx<TKey, TValue>) Initializes a new instance of the DictionaryEx<TKey, TValue> class, based on another instance. Declaration public DictionaryEx(DictionaryEx<TKey, TValue> other) Parameters Type Name Description DictionaryEx<TKey, TValue> other The other instance from which to construct the current instance. DictionaryEx(IEnumerable<KeyValuePair<TKey, TValue>>) Initializes a new instance of the DictionaryEx<TKey, TValue> class. Declaration public DictionaryEx(IEnumerable<KeyValuePair<TKey, TValue>> items) Parameters Type Name Description IEnumerable<KeyValuePair<TKey, TValue>> items The items. Methods Equals(DictionaryEx<TKey, TValue>) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public bool Equals(DictionaryEx<TKey, TValue> other) Parameters Type Name Description DictionaryEx<TKey, TValue> other Returns Type Description bool Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides object.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides object.GetHashCode() Implements IDictionary<TKey, TValue> ICollection<T> IDictionary ICollection IReadOnlyDictionary<TKey, TValue> IReadOnlyCollection<T> IEnumerable<T> IEnumerable ISerializable IDeserializationCallback IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.FileCollection.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.FileCollection.html",
    "title": "Class FileCollection",
    "summary": "Class FileCollection A dictionary-based collection of Files. Inheritance object Collection<File> KeyedCollection<string, File> KeyBasedCollection<string, File> FileCollection Implements IList<File> ICollection<File> IList ICollection IReadOnlyList<File> IReadOnlyCollection<File> IEnumerable<File> IEnumerable IEquatable<KeyBasedCollection<string, File>> Inherited Members KeyBasedCollection<string, File>.KeySelector KeyBasedCollection<string, File>.ForEach(Action<File>) KeyBasedCollection<string, File>.Equals(KeyBasedCollection<string, File>) KeyBasedCollection<string, File>.Equals(object) KeyBasedCollection<string, File>.GetHashCode() KeyBasedCollection<string, File>.GetKeyForItem(File) KeyedCollection<string, File>.Contains(string) KeyedCollection<string, File>.TryGetValue(string, out File) KeyedCollection<string, File>.Remove(string) KeyedCollection<string, File>.ChangeItemKey(File, string) KeyedCollection<string, File>.ClearItems() KeyedCollection<string, File>.InsertItem(int, File) KeyedCollection<string, File>.RemoveItem(int) KeyedCollection<string, File>.SetItem(int, File) KeyedCollection<string, File>.Comparer KeyedCollection<string, File>.this[string] KeyedCollection<string, File>.Dictionary Collection<File>.Add(File) Collection<File>.Clear() Collection<File>.CopyTo(File[], int) Collection<File>.Contains(File) Collection<File>.GetEnumerator() Collection<File>.IndexOf(File) Collection<File>.Insert(int, File) Collection<File>.Remove(File) Collection<File>.RemoveAt(int) Collection<File>.ClearItems() Collection<File>.RemoveItem(int) Collection<File>.Count Collection<File>.Items Collection<File>.this[int] object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Collections Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class FileCollection : KeyBasedCollection<string, File>, IList<File>, ICollection<File>, IList, ICollection, IReadOnlyList<File>, IReadOnlyCollection<File>, IEnumerable<File>, IEnumerable, IEquatable<KeyBasedCollection<string, File>> Constructors FileCollection() Initializes a new instance of the FileCollection class. Declaration public FileCollection() Properties IdGenerator The identifier generator. Declaration public IdGenerator IdGenerator { get; set; } Property Value Type Description IdGenerator Methods InsertItem(int, File) Inserts an element into the KeyedCollection<TKey, TItem> at the specified index. Declaration protected override void InsertItem(int index, File item) Parameters Type Name Description int index The zero-based index at which item should be inserted. File item The object to insert. Overrides KeyedCollection<string, File>.InsertItem(int, File) SetItem(int, File) Replaces the item at the specified index with the specified item. Declaration protected override void SetItem(int index, File item) Parameters Type Name Description int index The zero-based index of the item to be replaced. File item The new item. Overrides KeyedCollection<string, File>.SetItem(int, File) Implements IList<T> ICollection<T> IList ICollection IReadOnlyList<T> IReadOnlyCollection<T> IEnumerable<T> IEnumerable IEquatable<T> Extension Methods ModelExtensions.IsSequenceEqual<TSource>(IList<TSource>, IList<TSource>)"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.HashDictionaryInt-2.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.HashDictionaryInt-2.html",
    "title": "Class HashDictionaryInt<TKey, TValue>",
    "summary": "Class HashDictionaryInt<TKey, TValue> A dictionary which uses hashes generated from the key to store items in a backing dictionary. We may look at generating long hashes eventually if there are many collisions detected. Inheritance object HashDictionaryInt<TKey, TValue> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Collections Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class HashDictionaryInt<TKey, TValue> Type Parameters Name Description TKey Item from which key will be derived. At the moment, GetHashCode is called on the key to use as actual key in backing Dictionary TValue value for given key being stored in dictionary Constructors HashDictionaryInt() Initializes a new instance of the HashDictionaryInt<TKey, TValue> class. Declaration public HashDictionaryInt() Fields _backingDictionary The backing dictionary. Declaration public Dictionary<int, List<KeyValuePair<TKey, TValue>>> _backingDictionary Field Value Type Description Dictionary<int, List<KeyValuePair<TKey, TValue>>> Properties this[TKey] Gets the TKey with the specified key. Declaration public TValue this[TKey key] { get; } Parameters Type Name Description TKey key The key. Property Value Type Description TValue The TValue. Exceptions Type Condition InvalidOperationException Multiple matches found in collection or Key not found in collection Methods Add(TKey, TValue) Adds the specified key. Declaration public void Add(TKey key, TValue value) Parameters Type Name Description TKey key The key. TValue value The value. Exceptions Type Condition InvalidOperationException Item with same key already exists in collection Clear() Removes all keys and values from this instance. Declaration public void Clear() ContainsKey(TKey) Determines whether the collection contains the specified key. Declaration public bool ContainsKey(TKey key) Parameters Type Name Description TKey key The key. Returns Type Description bool true if the collection contains the specified key; otherwise, false. Exceptions Type Condition InvalidOperationException Multiple matches found in collection GetHashCodeInternal(TKey) Gets the internal hash code used in the backing dictionary. Declaration protected virtual int GetHashCodeInternal(TKey key) Parameters Type Name Description TKey key The key. Returns Type Description int Remove(TKey) Removes the specified key. Declaration public bool Remove(TKey key) Parameters Type Name Description TKey key The key. Returns Type Description bool Exceptions Type Condition InvalidOperationException Multiple matches found in collection TryGetValue(TKey, out TValue) Tries to get a value by key. Declaration public bool TryGetValue(TKey key, out TValue value) Parameters Type Name Description TKey key The key. TValue value The value. Returns Type Description bool"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.KeyBasedCollection-2.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.KeyBasedCollection-2.html",
    "title": "Class KeyBasedCollection<TKey, TValue>",
    "summary": "Class KeyBasedCollection<TKey, TValue> A KeyBasedCollection<TKey, TValue> implementation with support for deep equality. Inheritance object Collection<TValue> KeyedCollection<TKey, TValue> KeyBasedCollection<TKey, TValue> FileCollection ParagraphUnitCollection SubContentCollection Implements IList<TValue> ICollection<TValue> IList ICollection IReadOnlyList<TValue> IReadOnlyCollection<TValue> IEnumerable<TValue> IEnumerable IEquatable<KeyBasedCollection<TKey, TValue>> Inherited Members KeyedCollection<TKey, TValue>.Contains(TKey) KeyedCollection<TKey, TValue>.TryGetValue(TKey, out TValue) KeyedCollection<TKey, TValue>.Remove(TKey) KeyedCollection<TKey, TValue>.ChangeItemKey(TValue, TKey) KeyedCollection<TKey, TValue>.ClearItems() KeyedCollection<TKey, TValue>.GetKeyForItem(TValue) KeyedCollection<TKey, TValue>.InsertItem(int, TValue) KeyedCollection<TKey, TValue>.RemoveItem(int) KeyedCollection<TKey, TValue>.SetItem(int, TValue) KeyedCollection<TKey, TValue>.Comparer KeyedCollection<TKey, TValue>.this[TKey] KeyedCollection<TKey, TValue>.Dictionary Collection<TValue>.Add(TValue) Collection<TValue>.Clear() Collection<TValue>.CopyTo(TValue[], int) Collection<TValue>.Contains(TValue) Collection<TValue>.GetEnumerator() Collection<TValue>.IndexOf(TValue) Collection<TValue>.Insert(int, TValue) Collection<TValue>.Remove(TValue) Collection<TValue>.RemoveAt(int) Collection<TValue>.ClearItems() Collection<TValue>.InsertItem(int, TValue) Collection<TValue>.RemoveItem(int) Collection<TValue>.SetItem(int, TValue) Collection<TValue>.Count Collection<TValue>.Items Collection<TValue>.this[int] object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Collections Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class KeyBasedCollection<TKey, TValue> : KeyedCollection<TKey, TValue>, IList<TValue>, ICollection<TValue>, IList, ICollection, IReadOnlyList<TValue>, IReadOnlyCollection<TValue>, IEnumerable<TValue>, IEnumerable, IEquatable<KeyBasedCollection<TKey, TValue>> Type Parameters Name Description TKey The key. TValue The value. Constructors KeyBasedCollection() Initializes a new instance of the KeyBasedCollection<TKey, TValue> class. Declaration protected KeyBasedCollection() KeyBasedCollection(Func<TValue, TKey>) Initializes a new instance of the KeyBasedCollection<TKey, TValue> class. Declaration public KeyBasedCollection(Func<TValue, TKey> keySelector) Parameters Type Name Description Func<TValue, TKey> keySelector The key selector. Fields KeySelector The key selector. Declaration protected Func<TValue, TKey> KeySelector Field Value Type Description Func<TValue, TKey> Methods Equals(KeyBasedCollection<TKey, TValue>) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(KeyBasedCollection<TKey, TValue> other) Parameters Type Name Description KeyBasedCollection<TKey, TValue> other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides object.Equals(object) ForEach(Action<TValue>) Executes an action over each element of the collection. Declaration public void ForEach(Action<TValue> action) Parameters Type Name Description Action<TValue> action The action. GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides object.GetHashCode() GetKeyForItem(TValue) When implemented in a derived class, extracts the key from the specified element. Declaration protected override TKey GetKeyForItem(TValue item) Parameters Type Name Description TValue item The element from which to extract the key. Returns Type Description TKey The key for the specified element. Overrides KeyedCollection<TKey, TValue>.GetKeyForItem(TValue) Implements IList<T> ICollection<T> IList ICollection IReadOnlyList<T> IReadOnlyCollection<T> IEnumerable<T> IEnumerable IEquatable<T> Extension Methods ModelExtensions.IsSequenceEqual<TSource>(IList<TSource>, IList<TSource>)"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.ParagraphUnitCollection.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.ParagraphUnitCollection.html",
    "title": "Class ParagraphUnitCollection",
    "summary": "Class ParagraphUnitCollection A KeyBasedCollection<TKey, TValue> of ParagraphUnits. Adds support for setting the parent elements and additonal helper properties. Inheritance object Collection<ParagraphUnit> KeyedCollection<string, ParagraphUnit> KeyBasedCollection<string, ParagraphUnit> ParagraphUnitCollection Implements IList<ParagraphUnit> ICollection<ParagraphUnit> IList ICollection IReadOnlyList<ParagraphUnit> IReadOnlyCollection<ParagraphUnit> IEnumerable<ParagraphUnit> IEnumerable IEquatable<KeyBasedCollection<string, ParagraphUnit>> Inherited Members KeyBasedCollection<string, ParagraphUnit>.KeySelector KeyBasedCollection<string, ParagraphUnit>.ForEach(Action<ParagraphUnit>) KeyBasedCollection<string, ParagraphUnit>.Equals(KeyBasedCollection<string, ParagraphUnit>) KeyBasedCollection<string, ParagraphUnit>.Equals(object) KeyBasedCollection<string, ParagraphUnit>.GetHashCode() KeyBasedCollection<string, ParagraphUnit>.GetKeyForItem(ParagraphUnit) KeyedCollection<string, ParagraphUnit>.Contains(string) KeyedCollection<string, ParagraphUnit>.TryGetValue(string, out ParagraphUnit) KeyedCollection<string, ParagraphUnit>.Remove(string) KeyedCollection<string, ParagraphUnit>.ChangeItemKey(ParagraphUnit, string) KeyedCollection<string, ParagraphUnit>.ClearItems() KeyedCollection<string, ParagraphUnit>.InsertItem(int, ParagraphUnit) KeyedCollection<string, ParagraphUnit>.RemoveItem(int) KeyedCollection<string, ParagraphUnit>.SetItem(int, ParagraphUnit) KeyedCollection<string, ParagraphUnit>.Comparer KeyedCollection<string, ParagraphUnit>.this[string] KeyedCollection<string, ParagraphUnit>.Dictionary Collection<ParagraphUnit>.Add(ParagraphUnit) Collection<ParagraphUnit>.Clear() Collection<ParagraphUnit>.CopyTo(ParagraphUnit[], int) Collection<ParagraphUnit>.Contains(ParagraphUnit) Collection<ParagraphUnit>.GetEnumerator() Collection<ParagraphUnit>.IndexOf(ParagraphUnit) Collection<ParagraphUnit>.Insert(int, ParagraphUnit) Collection<ParagraphUnit>.Remove(ParagraphUnit) Collection<ParagraphUnit>.RemoveAt(int) Collection<ParagraphUnit>.ClearItems() Collection<ParagraphUnit>.RemoveItem(int) Collection<ParagraphUnit>.SetItem(int, ParagraphUnit) Collection<ParagraphUnit>.Count Collection<ParagraphUnit>.Items Collection<ParagraphUnit>.this[int] object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Collections Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class ParagraphUnitCollection : KeyBasedCollection<string, ParagraphUnit>, IList<ParagraphUnit>, ICollection<ParagraphUnit>, IList, ICollection, IReadOnlyList<ParagraphUnit>, IReadOnlyCollection<ParagraphUnit>, IEnumerable<ParagraphUnit>, IEnumerable, IEquatable<KeyBasedCollection<string, ParagraphUnit>> Constructors ParagraphUnitCollection() Initializes a new instance of the ParagraphUnitCollection class. Declaration public ParagraphUnitCollection() Properties AllSegmentPairs Gets all segment pairs. Declaration public IEnumerable<SegmentPair> AllSegmentPairs { get; } Property Value Type Description IEnumerable<SegmentPair> All segment pairs. ParentFile Gets or sets the parent file. Declaration public File ParentFile { get; set; } Property Value Type Description File The parent file. SegmentCount Gets the segment count. Declaration public int SegmentCount { get; } Property Value Type Description int The segment count. Methods InsertItem(int, ParagraphUnit) Inserts an element into the KeyedCollection<TKey, TItem> at the specified index. Declaration protected override void InsertItem(int index, ParagraphUnit item) Parameters Type Name Description int index The zero-based index at which item should be inserted. ParagraphUnit item The object to insert. Overrides KeyedCollection<string, ParagraphUnit>.InsertItem(int, ParagraphUnit) Implements IList<T> ICollection<T> IList ICollection IReadOnlyList<T> IReadOnlyCollection<T> IEnumerable<T> IEnumerable IEquatable<T> Extension Methods ModelExtensions.IsSequenceEqual<TSource>(IList<TSource>, IList<TSource>)"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.SegmentPairCollection.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.SegmentPairCollection.html",
    "title": "Class SegmentPairCollection",
    "summary": "Class SegmentPairCollection A collection of SegmentPairs. Adds support for indexing by segment number. Inheritance object SegmentPairCollection Implements IEnumerable<SegmentPair> IEnumerable Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Collections Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class SegmentPairCollection : IEnumerable<SegmentPair>, IEnumerable Constructors SegmentPairCollection(IEnumerable<SegmentPair>) Initializes a new instance of the SegmentPairCollection class. Declaration public SegmentPairCollection(IEnumerable<SegmentPair> enumerable) Parameters Type Name Description IEnumerable<SegmentPair> enumerable The enumerable. Properties this[string] Gets the SegmentPair with the specified segment number. Declaration public SegmentPair this[string segmentNumber] { get; } Parameters Type Name Description string segmentNumber The segment number. Property Value Type Description SegmentPair The SegmentPair. Methods GetEnumerator() Returns an enumerator that iterates through the collection. Declaration public IEnumerator<SegmentPair> GetEnumerator() Returns Type Description IEnumerator<SegmentPair> An enumerator that can be used to iterate through the collection. Implements IEnumerable<T> IEnumerable"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Collections.html",
    "title": "Namespace Sdl.Core.Bcm.BcmModel.Collections",
    "summary": "Namespace Sdl.Core.Bcm.BcmModel.Collections Classes DictionaryEx<TKey, TValue> A dictionary with support for: deep Equals (instead of ref comparison) deep GetHashCode (2 refs with the same values will return the same hash code). The default dictionary returns hash code based on reference. FileCollection A dictionary-based collection of Files. HashDictionaryInt<TKey, TValue> A dictionary which uses hashes generated from the key to store items in a backing dictionary. We may look at generating long hashes eventually if there are many collisions detected. KeyBasedCollection<TKey, TValue> A KeyBasedCollection<TKey, TValue> implementation with support for deep equality. ParagraphUnitCollection A KeyBasedCollection<TKey, TValue> of ParagraphUnits. Adds support for setting the parent elements and additonal helper properties. SegmentPairCollection A collection of SegmentPairs. Adds support for indexing by segment number."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Common.BcmConst.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Common.BcmConst.html",
    "title": "Class BcmConst",
    "summary": "Class BcmConst Public constants. Inheritance object BcmConst Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Common Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public static class BcmConst Fields CurrentBcmModelVersion The current BCM model version. Declaration public static readonly string CurrentBcmModelVersion Field Value Type Description string DateTimeFormat DateTime format for serializing and deserializing BCM DateTime properties. Declaration public const string DateTimeFormat = \"yyyy-MM-dd'T'HH:mm:ss.fff'Z'\" Field Value Type Description string FrameworkOriginalParagraphUnitId Metadata key for storing the original ParagraphUnit ID, populated by the SDL Filter Framework. Declaration public const string FrameworkOriginalParagraphUnitId = \"frameworkOriginalParagraphUnitId\" Field Value Type Description string FrameworkOriginalTagId Metadata key for storing the original tag ID, populated by the SDL Filter Framework. Declaration public const string FrameworkOriginalTagId = \"frameworkOriginalTagId\" Field Value Type Description string KeepContextFromPreviousParagraph Metadata used for conversion from BCM back to native format. If this metadata is True , the same contexts are used. If False , new contexts are created from the BCM contexts. Declaration public const string KeepContextFromPreviousParagraph = \"_keepContextFromPreviousParagraph\" Field Value Type Description string"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Common.BcmModelValidation.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Common.BcmModelValidation.html",
    "title": "Class BcmModelValidation",
    "summary": "Class BcmModelValidation Inheritance object BcmModelValidation Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Common Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public static class BcmModelValidation Fields ExcludeBaseTypes Declaration public static readonly IEnumerable<Type> ExcludeBaseTypes Field Value Type Description IEnumerable<Type>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Common.BcmVisitor.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Common.BcmVisitor.html",
    "title": "Class BcmVisitor",
    "summary": "Class BcmVisitor An abstract class using the Visitor pattern. Can be implemented for concrete processing of BCM documents. Inheritance object BcmVisitor Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Common Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public abstract class BcmVisitor Constructors BcmVisitor() Declaration protected BcmVisitor() Methods VisitCommentContainer(CommentContainer) Visits a CommentContainer instance. Declaration public abstract void VisitCommentContainer(CommentContainer commentContainer) Parameters Type Name Description CommentContainer commentContainer VisitFeedbackContainer(FeedbackContainer) Visits a FeedbackContainer instance. Declaration public abstract void VisitFeedbackContainer(FeedbackContainer feedbackContainer) Parameters Type Name Description FeedbackContainer feedbackContainer VisitLockedContentContainer(LockedContentContainer) Visits a LockedContentContainer instance. Declaration public abstract void VisitLockedContentContainer(LockedContentContainer lockedContentContainer) Parameters Type Name Description LockedContentContainer lockedContentContainer VisitParagraph(Paragraph) Visits a Paragraph instance. Declaration public abstract void VisitParagraph(Paragraph paragraph) Parameters Type Name Description Paragraph paragraph VisitPlaceholderTag(PlaceholderTag) Visits a PlaceholderTag instance. Declaration public abstract void VisitPlaceholderTag(PlaceholderTag tag) Parameters Type Name Description PlaceholderTag tag VisitRevisionContainer(RevisionContainer) Visits a RevisionContainer instance. Declaration public abstract void VisitRevisionContainer(RevisionContainer revisionContainer) Parameters Type Name Description RevisionContainer revisionContainer VisitSegment(Segment) Visits a Segment instance. Declaration public abstract void VisitSegment(Segment segment) Parameters Type Name Description Segment segment VisitStructure(StructureTag) Visits a StructureTag instance. Declaration public abstract void VisitStructure(StructureTag structureTag) Parameters Type Name Description StructureTag structureTag The structure tag. VisitTagPair(TagPair) Visits a StructureTag instance. Declaration public abstract void VisitTagPair(TagPair tagPair) Parameters Type Name Description TagPair tagPair VisitTerminologyContainer(TerminologyAnnotationContainer) Visits a TerminologyAnnotationContainer instance. Declaration public abstract void VisitTerminologyContainer(TerminologyAnnotationContainer terminologyAnnotation) Parameters Type Name Description TerminologyAnnotationContainer terminologyAnnotation VisitText(TextMarkup) Visits a TextMarkup instance. Declaration public abstract void VisitText(TextMarkup text) Parameters Type Name Description TextMarkup text"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Common.DefaultTranslationOrigin.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Common.DefaultTranslationOrigin.html",
    "title": "Class DefaultTranslationOrigin",
    "summary": "Class DefaultTranslationOrigin This class holds the constants that represent the suggested default values to use for the TSdl.Core.Bcm.BcmModel.TranslationOrigin.OriginType attribute. Inheritance object DefaultTranslationOrigin Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Common Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public static class DefaultTranslationOrigin Fields AdaptiveMachineTranslation Adaptive machine translated content Declaration public const string AdaptiveMachineTranslation = \"amt\" Field Value Type Description string AutoPropagated The segment has been translated using AutoPropagation from internal matches. Declaration public const string AutoPropagated = \"auto-propagated\" Field Value Type Description string AutomatedAlignment The translated segment was created by an automated linguistic alignment of previously translated source and target content. Declaration public const string AutomatedAlignment = \"auto-aligned\" Field Value Type Description string AutomaticTranslation Adaptive machine translated content Declaration public const string AutomaticTranslation = \"automatic-translation\" Field Value Type Description string DocumentMatch Batch translation by applying a Context TM type tool like PerfectMatch(tm) Declaration public const string DocumentMatch = \"document-match\" Field Value Type Description string Interactive The segment has been manually adapted or translated from scratch. Declaration public const string Interactive = \"interactive\" Field Value Type Description string MachineTranslation Machine translated content Declaration public const string MachineTranslation = \"mt\" Field Value Type Description string NeuralMachineTranslation Adaptive machine translated content Declaration public const string NeuralMachineTranslation = \"nmt\" Field Value Type Description string NotTranslated The segment has not yet been translated. This is usually an empty segment. Declaration public const string NotTranslated = \"not-translated\" Field Value Type Description string ReverseAlignment The segment was updated by ReverseAlignment process. Declaration public const string ReverseAlignment = \"Retrofit\" Field Value Type Description string Source The segment has been translated by copying the source to the target. Declaration public const string Source = \"source\" Field Value Type Description string TranslationMemory Batch pre-translation using a fuzzy or 100% match Declaration public const string TranslationMemory = \"tm\" Field Value Type Description string Unknown The segment was translated by an unknown tool - usually from a third party provider. Declaration public const string Unknown = \"unknown\" Field Value Type Description string"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Common.ICloneable-1.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Common.ICloneable-1.html",
    "title": "Interface ICloneable<T>",
    "summary": "Interface ICloneable<T> Typed ICloneable interface. Namespace: Sdl.Core.Bcm.BcmModel.Common Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public interface ICloneable<out T> Type Parameters Name Description T Methods Clone() Clones this instance. Declaration T Clone() Returns Type Description T"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Common.ModelExtensions.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Common.ModelExtensions.html",
    "title": "Class ModelExtensions",
    "summary": "Class ModelExtensions Extension methods. Inheritance object ModelExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Common Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public static class ModelExtensions Methods IsSequenceEqual<TSource>(IList<TSource>, IList<TSource>) Performs a deep comparison between two IList<T> Declaration public static bool IsSequenceEqual<TSource>(this IList<TSource> first, IList<TSource> second) Parameters Type Name Description IList<TSource> first The first collection. IList<TSource> second The second collection. Returns Type Description bool True if the collections are deeply equal. Otherwise false. Type Parameters Name Description TSource The collection element type."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Common.TranslationQualityEstimationConstants.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Common.TranslationQualityEstimationConstants.html",
    "title": "Class TranslationQualityEstimationConstants",
    "summary": "Class TranslationQualityEstimationConstants Defines constants for TQE metadata in Binlingual API content Inheritance object TranslationQualityEstimationConstants Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Common Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public static class TranslationQualityEstimationConstants Fields TqeDescription TQE description - a machine generated description Declaration public const string TqeDescription = \"tqe-description\" Field Value Type Description string TqeEvaluatedAt Indicates the date and time in UTC that the TQE was evaluated at Declaration public const string TqeEvaluatedAt = \"tqe-evaluated-at\" Field Value Type Description string TqeModel Model used to evaluate TQE - e.g. daVinci, Bedrock Declaration public const string TqeModel = \"tqe-model\" Field Value Type Description string TqeScore Score of TQE evalutation - a value between 0 and 100 inclusive Declaration public const string TqeScore = \"tqe-score\" Field Value Type Description string TqeSystem System from which TQE originted - e.g. lw-mt Declaration public const string TqeSystem = \"tqe-system\" Field Value Type Description string"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Common.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Common.html",
    "title": "Namespace Sdl.Core.Bcm.BcmModel.Common",
    "summary": "Namespace Sdl.Core.Bcm.BcmModel.Common Classes BcmConst Public constants. BcmModelValidation BcmVisitor An abstract class using the Visitor pattern. Can be implemented for concrete processing of BCM documents. DefaultTranslationOrigin This class holds the constants that represent the suggested default values to use for the TSdl.Core.Bcm.BcmModel.TranslationOrigin.OriginType attribute. ModelExtensions Extension methods. TranslationQualityEstimationConstants Defines constants for TQE metadata in Binlingual API content Interfaces ICloneable<T> Typed ICloneable interface."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.ConfirmationLevel.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.ConfirmationLevel.html",
    "title": "Enum ConfirmationLevel",
    "summary": "Enum ConfirmationLevel Different stages of translation and translation approval for a Segment. Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [JsonConverter(typeof(EnumConverter), new object[] { ConfirmationLevel.NotTranslated })] public enum ConfirmationLevel Fields Name Description ApprovedSignOff Translated content Approved at Sign-off. ApprovedTranslation Translated content marked as Approved. Draft Draft (edited) content. NotTranslated Untranslated content. RejectedSignOff Translated content Rejected at Sign-off. RejectedTranslation Translated content marked as Rejected. Translated Translated content."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.DependencyFile.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.DependencyFile.html",
    "title": "Class DependencyFile",
    "summary": "Class DependencyFile Files marked as dependencies for the BCM content. Used for conversion from and to native formats. Inheritance object ExtensionDataContainer MetadataContainer DependencyFile Implements IEquatable<MetadataContainer> ICloneable<DependencyFile> IEquatable<DependencyFile> Inherited Members MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class DependencyFile : MetadataContainer, IEquatable<MetadataContainer>, ICloneable<DependencyFile>, IEquatable<DependencyFile> Constructors DependencyFile() Declaration public DependencyFile() Properties EmbeddedContent Gets or sets the embedded content. Declaration [DataMember(Name = \"embeddedContent\")] [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)] public string EmbeddedContent { get; set; } Property Value Type Description string The embedded content. Remarks In the cases where the dependency file is stored inline, this will contain the B64-encoded ZIP archive of the dependency file FileId The id of the given file in the BCM document. This is used for multi-file sections in the BCM document and for matching the dependency section to the given file section in the BCM document Declaration [DataMember(Name = \"fileId\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public string FileId { get; set; } Property Value Type Description string FileName Gets or sets the name of the file. Declaration [DataMember(Name = \"fileName\")] public string FileName { get; set; } Property Value Type Description string The name of the file. Id The DependencyFile Id. Declaration [DataMember(Name = \"id\")] public string Id { get; set; } Property Value Type Description string Location Gets or sets the file location. Declaration [DataMember(Name = \"location\")] public string Location { get; set; } Property Value Type Description string The file location. Provider Gets or sets the system providing the file. Declaration [DataMember(Name = \"provider\")] [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)] public string Provider { get; set; } Property Value Type Description string The system providing the file. Usage Gets or sets the purpose of the dependency file. Declaration [DataMember(Name = \"usage\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public DependencyFileUsage Usage { get; set; } Property Value Type Description DependencyFileUsage The purpose of the dependency file. Methods Clone() Clones this instance. Declaration public DependencyFile Clone() Returns Type Description DependencyFile Equals(DependencyFile) Performs a deep-equals comparison. Declaration public bool Equals(DependencyFile other) Parameters Type Name Description DependencyFile other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MetadataContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MetadataContainer.GetHashCode() Implements IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.DependencyFileUsage.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.DependencyFileUsage.html",
    "title": "Enum DependencyFileUsage",
    "summary": "Enum DependencyFileUsage Defines the purpose of a DependencyFile. Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [JsonConverter(typeof(EnumConverter), new object[] { DependencyFileUsage.None })] public enum DependencyFileUsage Fields Name Description Extraction Used during the extraction phase. Final Used or required for correct operation of the final (localized) file. Generation Used during the generate phase. None Unknown or not specified."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Document.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Document.html",
    "title": "Class Document",
    "summary": "Class Document The BCM root element. Inheritance object ExtensionDataContainer MetadataContainer Document Implements IEquatable<MetadataContainer> ICloneable<Document> IEquatable<Document> Inherited Members MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class Document : MetadataContainer, IEquatable<MetadataContainer>, ICloneable<Document>, IEquatable<Document> Constructors Document() Public constructor. Declaration public Document() Properties Files A collection of all the Files in this document. Declaration [DataMember(Name = \"files\")] public FileCollection Files { get; set; } Property Value Type Description FileCollection Id The document ID. Uniquely identifies a BCM document. Declaration [DataMember(Name = \"id\")] public string Id { get; set; } Property Value Type Description string IdGenerator Used for managing sequential numeric IDs of different elements. Declaration public IdGenerator IdGenerator { get; } Property Value Type Description IdGenerator ModelVersion The semantic version of the BCM used for creating this document. Declaration [DataMember(Name = \"modelVersion\")] public string ModelVersion { get; } Property Value Type Description string Name The BCM document name. Declaration [DataMember(Name = \"name\")] public string Name { get; set; } Property Value Type Description string SourceLanguageCode The source language code. Declaration [DataMember(Name = \"sourceLanguageCode\")] public string SourceLanguageCode { get; set; } Property Value Type Description string Examples \"en-GB\" SourceLanguageName Gets or sets the source language display name. Declaration [Obsolete(\"Will be removed in a future version. Use the LanguageRegistry instead for retrieving language information.\")] [DataMember(Name = \"sourceLanguageName\", EmitDefaultValue = false)] public string SourceLanguageName { get; set; } Property Value Type Description string The name of the source language. TargetLanguageCode The source language code. Declaration [DataMember(Name = \"targetLanguageCode\")] public string TargetLanguageCode { get; set; } Property Value Type Description string Examples \"de-DE\" TargetLanguageName Gets or sets the target language display name. Declaration [Obsolete(\"Will be removed in a future version. Use the LanguageRegistry instead for retrieving language information.\")] [DataMember(Name = \"targetLanguageName\", EmitDefaultValue = false)] public string TargetLanguageName { get; set; } Property Value Type Description string The name of the target language. Methods Clone() Deep-clones a Document. Declaration public Document Clone() Returns Type Description Document DeserializeFromString(string) Declaration public static Document DeserializeFromString(string json) Parameters Type Name Description string json Returns Type Description Document Equals(Document) Performs a deep-equals comparison. Declaration public bool Equals(Document other) Parameters Type Name Description Document other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MetadataContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MetadataContainer.GetHashCode() Implements IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Exceptions.InvalidBcmDocumentException.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Exceptions.InvalidBcmDocumentException.html",
    "title": "Class InvalidBcmDocumentException",
    "summary": "Class InvalidBcmDocumentException Inheritance object Exception InvalidBcmDocumentException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Exceptions Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class InvalidBcmDocumentException : Exception, ISerializable Constructors InvalidBcmDocumentException(SerializationInfo, StreamingContext) Declaration protected InvalidBcmDocumentException(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context InvalidBcmDocumentException(string) Declaration public InvalidBcmDocumentException(string message) Parameters Type Name Description string message Implements ISerializable"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Exceptions.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Exceptions.html",
    "title": "Namespace Sdl.Core.Bcm.BcmModel.Exceptions",
    "summary": "Namespace Sdl.Core.Bcm.BcmModel.Exceptions Classes InvalidBcmDocumentException"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.ExtensionDataContainer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.ExtensionDataContainer.html",
    "title": "Class ExtensionDataContainer",
    "summary": "Class ExtensionDataContainer A Newtonsoft.Json.JsonExtensionDataAttribute object used as base for elements that need to preserve unrecognized data on deserialization. Inheritance object ExtensionDataContainer AlignmentData LiftSpan SpanPairNode LocalizableSubContent MetadataContainer SegmentPair Term TermOrigin TermTranslation SegmentPosition SegmentRange Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public abstract class ExtensionDataContainer Constructors ExtensionDataContainer() Declaration protected ExtensionDataContainer() Properties ExtensionData Preserves any unrecognized data upon deserialization from JSON. This data is serialized in its original format. Declaration [JsonExtensionData] public IDictionary<string, JToken> ExtensionData { get; set; } Property Value Type Description IDictionary<string, JToken>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.FeedbackContainer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.FeedbackContainer.html",
    "title": "Class FeedbackContainer",
    "summary": "Class FeedbackContainer Holds feedback information created during the translation and review process. Inheritance object ExtensionDataContainer MetadataContainer MarkupData MarkupDataContainer FeedbackContainer Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> Inherited Members MarkupDataContainer.AutoClonedTagPairKey MarkupDataContainer.GetAllChildren(Func<MarkupData, bool>) MarkupDataContainer.GetAllChildren<T>(Func<T, bool>) MarkupDataContainer.Add(MarkupData) MarkupDataContainer.Add(IEnumerable<MarkupData>) MarkupDataContainer.Insert(int, MarkupData) MarkupDataContainer.Remove(MarkupData) MarkupDataContainer.Clear() MarkupDataContainer.GetEnumerator() MarkupDataContainer.MoveToContainer(MarkupDataContainer, int, int, int) MarkupDataContainer.Equals(MarkupDataContainer) MarkupDataContainer.ToString() MarkupDataContainer.OnDeserialized() MarkupDataContainer.CloneWithoutChildren() MarkupDataContainer.Children MarkupDataContainer.AllSubItems MarkupDataContainer.Count MarkupDataContainer.this[int] MarkupData.Id MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.ParentParagraphUnit MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class FeedbackContainer : MarkupDataContainer, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData> Remarks Used by the Translation Quality Assessment process(TQA). Constructors FeedbackContainer() Initializes a new instance of the FeedbackContainer class. Declaration public FeedbackContainer() FeedbackContainer(FeedbackType) Initializes a new instance of the FeedbackContainer class. Declaration public FeedbackContainer(FeedbackType feedbackType) Parameters Type Name Description FeedbackType feedbackType Type of the feedback. Properties Author Gets or sets the author. Declaration [DataMember(Name = \"author\")] public string Author { get; set; } Property Value Type Description string The author. Category Gets or sets the custom category of this feedback. Declaration [DataMember(Name = \"category\")] public string Category { get; set; } Property Value Type Description string The category. Comment Gets or sets the comment on this review feedback. Declaration [DataMember(Name = \"comment\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public string Comment { get; set; } Property Value Type Description string The comment. CommentDefinitionId OBSOLETE Gets or sets the comment definition identifier. Declaration [Obsolete(\"SHOULD be removed in next MAJOR release\")] [DataMember(Name = \"commentDefinitionId\")] public int CommentDefinitionId { get; set; } Property Value Type Description int The comment definition identifier. DocumentCategory Gets or sets the document category. Declaration [DataMember(Name = \"documentCategory\")] public string DocumentCategory { get; set; } Property Value Type Description string The document category. FeedbackType Gets or sets the type of the feedback. Declaration [DataMember(Name = \"feedbackType\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public FeedbackType FeedbackType { get; set; } Property Value Type Description FeedbackType The type of the feedback. Origin Gets or sets the feedback origin. Example values: \"auto-filled\", \"auto-categorized\", \"interactive\" Declaration [DataMember(Name = \"origin\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public string Origin { get; set; } Property Value Type Description string ReplacementId Gets or sets the replacement identifier. Declaration [DataMember(Name = \"replacementId\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public string ReplacementId { get; set; } Property Value Type Description string The replacement identifier. Remarks Id which is used for identifying TQA replacements (replacing an existing piece of markup with new markup). Both original and new markup (adjacent FeedbackDeleted and FeedbackAdded markers) will contain an identical ReplacementId GUID in their properties indicating it is a replacement. Severity Gets or sets the custom severity. Declaration [DataMember(Name = \"severity\")] public string Severity { get; set; } Property Value Type Description string The custom severity. Timestamp Gets or sets the creation date. Declaration [DataMember(Name = \"timestamp\")] public DateTime? Timestamp { get; set; } Property Value Type Description DateTime? The creation date. Type Gets or sets the custom feedback type. Declaration [JsonProperty(\"type\")] protected override string Type { get; set; } Property Value Type Description string The feedback type. Overrides MarkupData.Type Methods AcceptVisitor(BcmVisitor) Accepts a visitor of type BcmVisitor. Declaration public override void AcceptVisitor(BcmVisitor visitor) Parameters Type Name Description BcmVisitor visitor The BcmVisitor used to visit this item. Overrides MarkupData.AcceptVisitor(BcmVisitor) Clone() Clones this instance. Declaration public FeedbackContainer Clone() Returns Type Description FeedbackContainer A deep clone of this instance. Equals(MarkupData) Performs a deep equals comparison. Declaration public override bool Equals(MarkupData other) Parameters Type Name Description MarkupData other The other MarkupData used for comparison.. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Overrides MarkupDataContainer.Equals(MarkupData) Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MarkupDataContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MarkupDataContainer.GetHashCode() UniqueClone() Clones this instance with a new unique ID. Declaration public FeedbackContainer UniqueClone() Returns Type Description FeedbackContainer A deep clone with a new unique ID. Implements IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.FeedbackType.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.FeedbackType.html",
    "title": "Enum FeedbackType",
    "summary": "Enum FeedbackType Types of feedback changes created during the translation/review process. Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [JsonConverter(typeof(EnumConverter))] public enum FeedbackType Fields Name Description Added Added content. Comment A feedback comment was added. Deleted Deleted content."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.File.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.File.html",
    "title": "Class File",
    "summary": "Class File BCM data extracted from a native file. Inheritance object ExtensionDataContainer MetadataContainer File Implements IEquatable<MetadataContainer> ICloneable<File> IEquatable<File> Inherited Members MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class File : MetadataContainer, IEquatable<MetadataContainer>, ICloneable<File>, IEquatable<File> Constructors File() Public constructor. Declaration public File() File(string) Declaration public File(string Id) Parameters Type Name Description string Id Properties CommentDefinitionIds IDs of CommentDefinition used as file-level comments. Declaration [DataMember(Name = \"commentDefinitionIds\", EmitDefaultValue = false)] public List<int> CommentDefinitionIds { get; set; } Property Value Type Description List<int> DependencyFiles Dependency files used for converting to and from native format. Declaration [DataMember(Name = \"dependencyFiles\", EmitDefaultValue = false)] public List<DependencyFile> DependencyFiles { get; set; } Property Value Type Description List<DependencyFile> FileTypeDefinitionId The ID of the filter used for converting the file from native format. Declaration [DataMember(Name = \"fileTypeDefinitionId\", EmitDefaultValue = false)] public string FileTypeDefinitionId { get; set; } Property Value Type Description string Id Gets or sets the identifier. Declaration [JsonProperty(PropertyName = \"id\", Order = -2147483648)] public string Id { get; set; } Property Value Type Description string The identifier. IdGenerator Gets or sets the IdGenerator used for generating sequential IDs./> Declaration public IdGenerator IdGenerator { get; set; } Property Value Type Description IdGenerator The identifier generator. OriginalEncoding Gets or sets the original encoding. Declaration [DataMember(Name = \"originalEncoding\", EmitDefaultValue = false)] public string OriginalEncoding { get; set; } Property Value Type Description string The original encoding. OriginalFileName The name of the native file from which this File was constructed. Declaration [DataMember(Name = \"originalFileName\", EmitDefaultValue = false)] public string OriginalFileName { get; set; } Property Value Type Description string ParagraphUnits A collection of all the ParagraphUnit elements in this File. Declaration [DataMember(Name = \"paragraphUnits\", EmitDefaultValue = false)] public ParagraphUnitCollection ParagraphUnits { get; set; } Property Value Type Description ParagraphUnitCollection Parent The parent Document of this File. Declaration public Document Parent { get; set; } Property Value Type Description Document PreferredTargetEncoding Gets or sets the preferred target encoding. Declaration [DataMember(Name = \"preferredTargetEncoding\", EmitDefaultValue = false)] public string PreferredTargetEncoding { get; set; } Property Value Type Description string The preferred target encoding. Skeleton The FileSkeleton holding all the structure element data referenced in this File. Declaration [DataMember(Name = \"skeleton\", EmitDefaultValue = false)] public FileSkeleton Skeleton { get; set; } Property Value Type Description FileSkeleton Methods Clone() Clones this instance. Declaration public File Clone() Returns Type Description File A deep clone of this instance. Equals(File) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(File other) Parameters Type Name Description File other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MetadataContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MetadataContainer.GetHashCode() ShouldSerializeCommentDefinitionIds() Used by JSON.NET serializer. Declaration public bool ShouldSerializeCommentDefinitionIds() Returns Type Description bool True if the CommentDefinitionIds property should be serialized. ShouldSerializeDependencyFiles() Used by JSON.NET serializer. Declaration public bool ShouldSerializeDependencyFiles() Returns Type Description bool True if the DependencyFiles property should be serialized. Implements IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.FileMetaDataKeys.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.FileMetaDataKeys.html",
    "title": "Class FileMetaDataKeys",
    "summary": "Class FileMetaDataKeys Constants used for File metadata. Inheritance object FileMetaDataKeys Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public static class FileMetaDataKeys Fields ContextFileLocation File level metadata containing the context file location. Declaration public const string ContextFileLocation = \"SDL:ContextFileLocation\" Field Value Type Description string"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Fragment.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Fragment.html",
    "title": "Class Fragment",
    "summary": "Class Fragment Class representing an independent fragment (slice) of a BCM Document. Inheritance object ExtensionDataContainer MetadataContainer Fragment Implements IEquatable<MetadataContainer> IEquatable<Fragment> ICloneable<Fragment> Inherited Members MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class Fragment : MetadataContainer, IEquatable<MetadataContainer>, IEquatable<Fragment>, ICloneable<Fragment> Constructors Fragment() Initializes a new instance of the Fragment class. Declaration public Fragment() Properties CommentDefinitionIds Gets or sets the list of CommentDefinition IDs associated with this fragment. Declaration [DataMember(Name = \"commentDefinitionIds\", EmitDefaultValue = false)] public List<int> CommentDefinitionIds { get; set; } Property Value Type Description List<int> The list of CommentDefinition IDs associated with this fragment. ContextList Gets or sets the list of Context IDs associated with this fragment. Declaration [DataMember(Name = \"contextList\", EmitDefaultValue = false)] public IList<int> ContextList { get; set; } Property Value Type Description IList<int> The list of Context IDs associated with this fragment.. DocumentId Gets or sets the document identifier. Declaration [DataMember(Name = \"documentId\", EmitDefaultValue = false)] public string DocumentId { get; set; } Property Value Type Description string The document identifier which uniquely identifies this BCM Fragment. Index The index in the source Document from where this fragment was extracted. Declaration [DataMember(Name = \"index\", EmitDefaultValue = false)] public int? Index { get; set; } Property Value Type Description int? The index in the source Document from where this fragment was extracted. Skeleton Gets or sets the File skeleton. Declaration [DataMember(Name = \"skeleton\", EmitDefaultValue = false)] public FileSkeleton Skeleton { get; set; } Property Value Type Description FileSkeleton The file skeleton. SourceContent Gets or sets the source content of the BCM fragment. Declaration [DataMember(Name = \"sourceContent\", EmitDefaultValue = false)] public MarkupData SourceContent { get; set; } Property Value Type Description MarkupData The source content of the Fragment. SourceLanguageCode Gets or sets the source language code. Declaration [DataMember(Name = \"sourceLanguageCode\", EmitDefaultValue = false)] public string SourceLanguageCode { get; set; } Property Value Type Description string The source language code. StructureContextId Gets or sets the structure Context associated with this fragment. Declaration [DataMember(Name = \"structureContextId\", EmitDefaultValue = false)] public int StructureContextId { get; set; } Property Value Type Description int The structure Context associated with this fragment. TargetContent Gets or sets the target content of the BCM fragment. Declaration [DataMember(Name = \"targetContent\", EmitDefaultValue = false)] public MarkupData TargetContent { get; set; } Property Value Type Description MarkupData The target content of the BCM fragment. TargetLanguageCode Gets or sets the target language code. Declaration [DataMember(Name = \"targetLanguageCode\", EmitDefaultValue = false)] public string TargetLanguageCode { get; set; } Property Value Type Description string The target language code. Methods Clone() Clones this instance. Declaration public Fragment Clone() Returns Type Description Fragment A deep clone of this instance. Equals(Fragment) Performs a deep-equals comparison. Declaration public bool Equals(Fragment other) Parameters Type Name Description Fragment other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MetadataContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MetadataContainer.GetHashCode() ShouldSerializeCommentDefinitionIds() Used by JSON.NET serialization. Declaration public bool ShouldSerializeCommentDefinitionIds() Returns Type Description bool True if the CommentDefinitionIds should be serialized; otherwise False ShouldSerializeContextList() Used by JSON.NET serialization. Declaration public bool ShouldSerializeContextList() Returns Type Description bool True if the ContextList should be serialized; otherwise False ShouldSerializeSkeleton() Used by JSON.NET serialization. Declaration public bool ShouldSerializeSkeleton() Returns Type Description bool True if the Skeleton should be serialized; otherwise False ToString() Converts to string. Declaration public override string ToString() Returns Type Description string A string that represents this instance. Overrides object.ToString() Implements IEquatable<T> IEquatable<T> ICloneable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.ISkeletonItemReference-1.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.ISkeletonItemReference-1.html",
    "title": "Interface ISkeletonItemReference<T>",
    "summary": "Interface ISkeletonItemReference<T> Marks a class as having its definition in the FileSkeleton. Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public interface ISkeletonItemReference<out T> where T : SkeletonItem Type Parameters Name Description T Type parameter. Should be an item from the FileSkeleton. Properties Definition Gets the definition of this item from the FileSkeleton. Declaration T Definition { get; } Property Value Type Description T The definition of this item from the FileSkeleton."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.LocalizableSubContent.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.LocalizableSubContent.html",
    "title": "Class LocalizableSubContent",
    "summary": "Class LocalizableSubContent Subcontent of a particular BCM content element. Inheritance object ExtensionDataContainer LocalizableSubContent Implements ICloneable<LocalizableSubContent> Inherited Members ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class LocalizableSubContent : ExtensionDataContainer, ICloneable<LocalizableSubContent> Constructors LocalizableSubContent() Declaration public LocalizableSubContent() Properties Length Gets or sets the content length. Declaration [DataMember(Name = \"length\")] public int Length { get; set; } Property Value Type Description int The content length. ParagraphUnitId Gets or sets the ParagraphUnit Id holding the content marked by this LocalizableSubContent reference. Declaration [DataMember(Name = \"paragraphUnitId\")] public string ParagraphUnitId { get; set; } Property Value Type Description string The ParagraphUnit Id holding the content marked by this LocalizableSubContent reference. SourceTagContentOffset Gets or sets the offset in the source tag from which the content was extracted. Declaration [DataMember(Name = \"sourceTagContentOffset\")] public int SourceTagContentOffset { get; set; } Property Value Type Description int The offset in the source tag from which the content was extracted. Methods Clone() Clones this instance. Declaration public LocalizableSubContent Clone() Returns Type Description LocalizableSubContent A deep clone of this instance. Equals(LocalizableSubContent) Performs a deep-equals comparison. Declaration protected bool Equals(LocalizableSubContent other) Parameters Type Name Description LocalizableSubContent other The other item used for comparison. Returns Type Description bool True if the items are deeply equal; False otherwise. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides object.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides object.GetHashCode() Implements ICloneable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.LockedContentContainer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.LockedContentContainer.html",
    "title": "Class LockedContentContainer",
    "summary": "Class LockedContentContainer Marks content that is locked for editing. Inheritance object ExtensionDataContainer MetadataContainer MarkupData MarkupDataContainer LockedContentContainer Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> Inherited Members MarkupDataContainer.AutoClonedTagPairKey MarkupDataContainer.GetAllChildren(Func<MarkupData, bool>) MarkupDataContainer.GetAllChildren<T>(Func<T, bool>) MarkupDataContainer.Add(MarkupData) MarkupDataContainer.Add(IEnumerable<MarkupData>) MarkupDataContainer.Insert(int, MarkupData) MarkupDataContainer.Remove(MarkupData) MarkupDataContainer.Clear() MarkupDataContainer.GetEnumerator() MarkupDataContainer.Equals(MarkupData) MarkupDataContainer.MoveToContainer(MarkupDataContainer, int, int, int) MarkupDataContainer.Equals(MarkupDataContainer) MarkupDataContainer.Equals(object) MarkupDataContainer.GetHashCode() MarkupDataContainer.ToString() MarkupDataContainer.OnDeserialized() MarkupDataContainer.CloneWithoutChildren() MarkupDataContainer.Children MarkupDataContainer.AllSubItems MarkupDataContainer.Count MarkupDataContainer.this[int] MarkupData.Id MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.ParentParagraphUnit MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class LockedContentContainer : MarkupDataContainer, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData> Constructors LockedContentContainer() Declaration public LockedContentContainer() Properties Type Gets the type of MarkupData. Declaration [JsonProperty(\"type\")] protected override string Type { get; set; } Property Value Type Description string The type. Overrides MarkupData.Type Methods AcceptVisitor(BcmVisitor) Accepts a visitor of type BcmVisitor. Declaration public override void AcceptVisitor(BcmVisitor visitor) Parameters Type Name Description BcmVisitor visitor The BcmVisitor used to visit this item. Overrides MarkupData.AcceptVisitor(BcmVisitor) Clone() Clones this instance. Declaration public LockedContentContainer Clone() Returns Type Description LockedContentContainer A deep clone of this instance. UniqueClone() Clones this instance, setting a new unique Id. Declaration public LockedContentContainer UniqueClone() Returns Type Description LockedContentContainer A deep clone of this instance, with a new unique Id. Implements IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.MarkupData.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.MarkupData.html",
    "title": "Class MarkupData",
    "summary": "Class MarkupData Abstract entity representing an item that can be included inside a MarkupDataContainer. Examples: TextMarkup, PlaceholderTag, TagPair. Inheritance object ExtensionDataContainer MetadataContainer MarkupData MarkupDataContainer PlaceholderTag StructureTag TextMarkup UnknownMarkupData Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> Inherited Members MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] [JsonConverter(typeof(MarkupDataCreator))] public abstract class MarkupData : MetadataContainer, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData> Remarks Inheritors of MarkupData should not implement themselves IEquatable<T>, but should override MarkupData equality. Constructors MarkupData() Initializes a new instance of the MarkupData class. Declaration protected MarkupData() MarkupData(string) Initializes a new instance of the MarkupData class. Declaration protected MarkupData(string id) Parameters Type Name Description string id The identifier. Properties Ancestors This item's MarkupDataContainer ancestors, in ascending order. Declaration public IEnumerable<MarkupDataContainer> Ancestors { get; } Property Value Type Description IEnumerable<MarkupDataContainer> Id Markup data unique id (GUID). Declaration [JsonProperty(PropertyName = \"id\", DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, Order = -2147483648)] public string Id { get; set; } Property Value Type Description string IndexInParent The index of this item in the parent MarkupDataContainer. -1 if it doesn't have a parent. Declaration public int IndexInParent { get; } Property Value Type Description int IsContainer True if this MarkupData is a container. Otherwise false. Declaration public bool IsContainer { get; } Property Value Type Description bool Parent The MarkupDataContainer parent container. Declaration public MarkupDataContainer Parent { get; set; } Property Value Type Description MarkupDataContainer ParentFragment The Fragment containing this item. Declaration public Fragment ParentFragment { get; } Property Value Type Description Fragment ParentParagraph The Paragraph containing this item. Declaration public Paragraph ParentParagraph { get; } Property Value Type Description Paragraph ParentParagraphUnit The ParagraphUnit containing this item. Declaration public virtual ParagraphUnit ParentParagraphUnit { get; set; } Property Value Type Description ParagraphUnit ParentSegment The Segment containing this item. Null if the item isn't inside of a Segment. Declaration public Segment ParentSegment { get; } Property Value Type Description Segment Type Gets or sets the type. Should be implement in derived classes to uniquely identify the type of MarkupData on deserialization. Declaration [JsonProperty(\"type\")] protected abstract string Type { get; set; } Property Value Type Description string The type. Methods AcceptVisitor(BcmVisitor) Accepts a visitor of type BcmVisitor. Declaration public abstract void AcceptVisitor(BcmVisitor visitor) Parameters Type Name Description BcmVisitor visitor The BcmVisitor used to visit this item. Clone() Clones the item to a new MarkupData. Declaration public virtual MarkupData Clone() Returns Type Description MarkupData Equals(MarkupData) Indicates whether the current object is equal to another object of the same type. Declaration public virtual bool Equals(MarkupData other) Parameters Type Name Description MarkupData other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MetadataContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MetadataContainer.GetHashCode() UniqueClone() Creates clone of the current object, with a new unique Id. Declaration public virtual MarkupData UniqueClone() Returns Type Description MarkupData A clone with a new unique Id. Implements IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.MarkupDataContainer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.MarkupDataContainer.html",
    "title": "Class MarkupDataContainer",
    "summary": "Class MarkupDataContainer A MarkupData element that can hold other MarkupData elements. Inheritance object ExtensionDataContainer MetadataContainer MarkupData MarkupDataContainer AnnotationContainer FeedbackContainer LockedContentContainer Paragraph RevisionContainer Segment TagPair Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> Inherited Members MarkupData.AcceptVisitor(BcmVisitor) MarkupData.Id MarkupData.Type MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.ParentParagraphUnit MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public abstract class MarkupDataContainer : MarkupData, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData> Constructors MarkupDataContainer() Initializes a new instance of the MarkupDataContainer class. Declaration protected MarkupDataContainer() MarkupDataContainer(string) Initializes a new instance of the MarkupDataContainer class. Declaration protected MarkupDataContainer(string id) Parameters Type Name Description string id The identifier. Fields AutoClonedTagPairKey Metadata key, marking thi instance as cloned (duplicated) during conversion from native formats. Declaration public const string AutoClonedTagPairKey = \"SDL:AutoCloned\" Field Value Type Description string Properties AllSubItems All the MarkupData items in the subtree, in depth-first order. Declaration public IEnumerable<MarkupData> AllSubItems { get; } Property Value Type Description IEnumerable<MarkupData> Children The container's direct children. Declaration [DataMember(Name = \"children\", Order = 2147483647)] public IReadOnlyCollection<MarkupData> Children { get; } Property Value Type Description IReadOnlyCollection<MarkupData> Count Gets the number of children of this container. Declaration public int Count { get; } Property Value Type Description int The number of children of this container. this[int] Gets or sets the MarkupData at the specified index. Declaration public MarkupData this[int index] { get; set; } Parameters Type Name Description int index The index. Property Value Type Description MarkupData The MarkupData. Methods Add(MarkupData) Adds a new MarkupData to the container. Declaration public MarkupDataContainer Add(MarkupData markupData) Parameters Type Name Description MarkupData markupData The item to be added. Returns Type Description MarkupDataContainer The container after the change. Add(IEnumerable<MarkupData>) Adds a new MarkupData to the container. Declaration public MarkupDataContainer Add(IEnumerable<MarkupData> range) Parameters Type Name Description IEnumerable<MarkupData> range The range of MarkupData items to be added. Returns Type Description MarkupDataContainer The container after the change. Clear() Removes all the items from this container. Sets the previous children Parent property to null. Declaration public void Clear() Clone() Clones the item to a new MarkupData. Declaration public override MarkupData Clone() Returns Type Description MarkupData A deep clone of this instance. Overrides MarkupData.Clone() CloneWithoutChildren() Creates a clone of this instance, without any children elements. Declaration public virtual MarkupDataContainer CloneWithoutChildren() Returns Type Description MarkupDataContainer A clone of this instance, without any children elements. Equals(MarkupData) Indicates whether the current object is equal to another object of the same type. Declaration public override bool Equals(MarkupData other) Parameters Type Name Description MarkupData other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Overrides MarkupData.Equals(MarkupData) Equals(MarkupDataContainer) Equalses the specified other. Declaration public virtual bool Equals(MarkupDataContainer other) Parameters Type Name Description MarkupDataContainer other The other. Returns Type Description bool Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MarkupData.Equals(object) GetAllChildren(Func<MarkupData, bool>) Finds all the MarkupData items in the subtree which satisfy a specific condition, in depth-first order. Declaration public IEnumerable<MarkupData> GetAllChildren(Func<MarkupData, bool> condition) Parameters Type Name Description Func<MarkupData, bool> condition Returns Type Description IEnumerable<MarkupData> GetAllChildren<T>(Func<T, bool>) Finds all the MarkupData items in the subtree which satisfy a specific condition, in depth-first order. Declaration public IEnumerable<T> GetAllChildren<T>(Func<T, bool> condition) where T : MarkupData Parameters Type Name Description Func<T, bool> condition Returns Type Description IEnumerable<T> Type Parameters Name Description T GetEnumerator() Gets an IEnumerator<T> for the container's children. Declaration public IEnumerator<MarkupData> GetEnumerator() Returns Type Description IEnumerator<MarkupData> An IEnumerator<T> instance enumerating the container's children. GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MarkupData.GetHashCode() Insert(int, MarkupData) Inserts a new MarkupData into the container. Declaration public MarkupDataContainer Insert(int index, MarkupData markupData) Parameters Type Name Description int index The position where the item should be inserted. MarkupData markupData The item to be inserted. Returns Type Description MarkupDataContainer The container after the change. MoveToContainer(MarkupDataContainer, int, int, int) Moves the children of this container to another MarkupDataContainer instance. Declaration public void MoveToContainer(MarkupDataContainer target, int sourceIndex, int targetIndex, int count) Parameters Type Name Description MarkupDataContainer target The target MarkupDataContainer. int sourceIndex Index in the source container, from where to start moving elements. int targetIndex Index in the target container, where the elements should be inserted. int count Number of elements to be moved. OnDeserialized() Declaration protected virtual void OnDeserialized() Remove(MarkupData) Removes a MarkupData item from the container. Declaration public MarkupDataContainer Remove(MarkupData markupData) Parameters Type Name Description MarkupData markupData The item to be removed. Returns Type Description MarkupDataContainer The container after the changes. ToString() Converts to string. Declaration public override string ToString() Returns Type Description string A string that represents this instance. Overrides object.ToString() UniqueClone() Creates clone of the current object, with a new unique Id. Declaration public override MarkupData UniqueClone() Returns Type Description MarkupData A clone with a new unique Id. Overrides MarkupData.UniqueClone() Implements IEquatable<T> ICloneable<T> IEquatable<T> See Also MarkupData"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.MetadataContainer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.MetadataContainer.html",
    "title": "Class MetadataContainer",
    "summary": "Class MetadataContainer An object that contains metadata in the form of a DictionaryEx<TKey, TValue>. Inheritance object ExtensionDataContainer MetadataContainer DependencyFile Document File Fragment MarkupData ParagraphUnit FileSkeleton SkeletonItem TranslationOrigin Implements IEquatable<MetadataContainer> Inherited Members ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public abstract class MetadataContainer : ExtensionDataContainer, IEquatable<MetadataContainer> Constructors MetadataContainer() Declaration protected MetadataContainer() Properties Metadata Gets or sets the metadata. Declaration public DictionaryEx<string, string> Metadata { get; set; } Property Value Type Description DictionaryEx<string, string> The metadata. Methods Equals(MetadataContainer) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(MetadataContainer other) Parameters Type Name Description MetadataContainer other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides object.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides object.GetHashCode() GetMetadata(string) Gets the metadata. Declaration public string GetMetadata(string key) Parameters Type Name Description string key The metadata key. Returns Type Description string The metadata value; or null if the key was not found. SetMetadata(string, string) Sets a metadata value. Declaration public void SetMetadata(string key, string value) Parameters Type Name Description string key The key. string value The value. ShouldSerialize_metadata() Needed for JSON serialization. Declaration public bool ShouldSerialize_metadata() Returns Type Description bool True if this instance should be serialized; otherwise False. Implements IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Paragraph.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Paragraph.html",
    "title": "Class Paragraph",
    "summary": "Class Paragraph A MarkupDataContainer containing the source or target content of a ParagraphUnit. Inheritance object ExtensionDataContainer MetadataContainer MarkupData MarkupDataContainer Paragraph Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> Inherited Members MarkupDataContainer.AutoClonedTagPairKey MarkupDataContainer.GetAllChildren(Func<MarkupData, bool>) MarkupDataContainer.GetAllChildren<T>(Func<T, bool>) MarkupDataContainer.Add(MarkupData) MarkupDataContainer.Add(IEnumerable<MarkupData>) MarkupDataContainer.Insert(int, MarkupData) MarkupDataContainer.Remove(MarkupData) MarkupDataContainer.Clear() MarkupDataContainer.GetEnumerator() MarkupDataContainer.Equals(MarkupData) MarkupDataContainer.MoveToContainer(MarkupDataContainer, int, int, int) MarkupDataContainer.Equals(MarkupDataContainer) MarkupDataContainer.Equals(object) MarkupDataContainer.GetHashCode() MarkupDataContainer.ToString() MarkupDataContainer.OnDeserialized() MarkupDataContainer.CloneWithoutChildren() MarkupDataContainer.Children MarkupDataContainer.AllSubItems MarkupDataContainer.Count MarkupDataContainer.this[int] MarkupData.Id MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class Paragraph : MarkupDataContainer, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData> Constructors Paragraph() Initializes a new instance of the Paragraph class. Declaration public Paragraph() Paragraph(Segment) Initializes a new instance of the Paragraph class with a particular child Segment. Declaration public Paragraph(Segment segment) Parameters Type Name Description Segment segment The Segment to be added as a child to this instance. Paragraph(string) Initializes a new instance of the Paragraph class. Declaration public Paragraph(string id) Parameters Type Name Description string id The identifier. Properties ParentParagraphUnit The ParagraphUnit containing this item. Declaration public override ParagraphUnit ParentParagraphUnit { get; set; } Property Value Type Description ParagraphUnit Overrides MarkupData.ParentParagraphUnit Type Gets the type of MarkupData. Declaration [JsonProperty(\"type\")] protected override string Type { get; set; } Property Value Type Description string The type. Overrides MarkupData.Type Methods AcceptVisitor(BcmVisitor) Accepts a visitor of type BcmVisitor. Declaration public override void AcceptVisitor(BcmVisitor visitor) Parameters Type Name Description BcmVisitor visitor The BcmVisitor used to visit this item. Overrides MarkupData.AcceptVisitor(BcmVisitor) Clone() Clones this instance. Declaration public Paragraph Clone() Returns Type Description Paragraph A deep clone of this instance. UniqueClone() Clones this instance, assigning a new unique Id. Declaration public Paragraph UniqueClone() Returns Type Description Paragraph A deep clone of this instance, with a new unique Id. Implements IEquatable<T> ICloneable<T> IEquatable<T> See Also MarkupDataContainer"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.ParagraphUnit.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.ParagraphUnit.html",
    "title": "Class ParagraphUnit",
    "summary": "Class ParagraphUnit The main element of translatable content. Contains a source and target Paragraph element. Inheritance object ExtensionDataContainer MetadataContainer ParagraphUnit Implements IEquatable<MetadataContainer> ICloneable<ParagraphUnit> IEquatable<ParagraphUnit> Inherited Members MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class ParagraphUnit : MetadataContainer, IEquatable<MetadataContainer>, ICloneable<ParagraphUnit>, IEquatable<ParagraphUnit> Constructors ParagraphUnit() Initializes a new instance of the ParagraphUnit class. Declaration public ParagraphUnit() Properties CommentDefinitionIds Gets or sets the list of CommentDefinition IDs. Declaration [DataMember(Name = \"commentDefinitionIds\", EmitDefaultValue = false)] public List<int> CommentDefinitionIds { get; set; } Property Value Type Description List<int> The list of CommentDefinition IDs. Remarks This holds any ParagraphUnit level comments. ContextList Gets or sets the list of Context IDs associated with this instance. Declaration [DataMember(Name = \"contextList\", EmitDefaultValue = false)] public IList<int> ContextList { get; set; } Property Value Type Description IList<int> The list of Context IDs associated with this instance. Id Gets or sets the identifier. Declaration [DataMember(Name = \"id\")] public string Id { get; set; } Property Value Type Description string The identifier. Index Gets or sets the index of this instance in the ParentFile. Declaration [DataMember(Name = \"index\")] [JsonConverter(typeof(FloatToIntConverter))] public int Index { get; set; } Property Value Type Description int The index of this instance in the ParentFile. IsLocked Gets or sets a value indicating whether this instance is locked. Declaration [DataMember(Name = \"isLocked\", EmitDefaultValue = false)] public bool IsLocked { get; set; } Property Value Type Description bool true if this instance is locked; otherwise, false. IsStructure Gets or sets a value indicating whether this instance is a structure ParagraphUnit. Declaration [DataMember(Name = \"isStructure\", EmitDefaultValue = false)] public bool IsStructure { get; set; } Property Value Type Description bool true if this instance is a structure ParagraphUnit; otherwise, false. Remarks A structure ParagraphUnit is not usually used as translatable content. ParentFile Gets or sets the parent File. Declaration public File ParentFile { get; set; } Property Value Type Description File The parent File. ParentFileId Gets or sets the parent File identifier. Declaration [DataMember(Name = \"parentFileId\")] public string ParentFileId { get; set; } Property Value Type Description string The parent File identifier. SegmentPairs Gets all the source and target Segment in this instance, paired as SegmentPair elements. Declaration public SegmentPairCollection SegmentPairs { get; } Property Value Type Description SegmentPairCollection The segment pairs. Source Gets or sets the source Paragraph. Declaration [DataMember(Name = \"source\")] public Paragraph Source { get; set; } Property Value Type Description Paragraph The source Paragraph. StructureContextId Gets or sets the id of the structure Context. Declaration [DataMember(Name = \"structureContextId\", EmitDefaultValue = false)] public int StructureContextId { get; set; } Property Value Type Description int The id of the structure Context. Target Gets or sets the target Paragraph. Declaration [DataMember(Name = \"target\")] public Paragraph Target { get; set; } Property Value Type Description Paragraph The target Paragraph. Methods Clone() Clones this instance. Declaration public ParagraphUnit Clone() Returns Type Description ParagraphUnit A deep clone of this instance. Equals(ParagraphUnit) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(ParagraphUnit other) Parameters Type Name Description ParagraphUnit other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MetadataContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MetadataContainer.GetHashCode() ToString() Converts to string. Declaration public override string ToString() Returns Type Description string A string that represents this instance. Overrides object.ToString() Implements IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.ParagraphUnitMetadataKeys.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.ParagraphUnitMetadataKeys.html",
    "title": "Class ParagraphUnitMetadataKeys",
    "summary": "Class ParagraphUnitMetadataKeys Constants with ParagraphUnit related metadata keys. Inheritance object ParagraphUnitMetadataKeys Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public static class ParagraphUnitMetadataKeys Fields FrameworkOriginalParagraphUnitId The original paragraph unit identifier used by the SDL Filter Framework. Declaration public const string FrameworkOriginalParagraphUnitId = \"frameworkOriginalParagraphUnitId\" Field Value Type Description string"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.AbstractPartialBcmSerializer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.AbstractPartialBcmSerializer.html",
    "title": "Class AbstractPartialBcmSerializer",
    "summary": "Class AbstractPartialBcmSerializer Common superclass for the two types of serializer Inheritance object AbstractPartialBcmSerializer InMemoryBcmSerializer TempFileBasedBcmSerializer Implements IPartialBcmSerializer IDisposable Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.PartialSerialization Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public abstract class AbstractPartialBcmSerializer : IPartialBcmSerializer, IDisposable Constructors AbstractPartialBcmSerializer() Declaration protected AbstractPartialBcmSerializer() Methods AddFile(File) Adds a file, based on the attributes and skeleton in the parameter. Array of paragraph units must be empty. Declaration public abstract void AddFile(File file) Parameters Type Name Description File file DeleteFile(int) Deletes the file from the document. Declaration public abstract void DeleteFile(int index) Parameters Type Name Description int index DeleteFile(string) Deletes the file from the document. Declaration public abstract void DeleteFile(string id) Parameters Type Name Description string id Dispose() Declaration public void Dispose() Dispose(bool) Dispose function to override in derived classes Declaration protected abstract void Dispose(bool disposing) Parameters Type Name Description bool disposing GetDocumentWithoutFiles() Gets document attributes and metadata without the files list. Updates made to the object returned will be reflected automatically in the result in case the updated bcm is requested. Declaration public abstract Document GetDocumentWithoutFiles() Returns Type Description Document GetFileCount() Number of files in this document Declaration public abstract int GetFileCount() Returns Type Description int GetFileIds() All file ids in this document Declaration public abstract IReadOnlyList<string> GetFileIds() Returns Type Description IReadOnlyList<string> GetFileSerializer(string) Gets serialization wrapper for specific file Declaration public abstract IPartialFileSerializer GetFileSerializer(string fileId) Parameters Type Name Description string fileId Returns Type Description IPartialFileSerializer InsertFile(int, File) Inserts a file to a specific position, based on the attributes and skeleton in the parameter. Array of paragraph units must be empty. Declaration public abstract void InsertFile(int index, File file) Parameters Type Name Description int index File file SaveAsJson(Stream) Saves bcm document as single json object Declaration public void SaveAsJson(Stream stream) Parameters Type Name Description Stream stream SaveAsJson(TextWriter) Saves bcm document as single json object to TextWriter Declaration public abstract void SaveAsJson(TextWriter textWriter) Parameters Type Name Description TextWriter textWriter SaveAsJson(string) Saves bcm document as single json object Declaration public void SaveAsJson(string filePath) Parameters Type Name Description string filePath Implements IPartialBcmSerializer IDisposable"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.IPartialBcmSerializer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.IPartialBcmSerializer.html",
    "title": "Interface IPartialBcmSerializer",
    "summary": "Interface IPartialBcmSerializer Bcm serialization interface that allows for not holding the whole bcm document in memory Inherited Members IDisposable.Dispose() Namespace: Sdl.Core.Bcm.BcmModel.PartialSerialization Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public interface IPartialBcmSerializer : IDisposable Methods AddFile(File) Adds a file, based on the attributes and skeleton in the parameter. Array of paragraph units must be empty. Declaration void AddFile(File file) Parameters Type Name Description File file DeleteFile(int) Deletes the file from the document. Declaration void DeleteFile(int index) Parameters Type Name Description int index DeleteFile(string) Deletes the file from the document. Declaration void DeleteFile(string id) Parameters Type Name Description string id GetDocumentWithoutFiles() Gets document attributes and metadata without the files list. Updates made to the object returned will be reflected automatically in the result in case the updated bcm is requested. Declaration Document GetDocumentWithoutFiles() Returns Type Description Document GetFileCount() Number of files in this document Declaration int GetFileCount() Returns Type Description int GetFileIds() All file ids in this document Declaration IReadOnlyList<string> GetFileIds() Returns Type Description IReadOnlyList<string> GetFileSerializer(string) Gets serialization wrapper for specific file Declaration IPartialFileSerializer GetFileSerializer(string fileId) Parameters Type Name Description string fileId Returns Type Description IPartialFileSerializer InsertFile(int, File) Inserts a file to a specific position, based on the attributes and skeleton in the parameter. Array of paragraph units must be empty. Declaration void InsertFile(int index, File file) Parameters Type Name Description int index File file SaveAsJson(Stream) Saves bcm document as single json object Declaration void SaveAsJson(Stream stream) Parameters Type Name Description Stream stream SaveAsJson(TextWriter) Saves bcm document as single json object to TextWriter Declaration void SaveAsJson(TextWriter textWriter) Parameters Type Name Description TextWriter textWriter SaveAsJson(string) Saves bcm document as single json object Declaration void SaveAsJson(string filePath) Parameters Type Name Description string filePath"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.IPartialFileSerializer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.IPartialFileSerializer.html",
    "title": "Interface IPartialFileSerializer",
    "summary": "Interface IPartialFileSerializer Bcm file serialization interface that allows for not holding the full file in memory Inherited Members IDisposable.Dispose() Namespace: Sdl.Core.Bcm.BcmModel.PartialSerialization Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public interface IPartialFileSerializer : IDisposable Methods AddParagraphUnit(ParagraphUnit) Adds a paragraph unit at the end of the paragraph units list in the file Declaration void AddParagraphUnit(ParagraphUnit paragraphUnit) Parameters Type Name Description ParagraphUnit paragraphUnit GetAllParagraphUnits() Returns a sequence of paragraph units from this file, deserialized one by one Declaration IEnumerable<ParagraphUnit> GetAllParagraphUnits() Returns Type Description IEnumerable<ParagraphUnit> GetFileWithoutParagraphUnits() Gets file attributes and skeleton without any paragraph units in it. Declaration File GetFileWithoutParagraphUnits() Returns Type Description File GetParagraphUnitCount() Returns the number of paragraph units in this file Declaration int GetParagraphUnitCount() Returns Type Description int GetParagraphUnitIds() Returns the paragraph unit ids from this file Declaration IReadOnlyList<string> GetParagraphUnitIds() Returns Type Description IReadOnlyList<string> GetSpecificParagraphUnit(int) Deserializes the paragraph unit with specific index in file Declaration ParagraphUnit GetSpecificParagraphUnit(int index) Parameters Type Name Description int index Returns Type Description ParagraphUnit GetSpecificParagraphUnit(string) Deserializes the paragraph unit with specific id in file Declaration ParagraphUnit GetSpecificParagraphUnit(string id) Parameters Type Name Description string id Returns Type Description ParagraphUnit InsertParagraphUnit(int, ParagraphUnit) Inserts paragraph unit at specific index in file Declaration void InsertParagraphUnit(int index, ParagraphUnit paragraphUnit) Parameters Type Name Description int index ParagraphUnit paragraphUnit RemoveParagraphUnit(int) Removes paragraph unit with specific index from file Declaration void RemoveParagraphUnit(int index) Parameters Type Name Description int index RemoveParagraphUnit(string) Removes paragraph unit from file Declaration void RemoveParagraphUnit(string id) Parameters Type Name Description string id RemoveParagraphUnitRange(int, int) Removes multiple paragraph units based on index Declaration void RemoveParagraphUnitRange(int startIndex, int count) Parameters Type Name Description int startIndex int count UpdateFileDataWithoutParagraphUnits(File) Updates file attributes and skeleton. Array of paragraph units must be empty. Declaration void UpdateFileDataWithoutParagraphUnits(File file) Parameters Type Name Description File file UpdateParagraphUnit(ParagraphUnit) Updates paragraph unit in file Declaration void UpdateParagraphUnit(ParagraphUnit paragraphUnit) Parameters Type Name Description ParagraphUnit paragraphUnit"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.InMemory.InMemoryBcmSerializer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.InMemory.InMemoryBcmSerializer.html",
    "title": "Class InMemoryBcmSerializer",
    "summary": "Class InMemoryBcmSerializer In-memory partial bcm serializer Inheritance object AbstractPartialBcmSerializer InMemoryBcmSerializer Implements IPartialBcmSerializer IDisposable Inherited Members AbstractPartialBcmSerializer.SaveAsJson(string) AbstractPartialBcmSerializer.SaveAsJson(Stream) AbstractPartialBcmSerializer.Dispose() object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.PartialSerialization.InMemory Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public sealed class InMemoryBcmSerializer : AbstractPartialBcmSerializer, IPartialBcmSerializer, IDisposable Constructors InMemoryBcmSerializer() New empty document Declaration public InMemoryBcmSerializer() InMemoryBcmSerializer(Document) Constructor from Document instance Declaration public InMemoryBcmSerializer(Document fullDocument) Parameters Type Name Description Document fullDocument InMemoryBcmSerializer(string, bool) Constructor from file path Declaration public InMemoryBcmSerializer(string filePath, bool deleteFile) Parameters Type Name Description string filePath bool deleteFile Methods AddFile(File) Adds a file, based on the attributes and skeleton in the parameter. Array of paragraph units must be empty. Declaration public override void AddFile(File file) Parameters Type Name Description File file Overrides AbstractPartialBcmSerializer.AddFile(File) DeleteFile(int) Deletes the file from the document. Declaration public override void DeleteFile(int index) Parameters Type Name Description int index Overrides AbstractPartialBcmSerializer.DeleteFile(int) DeleteFile(string) Deletes the file from the document. Declaration public override void DeleteFile(string id) Parameters Type Name Description string id Overrides AbstractPartialBcmSerializer.DeleteFile(string) Dispose(bool) Dispose function to override in derived classes Declaration protected override void Dispose(bool disposing) Parameters Type Name Description bool disposing Overrides AbstractPartialBcmSerializer.Dispose(bool) ExtractDocument() Returns the document packed into a single Document instance Declaration public Document ExtractDocument() Returns Type Description Document GetDocumentWithoutFiles() Gets document attributes and metadata without the files list. Updates made to the object returned will be reflected automatically in the result in case the updated bcm is requested. Declaration public override Document GetDocumentWithoutFiles() Returns Type Description Document Overrides AbstractPartialBcmSerializer.GetDocumentWithoutFiles() GetFileCount() Number of files in this document Declaration public override int GetFileCount() Returns Type Description int Overrides AbstractPartialBcmSerializer.GetFileCount() GetFileIds() All file ids in this document Declaration public override IReadOnlyList<string> GetFileIds() Returns Type Description IReadOnlyList<string> Overrides AbstractPartialBcmSerializer.GetFileIds() GetFileSerializer(string) Gets serialization wrapper for specific file Declaration public override IPartialFileSerializer GetFileSerializer(string fileId) Parameters Type Name Description string fileId Returns Type Description IPartialFileSerializer Overrides AbstractPartialBcmSerializer.GetFileSerializer(string) InsertFile(int, File) Inserts a file to a specific position, based on the attributes and skeleton in the parameter. Array of paragraph units must be empty. Declaration public override void InsertFile(int index, File file) Parameters Type Name Description int index File file Overrides AbstractPartialBcmSerializer.InsertFile(int, File) SaveAsJson(TextWriter) Saves bcm document as single json object to TextWriter Declaration public override void SaveAsJson(TextWriter textWriter) Parameters Type Name Description TextWriter textWriter Overrides AbstractPartialBcmSerializer.SaveAsJson(TextWriter) Implements IPartialBcmSerializer IDisposable"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.InMemory.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.InMemory.html",
    "title": "Namespace Sdl.Core.Bcm.BcmModel.PartialSerialization.InMemory",
    "summary": "Namespace Sdl.Core.Bcm.BcmModel.PartialSerialization.InMemory Classes InMemoryBcmSerializer In-memory partial bcm serializer"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.PartialBcmSerializerFactory.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.PartialBcmSerializerFactory.html",
    "title": "Class PartialBcmSerializerFactory",
    "summary": "Class PartialBcmSerializerFactory Creates IPartialBcmSerializer instances (either in-memory or temp file based) Inheritance object PartialBcmSerializerFactory Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.PartialSerialization Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class PartialBcmSerializerFactory Constructors PartialBcmSerializerFactory() Declaration public PartialBcmSerializerFactory() Properties FileSizeLimitInMBForInMemory Limit above which we will use a temp file based serializer instead of and in-memory one Declaration public int FileSizeLimitInMBForInMemory { get; set; } Property Value Type Description int Methods CreateSerializer(Document) Creates serializer from a Document instance Declaration public IPartialBcmSerializer CreateSerializer(Document existingDocument) Parameters Type Name Description Document existingDocument Returns Type Description IPartialBcmSerializer CreateSerializer(Stream) Creates serializer from a stream containing bcm json content Declaration public IPartialBcmSerializer CreateSerializer(Stream stream) Parameters Type Name Description Stream stream Returns Type Description IPartialBcmSerializer CreateSerializer(string) Creates serializer based on a temp file with the bcm json content. Does not delete the file. Declaration public IPartialBcmSerializer CreateSerializer(string filePath) Parameters Type Name Description string filePath Returns Type Description IPartialBcmSerializer"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.TempFileBased.TempFileBasedBcmSerializer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.TempFileBased.TempFileBasedBcmSerializer.html",
    "title": "Class TempFileBasedBcmSerializer",
    "summary": "Class TempFileBasedBcmSerializer Temp file based bcm serializer variant Inheritance object AbstractPartialBcmSerializer TempFileBasedBcmSerializer Implements IPartialBcmSerializer IDisposable Inherited Members AbstractPartialBcmSerializer.SaveAsJson(string) AbstractPartialBcmSerializer.SaveAsJson(Stream) AbstractPartialBcmSerializer.Dispose() object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.PartialSerialization.TempFileBased Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public sealed class TempFileBasedBcmSerializer : AbstractPartialBcmSerializer, IPartialBcmSerializer, IDisposable Constructors TempFileBasedBcmSerializer() Creates new empty document. Declaration public TempFileBasedBcmSerializer() TempFileBasedBcmSerializer(string, bool) Constructor based on file path Declaration public TempFileBasedBcmSerializer(string filePath, bool deleteFileOnDispose) Parameters Type Name Description string filePath bool deleteFileOnDispose Methods AddFile(File) Adds a file, based on the attributes and skeleton in the parameter. Array of paragraph units must be empty. Declaration public override void AddFile(File file) Parameters Type Name Description File file Overrides AbstractPartialBcmSerializer.AddFile(File) DeleteFile(int) Deletes the file from the document. Declaration public override void DeleteFile(int index) Parameters Type Name Description int index Overrides AbstractPartialBcmSerializer.DeleteFile(int) DeleteFile(string) Deletes the file from the document. Declaration public override void DeleteFile(string id) Parameters Type Name Description string id Overrides AbstractPartialBcmSerializer.DeleteFile(string) Dispose(bool) Dispose function to override in derived classes Declaration protected override void Dispose(bool disposing) Parameters Type Name Description bool disposing Overrides AbstractPartialBcmSerializer.Dispose(bool) GetDocumentWithoutFiles() Gets document attributes and metadata without the files list. Updates made to the object returned will be reflected automatically in the result in case the updated bcm is requested. Declaration public override Document GetDocumentWithoutFiles() Returns Type Description Document Overrides AbstractPartialBcmSerializer.GetDocumentWithoutFiles() GetFileCount() Number of files in this document Declaration public override int GetFileCount() Returns Type Description int Overrides AbstractPartialBcmSerializer.GetFileCount() GetFileIds() All file ids in this document Declaration public override IReadOnlyList<string> GetFileIds() Returns Type Description IReadOnlyList<string> Overrides AbstractPartialBcmSerializer.GetFileIds() GetFileSerializer(string) Gets serialization wrapper for specific file Declaration public override IPartialFileSerializer GetFileSerializer(string fileId) Parameters Type Name Description string fileId Returns Type Description IPartialFileSerializer Overrides AbstractPartialBcmSerializer.GetFileSerializer(string) InsertFile(int, File) Inserts a file to a specific position, based on the attributes and skeleton in the parameter. Array of paragraph units must be empty. Declaration public override void InsertFile(int index, File file) Parameters Type Name Description int index File file Overrides AbstractPartialBcmSerializer.InsertFile(int, File) SaveAsJson(TextWriter) Saves bcm document as single json object to TextWriter Declaration public override void SaveAsJson(TextWriter textWriter) Parameters Type Name Description TextWriter textWriter Overrides AbstractPartialBcmSerializer.SaveAsJson(TextWriter) Implements IPartialBcmSerializer IDisposable"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.TempFileBased.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.TempFileBased.html",
    "title": "Namespace Sdl.Core.Bcm.BcmModel.PartialSerialization.TempFileBased",
    "summary": "Namespace Sdl.Core.Bcm.BcmModel.PartialSerialization.TempFileBased Classes TempFileBasedBcmSerializer Temp file based bcm serializer variant"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.PartialSerialization.html",
    "title": "Namespace Sdl.Core.Bcm.BcmModel.PartialSerialization",
    "summary": "Namespace Sdl.Core.Bcm.BcmModel.PartialSerialization Classes AbstractPartialBcmSerializer Common superclass for the two types of serializer PartialBcmSerializerFactory Creates IPartialBcmSerializer instances (either in-memory or temp file based) Interfaces IPartialBcmSerializer Bcm serialization interface that allows for not holding the whole bcm document in memory IPartialFileSerializer Bcm file serialization interface that allows for not holding the full file in memory"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.PlaceholderTag.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.PlaceholderTag.html",
    "title": "Class PlaceholderTag",
    "summary": "Class PlaceholderTag A tag with no translatable content. Inheritance object ExtensionDataContainer MetadataContainer MarkupData PlaceholderTag Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> ISkeletonItemReference<PlaceholderTagDefinition> Inherited Members MarkupData.UniqueClone() MarkupData.Id MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.ParentParagraphUnit MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class PlaceholderTag : MarkupData, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData>, ISkeletonItemReference<PlaceholderTagDefinition> Constructors PlaceholderTag() Declaration public PlaceholderTag() Properties Definition Gets the definition of this item from the FileSkeleton. Declaration public PlaceholderTagDefinition Definition { get; } Property Value Type Description PlaceholderTagDefinition The definition of this item from the FileSkeleton. PlaceholderTagDefinitionId Gets or sets the PlaceholderTagDefinition id. Declaration [DataMember(Name = \"placeholderTagDefinitionId\")] public int PlaceholderTagDefinitionId { get; set; } Property Value Type Description int The PlaceholderTagDefinition id. TagNumber Gets or sets the TagNumber for this instance. This is the same as the \"frameworkOriginalTagId\" metadata but now exposed on the tag as well (the metadata will become deprecated). If needed, it will be populated on deserialization from the metadata, the value remains null iff not present (which should not be the case). Declaration [DataMember(Name = \"tagNumber\")] public string TagNumber { get; set; } Property Value Type Description string Type Gets the type of MarkupData. Declaration [JsonProperty(\"type\")] protected override string Type { get; set; } Property Value Type Description string The type. Overrides MarkupData.Type Methods AcceptVisitor(BcmVisitor) Accepts a visitor of type BcmVisitor. Declaration public override void AcceptVisitor(BcmVisitor visitor) Parameters Type Name Description BcmVisitor visitor The BcmVisitor used to visit this item. Overrides MarkupData.AcceptVisitor(BcmVisitor) Clone() Clones this instance, setting a new id. Declaration public PlaceholderTag Clone() Returns Type Description PlaceholderTag A deep clone of this instance, with a new unique id. Equals(MarkupData) Indicates whether the current object is equal to another object of the same type. Declaration public override bool Equals(MarkupData other) Parameters Type Name Description MarkupData other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Overrides MarkupData.Equals(MarkupData) Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MarkupData.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MarkupData.GetHashCode() Implements IEquatable<T> ICloneable<T> IEquatable<T> ISkeletonItemReference<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.RevisionContainer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.RevisionContainer.html",
    "title": "Class RevisionContainer",
    "summary": "Class RevisionContainer Marks revisions to the translated content. Inheritance object ExtensionDataContainer MetadataContainer MarkupData MarkupDataContainer RevisionContainer Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> Inherited Members MarkupDataContainer.AutoClonedTagPairKey MarkupDataContainer.GetAllChildren(Func<MarkupData, bool>) MarkupDataContainer.GetAllChildren<T>(Func<T, bool>) MarkupDataContainer.Add(MarkupData) MarkupDataContainer.Add(IEnumerable<MarkupData>) MarkupDataContainer.Insert(int, MarkupData) MarkupDataContainer.Remove(MarkupData) MarkupDataContainer.Clear() MarkupDataContainer.GetEnumerator() MarkupDataContainer.MoveToContainer(MarkupDataContainer, int, int, int) MarkupDataContainer.Equals(MarkupDataContainer) MarkupDataContainer.ToString() MarkupDataContainer.OnDeserialized() MarkupDataContainer.CloneWithoutChildren() MarkupDataContainer.Children MarkupDataContainer.AllSubItems MarkupDataContainer.Count MarkupDataContainer.this[int] MarkupData.Id MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.ParentParagraphUnit MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class RevisionContainer : MarkupDataContainer, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData> Constructors RevisionContainer() Initializes a new instance of the RevisionContainer class. Declaration public RevisionContainer() RevisionContainer(RevisionType) Initializes a new instance of the RevisionContainer class. Declaration public RevisionContainer(RevisionType revisionType) Parameters Type Name Description RevisionType revisionType Type of the revision. Properties Author Gets or sets the revision author. Declaration [DataMember(Name = \"author\")] public string Author { get; set; } Property Value Type Description string The revision author. RevisionType Gets or sets the type of the revision. Declaration [DataMember(Name = \"revisionType\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public RevisionType RevisionType { get; set; } Property Value Type Description RevisionType The type of the revision. Timestamp Gets or sets the date when the revision was added. Declaration [DataMember(Name = \"timestamp\")] public DateTime? Timestamp { get; set; } Property Value Type Description DateTime? The date when the revision was added. Type Gets the type of MarkupData. Declaration [JsonProperty(\"type\")] protected override string Type { get; set; } Property Value Type Description string The type. Overrides MarkupData.Type Methods AcceptVisitor(BcmVisitor) Accepts a visitor of type BcmVisitor. Declaration public override void AcceptVisitor(BcmVisitor visitor) Parameters Type Name Description BcmVisitor visitor The BcmVisitor used to visit this item. Overrides MarkupData.AcceptVisitor(BcmVisitor) Clone() Clones this instance. Declaration public RevisionContainer Clone() Returns Type Description RevisionContainer A deep clone of this instance. Equals(MarkupData) Indicates whether the current object is equal to another object of the same type. Declaration public override bool Equals(MarkupData other) Parameters Type Name Description MarkupData other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Overrides MarkupDataContainer.Equals(MarkupData) Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MarkupDataContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MarkupDataContainer.GetHashCode() UniqueClone() Clones this instance, setting a new unique id. Declaration public RevisionContainer UniqueClone() Returns Type Description RevisionContainer A deep clone of this instance, with a new unique id. Implements IEquatable<T> ICloneable<T> IEquatable<T> See Also MarkupDataContainer"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.RevisionType.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.RevisionType.html",
    "title": "Enum RevisionType",
    "summary": "Enum RevisionType Types of RevisionContainer. Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] [JsonConverter(typeof(EnumConverter))] public enum RevisionType Fields Name Description Deleted Content was deleted. Inserted Content was inserted. Unchanged The content was not changed."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Segment.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Segment.html",
    "title": "Class Segment",
    "summary": "Class Segment Basic unit of translatable content. Inheritance object ExtensionDataContainer MetadataContainer MarkupData MarkupDataContainer Segment Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> Inherited Members MarkupDataContainer.AutoClonedTagPairKey MarkupDataContainer.GetAllChildren(Func<MarkupData, bool>) MarkupDataContainer.GetAllChildren<T>(Func<T, bool>) MarkupDataContainer.Add(MarkupData) MarkupDataContainer.Add(IEnumerable<MarkupData>) MarkupDataContainer.Insert(int, MarkupData) MarkupDataContainer.Remove(MarkupData) MarkupDataContainer.Clear() MarkupDataContainer.GetEnumerator() MarkupDataContainer.MoveToContainer(MarkupDataContainer, int, int, int) MarkupDataContainer.Equals(MarkupDataContainer) MarkupDataContainer.OnDeserialized() MarkupDataContainer.Children MarkupDataContainer.AllSubItems MarkupDataContainer.Count MarkupDataContainer.this[int] MarkupData.Id MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.ParentParagraphUnit MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class Segment : MarkupDataContainer, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData> Constructors Segment() Initializes a new instance of the Segment class. Declaration public Segment() Segment(string) Initializes a new instance of the Segment class. Declaration public Segment(string segmentNumber) Parameters Type Name Description string segmentNumber The segment number. Segment(string, ConfirmationLevel) Initializes a new instance of the Segment class. Declaration public Segment(string segmentNumber, ConfirmationLevel confirmationLevel) Parameters Type Name Description string segmentNumber The segment number. ConfirmationLevel confirmationLevel The confirmation level. Properties AlignmentData Gets or sets the alignment data. Declaration [DataMember(Name = \"alignmentData\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public AlignmentData AlignmentData { get; set; } Property Value Type Description AlignmentData The alignment data. Remarks Used by the alignment processing. CharacterCount Gets or sets the character count. Declaration [DataMember(Name = \"characterCount\", EmitDefaultValue = false)] public int CharacterCount { get; set; } Property Value Type Description int The character count. ConfirmationLevel Gets or sets the confirmation level (translation status). Declaration [DataMember(Name = \"confirmationLevel\", EmitDefaultValue = false)] [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, NullValueHandling = NullValueHandling.Ignore)] public ConfirmationLevel ConfirmationLevel { get; set; } Property Value Type Description ConfirmationLevel The confirmation level (translation status). IsLocked Gets or sets a value indicating whether this instance is locked for editing. Declaration [DataMember(Name = \"isLocked\", EmitDefaultValue = false)] public bool IsLocked { get; set; } Property Value Type Description bool true if this instance is locked for editing; otherwise, false. SegmentNumber Gets or sets the segment number. Declaration [DataMember(Name = \"segmentNumber\")] public string SegmentNumber { get; set; } Property Value Type Description string The segment number. SiblingSegment Gets the sibling segment. Declaration public Segment SiblingSegment { get; } Property Value Type Description Segment The sibling segment. Remarks If this is the source segment, it retrieves the target (and the other way around) Tokens Gets or sets the tokens. Declaration [DataMember(Name = \"tokens\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public List<Token> Tokens { get; set; } Property Value Type Description List<Token> The tokens. Remarks Used by the tokenization process. TranslationOrigin Gets or sets the translation origin (translation source information). Declaration [DataMember(Name = \"translationOrigin\", EmitDefaultValue = false)] public TranslationOrigin TranslationOrigin { get; set; } Property Value Type Description TranslationOrigin The translation origin. Type Gets the type of MarkupData. Declaration [JsonProperty(\"type\")] protected override string Type { get; set; } Property Value Type Description string The type. Overrides MarkupData.Type WordCount Gets or sets the word count. Declaration [DataMember(Name = \"wordCount\", EmitDefaultValue = false)] public int WordCount { get; set; } Property Value Type Description int The word count. Methods AcceptVisitor(BcmVisitor) Accepts a visitor of type BcmVisitor. Declaration public override void AcceptVisitor(BcmVisitor visitor) Parameters Type Name Description BcmVisitor visitor The BcmVisitor used to visit this item. Overrides MarkupData.AcceptVisitor(BcmVisitor) Clone() Clones this instance. Declaration public Segment Clone() Returns Type Description Segment A deep clone of this instance. CloneWithoutChildren() Creates a clone of this instance, without any children elements. Declaration public override MarkupDataContainer CloneWithoutChildren() Returns Type Description MarkupDataContainer A clone of this instance, without any children elements. Overrides MarkupDataContainer.CloneWithoutChildren() Equals(MarkupData) Indicates whether the current object is equal to another object of the same type. Declaration public override bool Equals(MarkupData other) Parameters Type Name Description MarkupData other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Overrides MarkupDataContainer.Equals(MarkupData) Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MarkupDataContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MarkupDataContainer.GetHashCode() ToString() Converts to string. Declaration public override string ToString() Returns Type Description string A string that represents this instance. Overrides MarkupDataContainer.ToString() UniqueClone() Clones this instance, setting a new unique id. Declaration public Segment UniqueClone() Returns Type Description Segment A deep clone of this instance, with a new unique id. Implements IEquatable<T> ICloneable<T> IEquatable<T> See Also MarkupDataContainer"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.SegmentMetaDataKeys.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.SegmentMetaDataKeys.html",
    "title": "Class SegmentMetaDataKeys",
    "summary": "Class SegmentMetaDataKeys Constants for Segment metadata. Inheritance object SegmentMetaDataKeys Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public static class SegmentMetaDataKeys Fields AlignmentTimestamp Segment metadata key for accesing alignment date. Declaration public const string AlignmentTimestamp = \"tuInsertDate\" Field Value Type Description string Contexts Segment metadata key for accesing the associated contexts. Declaration public const string Contexts = \"Contexts\" Field Value Type Description string CustomFields Segment metadata key for accesing custom fields. Declaration public const string CustomFields = \"CustomFields\" Field Value Type Description string SystemFields Segment metadata key for accesing system fields. Declaration public const string SystemFields = \"SystemFields\" Field Value Type Description string TuGuId Segment metadata key for accesing the Translation Unit GUID id. Declaration public const string TuGuId = \"tuguid\" Field Value Type Description string TuId Segment metadata key for accesing the Translation Unit numerical id. Declaration public const string TuId = \"tuid\" Field Value Type Description string"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.SegmentPair.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.SegmentPair.html",
    "title": "Class SegmentPair",
    "summary": "Class SegmentPair Class grouping together the source and equivalent target Segment. Inheritance object ExtensionDataContainer SegmentPair Implements ICloneable<SegmentPair> Inherited Members ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class SegmentPair : ExtensionDataContainer, ICloneable<SegmentPair> Constructors SegmentPair(Segment, Segment) Initializes a new instance of the SegmentPair class. Declaration public SegmentPair(Segment source, Segment target) Parameters Type Name Description Segment source The source. Segment target The target. Properties Source Gets or sets the source. Declaration public Segment Source { get; set; } Property Value Type Description Segment The source. Target Gets or sets the target. Declaration public Segment Target { get; set; } Property Value Type Description Segment The target. Methods Clone() Clones this instance. Declaration public SegmentPair Clone() Returns Type Description SegmentPair A deep clone of this instance. Implements ICloneable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.SegmentationHint.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.SegmentationHint.html",
    "title": "Enum SegmentationHint",
    "summary": "Enum SegmentationHint Information on how specific tags should be segmented. Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [JsonConverter(typeof(EnumConverter), new object[] { SegmentationHint.MayExclude })] public enum SegmentationHint Fields Name Description Exclude The tag will be excluded from a segment, even if this means changing the segmentation. This is used for sub-content processing. Include If possible, the segmentation engine should always include this tag inside a segment. IncludeWithText The tag will be included in a segment if the segment also contains text content, otherwise it will not be included in a segment (in order to prevent segment-only tags). MayExclude The tag may be left outside of the segment, e.g. if it appears at a segment boundary."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Serialization.MarkupDataMapping.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Serialization.MarkupDataMapping.html",
    "title": "Class MarkupDataMapping",
    "summary": "Class MarkupDataMapping Factory providing mapping between MarkupData.Type string values and concrete implementations of MarkupData. Inheritance object MarkupDataMapping Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Serialization Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public static class MarkupDataMapping Methods GetType(string) Gets the concrete implementation of MarkupData. Declaration public static MarkupData GetType(string type) Parameters Type Name Description string type The MarkupData.Type string. Returns Type Description MarkupData"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Serialization.TokenMapping.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Serialization.TokenMapping.html",
    "title": "Class TokenMapping",
    "summary": "Class TokenMapping Class for mapping to different types of Token. Inheritance object TokenMapping Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Serialization Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public static class TokenMapping Methods GetType(string) Gets the type of Token based on the string type. Declaration public static Token GetType(string type) Parameters Type Name Description string type The type. Returns Type Description Token"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Serialization.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Serialization.html",
    "title": "Namespace Sdl.Core.Bcm.BcmModel.Serialization",
    "summary": "Namespace Sdl.Core.Bcm.BcmModel.Serialization Classes MarkupDataMapping Factory providing mapping between MarkupData.Type string values and concrete implementations of MarkupData. TokenMapping Class for mapping to different types of Token."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.CommentDefinition.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.CommentDefinition.html",
    "title": "Class CommentDefinition",
    "summary": "Class CommentDefinition Contains comment data. Can be referenced by multiple CommentContainer instances. Inheritance object ExtensionDataContainer MetadataContainer SkeletonItem CommentDefinition Implements IEquatable<MetadataContainer> IEquatable<SkeletonItem> ICloneable<CommentDefinition> IEquatable<CommentDefinition> Inherited Members SkeletonItem.Equals(SkeletonItem) SkeletonItem.Id MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class CommentDefinition : SkeletonItem, IEquatable<MetadataContainer>, IEquatable<SkeletonItem>, ICloneable<CommentDefinition>, IEquatable<CommentDefinition> Constructors CommentDefinition() Initializes a new instance of the CommentDefinition class. Declaration public CommentDefinition() Properties Author Gets or sets the author. Declaration [DataMember(Name = \"author\")] public string Author { get; set; } Property Value Type Description string The author. CommentSeverity Gets or sets the comment severity. Declaration [DataMember(Name = \"commentSeverity\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public CommentSeverity CommentSeverity { get; set; } Property Value Type Description CommentSeverity The comment severity. Date Gets or sets the comment creation date. Declaration [DataMember(Name = \"date\", EmitDefaultValue = false)] public DateTime Date { get; set; } Property Value Type Description DateTime The comment creation date. Text Gets or sets the text. Declaration [DataMember(Name = \"text\")] public string Text { get; set; } Property Value Type Description string The text. Methods Clone() Clones this instance. Declaration public CommentDefinition Clone() Returns Type Description CommentDefinition A dee Equals(CommentDefinition) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public bool Equals(CommentDefinition other) Parameters Type Name Description CommentDefinition other Returns Type Description bool Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides SkeletonItem.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides SkeletonItem.GetHashCode() Implements IEquatable<T> IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.CommentSeverity.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.CommentSeverity.html",
    "title": "Enum CommentSeverity",
    "summary": "Enum CommentSeverity Supported values of comment severity. Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] [JsonConverter(typeof(EnumConverter), new object[] { CommentSeverity.Medium })] public enum CommentSeverity Fields Name Description High High comment severity. Low Low comment severity. Medium Medium comment severity (default)."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.Context.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.Context.html",
    "title": "Class Context",
    "summary": "Class Context Context information, organized as a tree structure. Inheritance object ExtensionDataContainer MetadataContainer SkeletonItem Context Implements IEquatable<MetadataContainer> IEquatable<SkeletonItem> ICloneable<Context> IEquatable<Context> Inherited Members SkeletonItem.Equals(SkeletonItem) SkeletonItem.Id MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class Context : SkeletonItem, IEquatable<MetadataContainer>, IEquatable<SkeletonItem>, ICloneable<Context>, IEquatable<Context> Constructors Context() Declaration public Context() Properties ContextDefinitionId Id of the ContextDefinition object holding the data for this specific Context element. Declaration [DataMember(Name = \"contextDefinitionId\")] public int ContextDefinitionId { get; set; } Property Value Type Description int ParentContextId The id of the parent Context element. Declaration [DataMember(Name = \"parentContextId\", EmitDefaultValue = false)] public int ParentContextId { get; set; } Property Value Type Description int Methods Clone() Clones this instance. Declaration public Context Clone() Returns Type Description Context A clone of this instance. Equals(Context) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(Context other) Parameters Type Name Description Context other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides SkeletonItem.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides SkeletonItem.GetHashCode() ToString() Converts to string. Declaration public override string ToString() Returns Type Description string A string that represents this instance. Overrides object.ToString() Implements IEquatable<T> IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.ContextDefinition.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.ContextDefinition.html",
    "title": "Class ContextDefinition",
    "summary": "Class ContextDefinition Holds context data. Can be referenced by multiple Context elements. Inheritance object ExtensionDataContainer MetadataContainer SkeletonItem ContextDefinition Implements IEquatable<MetadataContainer> IEquatable<SkeletonItem> ICloneable<ContextDefinition> IEquatable<ContextDefinition> Inherited Members SkeletonItem.Equals(SkeletonItem) SkeletonItem.Id MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class ContextDefinition : SkeletonItem, IEquatable<MetadataContainer>, IEquatable<SkeletonItem>, ICloneable<ContextDefinition>, IEquatable<ContextDefinition> Constructors ContextDefinition() Declaration public ContextDefinition() Properties Description Gets or sets the description. Declaration [DataMember(Name = \"description\", EmitDefaultValue = false)] public string Description { get; set; } Property Value Type Description string The description. DisplayCode Gets or sets the context display code. Declaration [DataMember(Name = \"displayCode\", EmitDefaultValue = false)] public string DisplayCode { get; set; } Property Value Type Description string The context display code. DisplayColor Gets or sets the context display color. Declaration [DataMember(Name = \"displayColor\", EmitDefaultValue = false)] public string DisplayColor { get; set; } Property Value Type Description string The context display color. DisplayName Gets or sets the context display name. Declaration [DataMember(Name = \"displayName\", EmitDefaultValue = false)] public string DisplayName { get; set; } Property Value Type Description string The context display name. FormattingGroupId Gets or sets the formatting group identifier. Declaration [DataMember(Name = \"formattingGroupId\", EmitDefaultValue = false)] public int FormattingGroupId { get; set; } Property Value Type Description int The formatting group identifier. IsSidContext Gets a value indicating whether this instance is sID context. Declaration public bool IsSidContext { get; } Property Value Type Description bool true if this instance is sID context; otherwise, false. IsStructureContext Gets or sets a value indicating whether this instance is a structure context. Declaration [DataMember(Name = \"isStructureContext\", EmitDefaultValue = false)] public bool IsStructureContext { get; set; } Property Value Type Description bool true if this instance is a structure context; otherwise, false. IsTmContext Gets or sets a value indicating whether this instance is a TM context. Declaration [DataMember(Name = \"isTmContext\", EmitDefaultValue = false)] public bool IsTmContext { get; set; } Property Value Type Description bool true if this instance is TM context; otherwise, false. IsTmStructureContext Gets a value indicating whether this instance is a TM structure context. Declaration public bool IsTmStructureContext { get; } Property Value Type Description bool true if this instance is a TM structure context; otherwise, false. TypeId Gets or sets the context type identifier. Declaration [DataMember(Name = \"typeId\", EmitDefaultValue = false)] public string TypeId { get; set; } Property Value Type Description string The context type identifier. Methods Clone() Clones this instance. Declaration public ContextDefinition Clone() Returns Type Description ContextDefinition Equals(ContextDefinition) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public bool Equals(ContextDefinition other) Parameters Type Name Description ContextDefinition other Returns Type Description bool Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides SkeletonItem.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides SkeletonItem.GetHashCode() ToString() Converts to string. Declaration public override string ToString() Returns Type Description string A string that represents this instance. Overrides object.ToString() Implements IEquatable<T> IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.FileSkeleton.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.FileSkeleton.html",
    "title": "Class FileSkeleton",
    "summary": "Class FileSkeleton Holds data for a File that is referenced by different MarkupData elements. Inheritance object ExtensionDataContainer MetadataContainer FileSkeleton Implements IEquatable<MetadataContainer> ICloneable<FileSkeleton> IEquatable<FileSkeleton> Inherited Members MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class FileSkeleton : MetadataContainer, IEquatable<MetadataContainer>, ICloneable<FileSkeleton>, IEquatable<FileSkeleton> Examples A PlaceholderTag element has a DefinitionId that points to an element in the PlaceholderTagDefinitions collection. Constructors FileSkeleton() Public constructor. Declaration public FileSkeleton() Properties CommentDefinitions Collection of all the CommentDefinition elements referenced in a File. Declaration [DataMember(Name = \"commentDefinitions\")] public SkeletonCollection<CommentDefinition> CommentDefinitions { get; set; } Property Value Type Description SkeletonCollection<CommentDefinition> ContextDefinitions Collection of all the ContextDefinitionelements referenced in a File. Declaration [DataMember(Name = \"contextDefinitions\")] public SkeletonCollection<ContextDefinition> ContextDefinitions { get; set; } Property Value Type Description SkeletonCollection<ContextDefinition> Contexts Collection of all the Contextelements referenced in a File. Declaration [DataMember(Name = \"contexts\")] public SkeletonCollection<Context> Contexts { get; set; } Property Value Type Description SkeletonCollection<Context> FileId The File id. Declaration [DataMember(Name = \"fileId\", EmitDefaultValue = false)] public string FileId { get; set; } Property Value Type Description string FormattingGroups Collection of all the FormattingGroup elements referenced in a File. Declaration [DataMember(Name = \"formattingGroups\")] public SkeletonCollection<FormattingGroup> FormattingGroups { get; set; } Property Value Type Description SkeletonCollection<FormattingGroup> IdGenerator An IdGenerator instance that creates unique numeric IDs for all the elements in different FileSkeleton collection. Declaration public IdGenerator IdGenerator { get; } Property Value Type Description IdGenerator ParentFile The File for which this FileSkeleton is defined. Declaration public File ParentFile { get; set; } Property Value Type Description File PlaceholderTagDefinitions Collection of all the PlaceholderTagDefinition elements referenced in a File. Declaration [DataMember(Name = \"placeholderTagDefinitions\")] public SkeletonCollection<PlaceholderTagDefinition> PlaceholderTagDefinitions { get; set; } Property Value Type Description SkeletonCollection<PlaceholderTagDefinition> QuickInsertIds Collection of all the QuickInsert IDs referenced in a File. Declaration [DataMember(Name = \"quickInsertIds\", EmitDefaultValue = false)] public List<string> QuickInsertIds { get; set; } Property Value Type Description List<string> StructureTagDefinitions Collection of all the StructureTagDefinition elements referenced in a File. Declaration [DataMember(Name = \"structureTagDefinitions\")] public SkeletonCollection<StructureTagDefinition> StructureTagDefinitions { get; set; } Property Value Type Description SkeletonCollection<StructureTagDefinition> SubContentPUs List of all the IDs of ParagraphUnits that are sub-content elements. Declaration public List<string> SubContentPUs { get; set; } Property Value Type Description List<string> TagPairDefinitions Collection of all the TagPairDefinition elements referenced in a File. Declaration [DataMember(Name = \"tagPairDefinitions\")] public SkeletonCollection<TagPairDefinition> TagPairDefinitions { get; set; } Property Value Type Description SkeletonCollection<TagPairDefinition> TerminologyData Collection of all the TerminologyData elements referenced in a File. Declaration [DataMember(Name = \"terminologyData\")] public SkeletonCollection<TerminologyData> TerminologyData { get; set; } Property Value Type Description SkeletonCollection<TerminologyData> Methods Clone() Clones this instance. Declaration public FileSkeleton Clone() Returns Type Description FileSkeleton Equals(FileSkeleton) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public bool Equals(FileSkeleton other) Parameters Type Name Description FileSkeleton other Returns Type Description bool Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MetadataContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MetadataContainer.GetHashCode() ShouldSerializeCommentDefinitions() Used by JSON serialization. Declaration public bool ShouldSerializeCommentDefinitions() Returns Type Description bool True if CommentDefinitions should be serialized. ShouldSerializeContextDefinitions() Used by JSON serialization. Declaration public bool ShouldSerializeContextDefinitions() Returns Type Description bool True if ContextDefinitions should be serialized. ShouldSerializeContexts() Used by JSON serialization. Declaration public bool ShouldSerializeContexts() Returns Type Description bool True if Contexts should be serialized. ShouldSerializeFormattingGroups() Used by JSON serialization. Declaration public bool ShouldSerializeFormattingGroups() Returns Type Description bool True if FormattingGroups should be serialized. ShouldSerializePlaceholderTagDefinitions() Used by JSON serialization. Declaration public bool ShouldSerializePlaceholderTagDefinitions() Returns Type Description bool True if PlaceholderTagDefinitions should be serialized. ShouldSerializeQuickInsertIds() Used by JSON serialization. Declaration public bool ShouldSerializeQuickInsertIds() Returns Type Description bool True if QuickInsertIds should be serialized. ShouldSerializeStructureTagDefinitions() Used by JSON serialization. Declaration public bool ShouldSerializeStructureTagDefinitions() Returns Type Description bool True if FormattingGroups should be serialized. ShouldSerializeSubContentPUs() Used by JSON serialization. Declaration public bool ShouldSerializeSubContentPUs() Returns Type Description bool True if SubContentPUs should be serialized. ShouldSerializeTagPairDefinitions() Used by JSON serialization. Declaration public bool ShouldSerializeTagPairDefinitions() Returns Type Description bool True if TagPairDefinitions should be serialized. ShouldSerializeTerminologyData() Used by JSON serialization. Declaration public bool ShouldSerializeTerminologyData() Returns Type Description bool True if TerminologyData should be serialized. Implements IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.FormattingGroup.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.FormattingGroup.html",
    "title": "Class FormattingGroup",
    "summary": "Class FormattingGroup Holds formatting elements that can be applied to different elements of BCM content. Inheritance object ExtensionDataContainer MetadataContainer SkeletonItem FormattingGroup Implements IEquatable<MetadataContainer> IEquatable<SkeletonItem> ICloneable<FormattingGroup> IEquatable<FormattingGroup> Inherited Members SkeletonItem.Equals(SkeletonItem) SkeletonItem.Id MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class FormattingGroup : SkeletonItem, IEquatable<MetadataContainer>, IEquatable<SkeletonItem>, ICloneable<FormattingGroup>, IEquatable<FormattingGroup> Constructors FormattingGroup() Initializes a new instance of the FormattingGroup class. Declaration public FormattingGroup() Properties Items Collection of formatting elements in this FormattingGroup. Declaration [DataMember(Name = \"items\")] public DictionaryEx<string, string> Items { get; set; } Property Value Type Description DictionaryEx<string, string> Methods Clone() Clones this instance. Declaration public FormattingGroup Clone() Returns Type Description FormattingGroup Equals(FormattingGroup) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public bool Equals(FormattingGroup other) Parameters Type Name Description FormattingGroup other Returns Type Description bool Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides SkeletonItem.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides SkeletonItem.GetHashCode() ShouldSerializeItems() Used by JSON serialization. Declaration public bool ShouldSerializeItems() Returns Type Description bool Implements IEquatable<T> IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.ITermAttributeContainer.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.ITermAttributeContainer.html",
    "title": "Interface ITermAttributeContainer",
    "summary": "Interface ITermAttributeContainer Interface for BCM elements containing terminology attributes. Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public interface ITermAttributeContainer Properties TermAttributes Gets or sets the term attributes. Declaration DictionaryEx<string, object> TermAttributes { get; set; } Property Value Type Description DictionaryEx<string, object> The term attributes."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.IdGenerator.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.IdGenerator.html",
    "title": "Class IdGenerator",
    "summary": "Class IdGenerator Creates unique numeric IDs for all the elements in different FileSkeleton collection. Inheritance object IdGenerator Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class IdGenerator Constructors IdGenerator() Declaration public IdGenerator() Methods GetNext<T>() Gets the next ID. Declaration public int GetNext<T>() where T : SkeletonItem Returns Type Description int The next ID in the sequence. Type Parameters Name Description T UpdateFrom(Document) Updates the ID sequence with the values from the specified Document. Declaration public void UpdateFrom(Document document) Parameters Type Name Description Document document The Document. UpdateFrom(FileSkeleton) Updates the ID sequence with the values from the specified FileSkeleton. Declaration public void UpdateFrom(FileSkeleton skeleton) Parameters Type Name Description FileSkeleton skeleton The FileSkeleton. Update<T>(T) Updates the ID sequence with the ID of the specified item. Declaration public void Update<T>(T item) where T : SkeletonItem Parameters Type Name Description T item The item. Type Parameters Name Description T"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.PlaceholderTagDefinition.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.PlaceholderTagDefinition.html",
    "title": "Class PlaceholderTagDefinition",
    "summary": "Class PlaceholderTagDefinition Definition of a Placeholder. Can be referenced by multiple PlaceholderTag elements. Inheritance object ExtensionDataContainer MetadataContainer SkeletonItem PlaceholderTagDefinition Implements IEquatable<MetadataContainer> IEquatable<SkeletonItem> ICloneable<PlaceholderTagDefinition> IEquatable<PlaceholderTagDefinition> Inherited Members SkeletonItem.Equals(SkeletonItem) SkeletonItem.Id MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class PlaceholderTagDefinition : SkeletonItem, IEquatable<MetadataContainer>, IEquatable<SkeletonItem>, ICloneable<PlaceholderTagDefinition>, IEquatable<PlaceholderTagDefinition> Constructors PlaceholderTagDefinition() Initializes a new instance of the PlaceholderTagDefinition class. Declaration public PlaceholderTagDefinition() Properties DisplayText Gets or sets the display text. Declaration [DataMember(Name = \"displayText\", EmitDefaultValue = false)] public string DisplayText { get; set; } Property Value Type Description string The display text. QuickInsertId Gets or sets the QuickInsert ID of the tag. Declaration [DataMember(Name = \"quickInsertId\", EmitDefaultValue = false)] public string QuickInsertId { get; set; } Property Value Type Description string The QuickInsert ID of the tag. SegmentationHint Gets or sets the segmentation hint. Declaration [DataMember(Name = \"segmentationHint\", EmitDefaultValue = false)] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public SegmentationHint SegmentationHint { get; set; } Property Value Type Description SegmentationHint The segmentation hint. SubContent Gets or sets the SubContentCollection of the placeholder tag. Declaration [DataMember(Name = \"subContent\")] public SubContentCollection SubContent { get; set; } Property Value Type Description SubContentCollection The SubContentCollection of the tag. TagContent Gets or sets the raw Placeholder tag content. Declaration [DataMember(Name = \"tagContent\", EmitDefaultValue = false)] public string TagContent { get; set; } Property Value Type Description string The raw Placeholder tag content of the tag. TextEquivalent Gets or sets the tag text equivalent. Declaration [DataMember(Name = \"textEquivalent\", EmitDefaultValue = false)] public string TextEquivalent { get; set; } Property Value Type Description string The tag text equivalent. Methods Clone() Clones this instance. Declaration public PlaceholderTagDefinition Clone() Returns Type Description PlaceholderTagDefinition A new clone of this instance. Equals(PlaceholderTagDefinition) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(PlaceholderTagDefinition other) Parameters Type Name Description PlaceholderTagDefinition other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides SkeletonItem.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides SkeletonItem.GetHashCode() Implements IEquatable<T> IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.SkeletonCollection-1.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.SkeletonCollection-1.html",
    "title": "Class SkeletonCollection<T>",
    "summary": "Class SkeletonCollection<T> Base class for collections used in a FileSkeleton. Inheritance object Collection<T> KeyedCollection<SkeletonCollectionKey, T> SkeletonCollection<T> Implements IList<T> ICollection<T> IList ICollection IReadOnlyList<T> IReadOnlyCollection<T> IEnumerable<T> IEnumerable IEquatable<SkeletonCollection<T>> Inherited Members KeyedCollection<SkeletonCollectionKey, T>.Contains(SkeletonCollectionKey) KeyedCollection<SkeletonCollectionKey, T>.TryGetValue(SkeletonCollectionKey, out T) KeyedCollection<SkeletonCollectionKey, T>.Remove(SkeletonCollectionKey) KeyedCollection<SkeletonCollectionKey, T>.ChangeItemKey(T, SkeletonCollectionKey) KeyedCollection<SkeletonCollectionKey, T>.ClearItems() KeyedCollection<SkeletonCollectionKey, T>.GetKeyForItem(T) KeyedCollection<SkeletonCollectionKey, T>.InsertItem(int, T) KeyedCollection<SkeletonCollectionKey, T>.RemoveItem(int) KeyedCollection<SkeletonCollectionKey, T>.SetItem(int, T) KeyedCollection<SkeletonCollectionKey, T>.Comparer KeyedCollection<SkeletonCollectionKey, T>.this[SkeletonCollectionKey] KeyedCollection<SkeletonCollectionKey, T>.Dictionary Collection<T>.Add(T) Collection<T>.Clear() Collection<T>.CopyTo(T[], int) Collection<T>.Contains(T) Collection<T>.GetEnumerator() Collection<T>.IndexOf(T) Collection<T>.Insert(int, T) Collection<T>.Remove(T) Collection<T>.RemoveAt(int) Collection<T>.Count Collection<T>.Items Collection<T>.this[int] object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class SkeletonCollection<T> : KeyedCollection<SkeletonCollectionKey, T>, IList<T>, ICollection<T>, IList, ICollection, IReadOnlyList<T>, IReadOnlyCollection<T>, IEnumerable<T>, IEnumerable, IEquatable<SkeletonCollection<T>> where T : SkeletonItem Type Parameters Name Description T Constructors SkeletonCollection() Declaration public SkeletonCollection() Properties IdGenerator Gets the IdGenerator. Declaration public IdGenerator IdGenerator { get; } Property Value Type Description IdGenerator The IdGenerator. ParentSkeleton Gets or sets the parent FileSkeleton. Declaration public FileSkeleton ParentSkeleton { get; set; } Property Value Type Description FileSkeleton The parent FileSkeleton. Methods ClearItems() Removes all elements from the KeyedCollection<TKey, TItem>. Declaration protected override void ClearItems() Overrides KeyedCollection<SkeletonCollectionKey, T>.ClearItems() Equals(SkeletonCollection<T>) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public bool Equals(SkeletonCollection<T> other) Parameters Type Name Description SkeletonCollection<T> other Returns Type Description bool GetById(int) Gets an element by its numerical id. Declaration public T GetById(int id) Parameters Type Name Description int id The id. Returns Type Description T If found, returns the element with the Id id; otherwise returns default(T) GetKeyForItem(T) Extracts the key from the specified element. Declaration protected override SkeletonCollectionKey GetKeyForItem(T item) Parameters Type Name Description T item The element from which to extract the key. Returns Type Description SkeletonCollectionKey The key for the specified element. Overrides KeyedCollection<SkeletonCollectionKey, T>.GetKeyForItem(T) GetOrAdd(T) Gets the element if it already exists in the collection. Otherwise, it is added to the collection and gives it the next ID in the IdGenerator sequence. Declaration public T GetOrAdd(T elem) Parameters Type Name Description T elem The element. Returns Type Description T The existing element; or the newly added one with an Id set. GetOrAddWithExistingId(T) Gets the element if it already exists in the collection. Otherwise, it is added to the collection (preserving its existing ID). Declaration public T GetOrAddWithExistingId(T elem) Parameters Type Name Description T elem The element. Returns Type Description T The existing element; or the newly added one with an Id set. InsertItem(int, T) Inserts an element into the KeyedCollection<TKey, TItem> at the specified index. Declaration protected override void InsertItem(int index, T item) Parameters Type Name Description int index The zero-based index at which item should be inserted. T item The object to insert. Overrides KeyedCollection<SkeletonCollectionKey, T>.InsertItem(int, T) RemoveItem(int) Removes the element at the specified index of the KeyedCollection<TKey, TItem>. Declaration protected override void RemoveItem(int index) Parameters Type Name Description int index The index of the element to remove. Overrides KeyedCollection<SkeletonCollectionKey, T>.RemoveItem(int) SetItem(int, T) Replaces the item at the specified index with the specified item. Declaration protected override void SetItem(int index, T item) Parameters Type Name Description int index The zero-based index of the item to be replaced. T item The new item. Overrides KeyedCollection<SkeletonCollectionKey, T>.SetItem(int, T) Implements IList<T> ICollection<T> IList ICollection IReadOnlyList<T> IReadOnlyCollection<T> IEnumerable<T> IEnumerable IEquatable<T> Extension Methods ModelExtensions.IsSequenceEqual<TSource>(IList<TSource>, IList<TSource>)"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.SkeletonCollectionKey.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.SkeletonCollectionKey.html",
    "title": "Struct SkeletonCollectionKey",
    "summary": "Struct SkeletonCollectionKey Wrapper used for defining integer keys in the FileSkeleton collections. Implements IEquatable<SkeletonCollectionKey> Inherited Members ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public struct SkeletonCollectionKey : IEquatable<SkeletonCollectionKey> Constructors SkeletonCollectionKey(int) Initializes a new instance of the SkeletonCollectionKey struct. Declaration public SkeletonCollectionKey(int id) Parameters Type Name Description int id The identifier. Properties Id Gets or sets the identifier. Declaration public int Id { get; set; } Property Value Type Description int The identifier. Methods Equals(SkeletonCollectionKey) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public bool Equals(SkeletonCollectionKey other) Parameters Type Name Description SkeletonCollectionKey other Returns Type Description bool Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides ValueType.Equals(object) From(int) Creates a new SkeletonCollectionKey from an integer. Declaration public static SkeletonCollectionKey From(int from) Parameters Type Name Description int from The value with which to initialize this instance. Returns Type Description SkeletonCollectionKey A new instance of the SkeletonCollectionKey GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides ValueType.GetHashCode() Operators operator ==(SkeletonCollectionKey, SkeletonCollectionKey) Implements the operator ==. Declaration public static bool operator ==(SkeletonCollectionKey left, SkeletonCollectionKey right) Parameters Type Name Description SkeletonCollectionKey left The left hand item. SkeletonCollectionKey right The right hand item. Returns Type Description bool The result of Equals(SkeletonCollectionKey) operator !=(SkeletonCollectionKey, SkeletonCollectionKey) Implements the operator !=. Declaration public static bool operator !=(SkeletonCollectionKey left, SkeletonCollectionKey right) Parameters Type Name Description SkeletonCollectionKey left The left hand item. SkeletonCollectionKey right The right hand item. Returns Type Description bool The negated result of Equals(SkeletonCollectionKey) Implements IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.SkeletonItem.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.SkeletonItem.html",
    "title": "Class SkeletonItem",
    "summary": "Class SkeletonItem Base class for different types of elements definied in a FileSkeleton. Inheritance object ExtensionDataContainer MetadataContainer SkeletonItem CommentDefinition Context ContextDefinition FormattingGroup PlaceholderTagDefinition StructureTagDefinition TagPairDefinition TerminologyData Implements IEquatable<MetadataContainer> IEquatable<SkeletonItem> Inherited Members MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public abstract class SkeletonItem : MetadataContainer, IEquatable<MetadataContainer>, IEquatable<SkeletonItem> Constructors SkeletonItem() Declaration protected SkeletonItem() Properties Id Gets or sets the identifier. Declaration [JsonProperty(PropertyName = \"id\", Order = -2147483648)] public int Id { get; set; } Property Value Type Description int The identifier. Methods Equals(SkeletonItem) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(SkeletonItem other) Parameters Type Name Description SkeletonItem other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MetadataContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MetadataContainer.GetHashCode() Implements IEquatable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.StructureTagDefinition.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.StructureTagDefinition.html",
    "title": "Class StructureTagDefinition",
    "summary": "Class StructureTagDefinition Definition of a StructureTag. Can be referenced by multiple StructureTag elements. Inheritance object ExtensionDataContainer MetadataContainer SkeletonItem StructureTagDefinition Implements IEquatable<MetadataContainer> IEquatable<SkeletonItem> ICloneable<StructureTagDefinition> IEquatable<StructureTagDefinition> Inherited Members SkeletonItem.Equals(SkeletonItem) SkeletonItem.Id MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class StructureTagDefinition : SkeletonItem, IEquatable<MetadataContainer>, IEquatable<SkeletonItem>, ICloneable<StructureTagDefinition>, IEquatable<StructureTagDefinition> Constructors StructureTagDefinition() Declaration public StructureTagDefinition() Properties DisplayText Gets or sets the display text. Declaration [DataMember(Name = \"displayText\", EmitDefaultValue = false)] public string DisplayText { get; set; } Property Value Type Description string The display text. SubContent Gets or sets the localizable sub-content. Declaration [DataMember(Name = \"subContent\", EmitDefaultValue = false)] public SubContentCollection SubContent { get; set; } Property Value Type Description SubContentCollection The localizable sub-content. TagContent Gets or sets the content of the tag. Declaration [DataMember(Name = \"tagContent\", EmitDefaultValue = false)] public string TagContent { get; set; } Property Value Type Description string The content of the tag. Methods Clone() Clones this instance. Declaration public StructureTagDefinition Clone() Returns Type Description StructureTagDefinition A clone of this instance. Equals(StructureTagDefinition) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(StructureTagDefinition other) Parameters Type Name Description StructureTagDefinition other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides SkeletonItem.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides SkeletonItem.GetHashCode() Implements IEquatable<T> IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.SubContentCollection.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.SubContentCollection.html",
    "title": "Class SubContentCollection",
    "summary": "Class SubContentCollection Collection of subcontent LocalizableSubContent elements. Can appear in different MarkupData elements. Inheritance object Collection<LocalizableSubContent> KeyedCollection<string, LocalizableSubContent> KeyBasedCollection<string, LocalizableSubContent> SubContentCollection Implements IList<LocalizableSubContent> ICollection<LocalizableSubContent> IList ICollection IReadOnlyList<LocalizableSubContent> IReadOnlyCollection<LocalizableSubContent> IEnumerable<LocalizableSubContent> IEnumerable IEquatable<KeyBasedCollection<string, LocalizableSubContent>> Inherited Members KeyBasedCollection<string, LocalizableSubContent>.KeySelector KeyBasedCollection<string, LocalizableSubContent>.ForEach(Action<LocalizableSubContent>) KeyBasedCollection<string, LocalizableSubContent>.Equals(KeyBasedCollection<string, LocalizableSubContent>) KeyBasedCollection<string, LocalizableSubContent>.Equals(object) KeyBasedCollection<string, LocalizableSubContent>.GetHashCode() KeyBasedCollection<string, LocalizableSubContent>.GetKeyForItem(LocalizableSubContent) KeyedCollection<string, LocalizableSubContent>.Contains(string) KeyedCollection<string, LocalizableSubContent>.TryGetValue(string, out LocalizableSubContent) KeyedCollection<string, LocalizableSubContent>.Remove(string) KeyedCollection<string, LocalizableSubContent>.ChangeItemKey(LocalizableSubContent, string) KeyedCollection<string, LocalizableSubContent>.ClearItems() KeyedCollection<string, LocalizableSubContent>.InsertItem(int, LocalizableSubContent) KeyedCollection<string, LocalizableSubContent>.RemoveItem(int) KeyedCollection<string, LocalizableSubContent>.SetItem(int, LocalizableSubContent) KeyedCollection<string, LocalizableSubContent>.Comparer KeyedCollection<string, LocalizableSubContent>.this[string] KeyedCollection<string, LocalizableSubContent>.Dictionary Collection<LocalizableSubContent>.Add(LocalizableSubContent) Collection<LocalizableSubContent>.Clear() Collection<LocalizableSubContent>.CopyTo(LocalizableSubContent[], int) Collection<LocalizableSubContent>.Contains(LocalizableSubContent) Collection<LocalizableSubContent>.GetEnumerator() Collection<LocalizableSubContent>.IndexOf(LocalizableSubContent) Collection<LocalizableSubContent>.Insert(int, LocalizableSubContent) Collection<LocalizableSubContent>.Remove(LocalizableSubContent) Collection<LocalizableSubContent>.RemoveAt(int) Collection<LocalizableSubContent>.ClearItems() Collection<LocalizableSubContent>.InsertItem(int, LocalizableSubContent) Collection<LocalizableSubContent>.RemoveItem(int) Collection<LocalizableSubContent>.SetItem(int, LocalizableSubContent) Collection<LocalizableSubContent>.Count Collection<LocalizableSubContent>.Items Collection<LocalizableSubContent>.this[int] object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class SubContentCollection : KeyBasedCollection<string, LocalizableSubContent>, IList<LocalizableSubContent>, ICollection<LocalizableSubContent>, IList, ICollection, IReadOnlyList<LocalizableSubContent>, IReadOnlyCollection<LocalizableSubContent>, IEnumerable<LocalizableSubContent>, IEnumerable, IEquatable<KeyBasedCollection<string, LocalizableSubContent>> Constructors SubContentCollection() Initializes a new instance of the SubContentCollection class. Declaration public SubContentCollection() Implements IList<T> ICollection<T> IList ICollection IReadOnlyList<T> IReadOnlyCollection<T> IEnumerable<T> IEnumerable IEquatable<T> Extension Methods ModelExtensions.IsSequenceEqual<TSource>(IList<TSource>, IList<TSource>)"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.TagPairDefinition.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.TagPairDefinition.html",
    "title": "Class TagPairDefinition",
    "summary": "Class TagPairDefinition Definition of a TagPair. Can be referenced by multiple TagPair elements. Inheritance object ExtensionDataContainer MetadataContainer SkeletonItem TagPairDefinition Implements IEquatable<MetadataContainer> IEquatable<SkeletonItem> ICloneable<TagPairDefinition> IEquatable<TagPairDefinition> Inherited Members SkeletonItem.Equals(SkeletonItem) SkeletonItem.Id MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class TagPairDefinition : SkeletonItem, IEquatable<MetadataContainer>, IEquatable<SkeletonItem>, ICloneable<TagPairDefinition>, IEquatable<TagPairDefinition> Constructors TagPairDefinition() Initializes a new instance of the TagPairDefinition class. Declaration public TagPairDefinition() Properties CanHide Gets or sets a value indicating whether this tag can be hidden when displayed. Declaration [DataMember(Name = \"canHide\")] public bool CanHide { get; set; } Property Value Type Description bool true if this tag can be hidden when displayed; otherwise, false. EndTagContent Gets or sets the raw end tag content. Declaration [DataMember(Name = \"endTagContent\", EmitDefaultValue = false)] public string EndTagContent { get; set; } Property Value Type Description string The raw end tag content. EndTagDisplayText Gets or sets the end tag display text. Declaration [DataMember(Name = \"endTagDisplayText\", EmitDefaultValue = false)] public string EndTagDisplayText { get; set; } Property Value Type Description string The end tag display text. FormattingGroupId Gets or sets the formatting group identifier. Declaration [DataMember(Name = \"formattingGroupId\")] public int FormattingGroupId { get; set; } Property Value Type Description int The formatting group identifier. QuickInsertId Gets or sets the QuickInsert identifier of this tag. Declaration [DataMember(Name = \"quickInsertId\", EmitDefaultValue = false)] public string QuickInsertId { get; set; } Property Value Type Description string The QuickInsert identifier of this tag. SegmentationHint Gets or sets the segmentation hint. Declaration [DataMember(Name = \"segmentationHint\", EmitDefaultValue = false)] [JsonProperty(NullValueHandling = NullValueHandling.Ignore, DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)] public SegmentationHint SegmentationHint { get; set; } Property Value Type Description SegmentationHint The segmentation hint. StartTagContent Gets or sets the raw start tag conten. Declaration [DataMember(Name = \"startTagContent\", EmitDefaultValue = false)] public string StartTagContent { get; set; } Property Value Type Description string The raw start tag content. StartTagDisplayText Gets or sets the start tag display text. Declaration [DataMember(Name = \"startTagDisplayText\", EmitDefaultValue = false)] public string StartTagDisplayText { get; set; } Property Value Type Description string The start tag display text. SubContent Gets or sets the localizable subcontent. Declaration [DataMember(Name = \"subContent\", EmitDefaultValue = false)] public SubContentCollection SubContent { get; set; } Property Value Type Description SubContentCollection The localizable subcontent. Methods Clone() Clones this instance. Declaration public TagPairDefinition Clone() Returns Type Description TagPairDefinition Equals(TagPairDefinition) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(TagPairDefinition other) Parameters Type Name Description TagPairDefinition other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides SkeletonItem.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides SkeletonItem.GetHashCode() Implements IEquatable<T> IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.Term.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.Term.html",
    "title": "Class Term",
    "summary": "Class Term Terminology element. Inheritance object ExtensionDataContainer Term Implements ICloneable<Term> IEquatable<Term> ITermAttributeContainer Inherited Members ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class Term : ExtensionDataContainer, ICloneable<Term>, IEquatable<Term>, ITermAttributeContainer Constructors Term() Initializes a new instance of the Term class. Declaration public Term() Properties Id Gets or sets the identifier. Declaration [DataMember(Name = \"id\")] public string Id { get; set; } Property Value Type Description string The identifier. Score Gets or sets the terminology score. Declaration [DataMember(Name = \"score\")] public double Score { get; set; } Property Value Type Description double The terminology score. TermAttributes Gets or sets term level attributes contained at any level within the termbase field structures. Declaration [DataMember(Name = \"termAttributes\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public DictionaryEx<string, object> TermAttributes { get; set; } Property Value Type Description DictionaryEx<string, object> The term attributes. TermOrigin Gets or sets the term origin. Declaration [DataMember(Name = \"termOrigin\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public TermOrigin TermOrigin { get; set; } Property Value Type Description TermOrigin The term origin. TermTranslations Gets or sets the term translations. Declaration [DataMember(Name = \"termTranslations\")] public List<TermTranslation> TermTranslations { get; set; } Property Value Type Description List<TermTranslation> The term translations. Text Gets or sets the terminology text. Declaration [DataMember(Name = \"text\")] public string Text { get; set; } Property Value Type Description string The terminology text. Methods Clone() Clones this instance. Declaration public Term Clone() Returns Type Description Term A deep clone of this instance. Equals(Term) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public bool Equals(Term other) Parameters Type Name Description Term other Returns Type Description bool Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides object.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides object.GetHashCode() ShouldSerializeTermAttributes() Used by JSON serialization. Declaration public bool ShouldSerializeTermAttributes() Returns Type Description bool ShouldSerializeTermTranslations() Used by JSON serialization. Declaration public bool ShouldSerializeTermTranslations() Returns Type Description bool Implements ICloneable<T> IEquatable<T> ITermAttributeContainer"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.TermOrigin.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.TermOrigin.html",
    "title": "Class TermOrigin",
    "summary": "Class TermOrigin Data on the creation origin of Term. Inheritance object ExtensionDataContainer TermOrigin Implements ICloneable<TermOrigin> IEquatable<TermOrigin> Inherited Members ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class TermOrigin : ExtensionDataContainer, ICloneable<TermOrigin>, IEquatable<TermOrigin> Constructors TermOrigin() Declaration public TermOrigin() Properties ResourceId Gets or sets the terminology resource identifier. Declaration [DataMember(Name = \"resourceId\")] public string ResourceId { get; set; } Property Value Type Description string The terminology resource identifier. ResourceName Gets or sets the name of the terminology resource. Declaration [DataMember(Name = \"resourceName\")] public string ResourceName { get; set; } Property Value Type Description string The name of the terminology resource. SystemId Gets or sets the identifier of the terminology system. Declaration [DataMember(Name = \"systemId\")] public string SystemId { get; set; } Property Value Type Description string The terminology system identifier. SystemName Gets or sets the terminology system nane. Declaration [DataMember(Name = \"systemName\")] public string SystemName { get; set; } Property Value Type Description string The terminology system name. Methods Clone() Clones this instance. Declaration public TermOrigin Clone() Returns Type Description TermOrigin Equals(TermOrigin) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public bool Equals(TermOrigin other) Parameters Type Name Description TermOrigin other Returns Type Description bool Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides object.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides object.GetHashCode() Implements ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.TermTranslation.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.TermTranslation.html",
    "title": "Class TermTranslation",
    "summary": "Class TermTranslation Translation of a specific Term. Inheritance object ExtensionDataContainer TermTranslation Implements ICloneable<TermTranslation> IEquatable<TermTranslation> ITermAttributeContainer Inherited Members ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class TermTranslation : ExtensionDataContainer, ICloneable<TermTranslation>, IEquatable<TermTranslation>, ITermAttributeContainer Constructors TermTranslation() Initializes a new instance of the TermTranslation class. Declaration public TermTranslation() Properties Id Gets or sets the identifier. Declaration [DataMember(Name = \"id\")] public string Id { get; set; } Property Value Type Description string The identifier. TermAttributes Gets or sets the term attributes. Declaration [DataMember(Name = \"termAttributes\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public DictionaryEx<string, object> TermAttributes { get; set; } Property Value Type Description DictionaryEx<string, object> The term attributes. Text Gets or sets the text. Declaration [DataMember(Name = \"text\")] public string Text { get; set; } Property Value Type Description string The text. Methods Clone() Clones this instance. Declaration public TermTranslation Clone() Returns Type Description TermTranslation Equals(TermTranslation) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public bool Equals(TermTranslation other) Parameters Type Name Description TermTranslation other Returns Type Description bool Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides object.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides object.GetHashCode() ShouldSerializeTermAttributes() Used by JSON serialization. Declaration public bool ShouldSerializeTermAttributes() Returns Type Description bool Implements ICloneable<T> IEquatable<T> ITermAttributeContainer"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.TerminologyData.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.TerminologyData.html",
    "title": "Class TerminologyData",
    "summary": "Class TerminologyData Data containing a list of Terms representing terminology information. Inheritance object ExtensionDataContainer MetadataContainer SkeletonItem TerminologyData Implements IEquatable<MetadataContainer> IEquatable<SkeletonItem> ICloneable<TerminologyData> IEquatable<TerminologyData> Inherited Members SkeletonItem.Equals(SkeletonItem) SkeletonItem.Id MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Skeleton Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class TerminologyData : SkeletonItem, IEquatable<MetadataContainer>, IEquatable<SkeletonItem>, ICloneable<TerminologyData>, IEquatable<TerminologyData> Constructors TerminologyData() Declaration public TerminologyData() Properties Origin Gets or sets the origin of the terminology information. Declaration [Obsolete(\"Will be removed in a future version. Use the TermOrigin instead!\")] [DataMember(Name = \"origin\")] public string Origin { get; set; } Property Value Type Description string The origin. Terms Gets or sets the terms. Declaration [DataMember(Name = \"terms\")] public List<Term> Terms { get; set; } Property Value Type Description List<Term> The terms. Methods Clone() Clones this instance. Declaration public TerminologyData Clone() Returns Type Description TerminologyData A deep clone of this instance. Equals(TerminologyData) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public bool Equals(TerminologyData other) Parameters Type Name Description TerminologyData other Returns Type Description bool Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides SkeletonItem.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides SkeletonItem.GetHashCode() Implements IEquatable<T> IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Skeleton.html",
    "title": "Namespace Sdl.Core.Bcm.BcmModel.Skeleton",
    "summary": "Namespace Sdl.Core.Bcm.BcmModel.Skeleton Classes CommentDefinition Contains comment data. Can be referenced by multiple CommentContainer instances. Context Context information, organized as a tree structure. ContextDefinition Holds context data. Can be referenced by multiple Context elements. FileSkeleton Holds data for a File that is referenced by different MarkupData elements. FormattingGroup Holds formatting elements that can be applied to different elements of BCM content. IdGenerator Creates unique numeric IDs for all the elements in different FileSkeleton collection. PlaceholderTagDefinition Definition of a Placeholder. Can be referenced by multiple PlaceholderTag elements. SkeletonCollection<T> Base class for collections used in a FileSkeleton. SkeletonItem Base class for different types of elements definied in a FileSkeleton. StructureTagDefinition Definition of a StructureTag. Can be referenced by multiple StructureTag elements. SubContentCollection Collection of subcontent LocalizableSubContent elements. Can appear in different MarkupData elements. TagPairDefinition Definition of a TagPair. Can be referenced by multiple TagPair elements. Term Terminology element. TermOrigin Data on the creation origin of Term. TermTranslation Translation of a specific Term. TerminologyData Data containing a list of Terms representing terminology information. Structs SkeletonCollectionKey Wrapper used for defining integer keys in the FileSkeleton collections. Interfaces ITermAttributeContainer Interface for BCM elements containing terminology attributes. Enums CommentSeverity Supported values of comment severity."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.StructureTag.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.StructureTag.html",
    "title": "Class StructureTag",
    "summary": "Class StructureTag A tag that is used for document structure only and has no translatable content. Inheritance object ExtensionDataContainer MetadataContainer MarkupData StructureTag Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> ISkeletonItemReference<StructureTagDefinition> Inherited Members MarkupData.UniqueClone() MarkupData.Id MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.ParentParagraphUnit MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class StructureTag : MarkupData, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData>, ISkeletonItemReference<StructureTagDefinition> Constructors StructureTag() Declaration public StructureTag() Properties Definition Gets the definition of this item from the FileSkeleton. Declaration public StructureTagDefinition Definition { get; } Property Value Type Description StructureTagDefinition The definition of this item from the FileSkeleton. StructureTagDefinitionId Gets or sets the StructureTagDefinition id of this instance. Declaration [DataMember(Name = \"structureTagDefinitionId\")] public int StructureTagDefinitionId { get; set; } Property Value Type Description int The StructureTagDefinition id of this instance. TagNumber Gets or sets the TagNumber for this instance. This is the same as the \"frameworkOriginalTagId\" metadata but now exposed on the tag as well (the metadata will become deprecated). If needed, it will be populated on deserialization from the metadata, the value remains null iff not present (which should not be the case). Declaration [DataMember(Name = \"tagNumber\")] public string TagNumber { get; set; } Property Value Type Description string Type Gets the type of MarkupData. Declaration [JsonProperty(\"type\")] protected override string Type { get; set; } Property Value Type Description string The type. Overrides MarkupData.Type Methods AcceptVisitor(BcmVisitor) Accepts a visitor of type BcmVisitor. Declaration public override void AcceptVisitor(BcmVisitor visitor) Parameters Type Name Description BcmVisitor visitor The BcmVisitor used to visit this item. Overrides MarkupData.AcceptVisitor(BcmVisitor) Clone() Clones this instance. Declaration public StructureTag Clone() Returns Type Description StructureTag A deep clone of this instance. Equals(MarkupData) Indicates whether the current object is equal to another object of the same type. Declaration public override bool Equals(MarkupData other) Parameters Type Name Description MarkupData other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Overrides MarkupData.Equals(MarkupData) Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MarkupData.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MarkupData.GetHashCode() Implements IEquatable<T> ICloneable<T> IEquatable<T> ISkeletonItemReference<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.TagPair.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.TagPair.html",
    "title": "Class TagPair",
    "summary": "Class TagPair A tag composed of a start and and end tag. Can contain other MarkupData elements. Inheritance object ExtensionDataContainer MetadataContainer MarkupData MarkupDataContainer TagPair Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> ISkeletonItemReference<TagPairDefinition> Inherited Members MarkupDataContainer.AutoClonedTagPairKey MarkupDataContainer.GetAllChildren(Func<MarkupData, bool>) MarkupDataContainer.GetAllChildren<T>(Func<T, bool>) MarkupDataContainer.Add(MarkupData) MarkupDataContainer.Add(IEnumerable<MarkupData>) MarkupDataContainer.Insert(int, MarkupData) MarkupDataContainer.Remove(MarkupData) MarkupDataContainer.Clear() MarkupDataContainer.GetEnumerator() MarkupDataContainer.MoveToContainer(MarkupDataContainer, int, int, int) MarkupDataContainer.Equals(MarkupDataContainer) MarkupDataContainer.ToString() MarkupDataContainer.CloneWithoutChildren() MarkupDataContainer.Children MarkupDataContainer.AllSubItems MarkupDataContainer.Count MarkupDataContainer.this[int] MarkupData.Id MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.ParentParagraphUnit MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class TagPair : MarkupDataContainer, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData>, ISkeletonItemReference<TagPairDefinition> Constructors TagPair() Declaration public TagPair() Properties Definition Gets the definition of this item from the FileSkeleton. Declaration public TagPairDefinition Definition { get; } Property Value Type Description TagPairDefinition The definition of this item from the FileSkeleton. TagNumber Gets or sets the TagNumber for this instance. This is the same as the \"frameworkOriginalTagId\" metadata but now exposed on the tag as well (the metadata will become deprecated). If needed, it will be populated on deserialization from the metadata, the value remains null iff not present (which should not be the case). Declaration [DataMember(Name = \"tagNumber\")] public string TagNumber { get; set; } Property Value Type Description string TagPairDefinitionId Gets or sets the TagPairDefinition id for this instance. Declaration [DataMember(Name = \"tagPairDefinitionId\")] public int TagPairDefinitionId { get; set; } Property Value Type Description int The TagPairDefinition id for this instance. Type Gets the type of MarkupData. Declaration [JsonProperty(\"type\")] protected override string Type { get; set; } Property Value Type Description string The type. Overrides MarkupData.Type Methods AcceptVisitor(BcmVisitor) Accepts a visitor of type BcmVisitor. Declaration public override void AcceptVisitor(BcmVisitor visitor) Parameters Type Name Description BcmVisitor visitor The BcmVisitor used to visit this item. Overrides MarkupData.AcceptVisitor(BcmVisitor) Clone() Clones this instance. Declaration public TagPair Clone() Returns Type Description TagPair A deep clone of this instance. Equals(MarkupData) Indicates whether the current object is equal to another object of the same type. Declaration public override bool Equals(MarkupData other) Parameters Type Name Description MarkupData other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Overrides MarkupDataContainer.Equals(MarkupData) Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MarkupDataContainer.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance. Overrides MarkupDataContainer.GetHashCode() OnDeserialized() Declaration protected override void OnDeserialized() Overrides MarkupDataContainer.OnDeserialized() UniqueClone() Clones this instance, setting a new id. Declaration public TagPair UniqueClone() Returns Type Description TagPair A deep clone of this instance, with a new unique id. Implements IEquatable<T> ICloneable<T> IEquatable<T> ISkeletonItemReference<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.TagPairMetaDataKeys.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.TagPairMetaDataKeys.html",
    "title": "Class TagPairMetaDataKeys",
    "summary": "Class TagPairMetaDataKeys Constants used a keys for TagPair metadata. Inheritance object TagPairMetaDataKeys Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public static class TagPairMetaDataKeys Fields EndTagMetadataPrefix Metadata key used for prefixing end tag related metadata (used by internal conversion). Declaration public const string EndTagMetadataPrefix = \"__end_\" Field Value Type Description string FrameworkOriginalSegmentationHint Metadata key identifying the original TagPair segmentation hint set by the SDL Filter Framework. Declaration public const string FrameworkOriginalSegmentationHint = \"_originalSegmentationHint\" Field Value Type Description string FrameworkOriginalTagId Metadata key identifying the original TagPair id set by the SDL Filter Framework. Declaration public const string FrameworkOriginalTagId = \"frameworkOriginalTagId\" Field Value Type Description string"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.TextContextMatchLevel.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.TextContextMatchLevel.html",
    "title": "Enum TextContextMatchLevel",
    "summary": "Enum TextContextMatchLevel Used with textual context matches to indicate the level of matching. Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [JsonConverter(typeof(EnumConverter), new object[] { TextContextMatchLevel.None })] public enum TextContextMatchLevel Fields Name Description None The textual context does not match. Source Source content matches with surrounding source content. SourceAndTarget Source and target matches surrounding source and target content."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.TextMarkup.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.TextMarkup.html",
    "title": "Class TextMarkup",
    "summary": "Class TextMarkup A MarkupData containing plain text. Inheritance object ExtensionDataContainer MetadataContainer MarkupData TextMarkup Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> Inherited Members MarkupData.UniqueClone() MarkupData.Id MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.ParentParagraphUnit MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class TextMarkup : MarkupData, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData> Constructors TextMarkup() Initializes a new instance of the TextMarkup class. Declaration public TextMarkup() TextMarkup(string) Initializes a new instance of the TextMarkup class. Declaration public TextMarkup(string text) Parameters Type Name Description string text The text. Properties Text Gets or sets the text. Declaration [DataMember(Name = \"text\")] public string Text { get; set; } Property Value Type Description string The text. Type Gets the type of MarkupData. Declaration [JsonProperty(\"type\")] protected override string Type { get; set; } Property Value Type Description string The type. Overrides MarkupData.Type Methods AcceptVisitor(BcmVisitor) Accepts a visitor of type BcmVisitor. Declaration public override void AcceptVisitor(BcmVisitor visitor) Parameters Type Name Description BcmVisitor visitor The BcmVisitor used to visit this item. Overrides MarkupData.AcceptVisitor(BcmVisitor) Clone() Clones this instance. Declaration public TextMarkup Clone() Returns Type Description TextMarkup A deep clone of this instance. Equals(MarkupData) Indicates whether the current object is equal to another object of the same type. Declaration public override bool Equals(MarkupData other) Parameters Type Name Description MarkupData other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Overrides MarkupData.Equals(MarkupData) Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MarkupData.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance, Overrides MarkupData.GetHashCode() ToString() Converts to string. Declaration public override string ToString() Returns Type Description string A string that represents this instance. Overrides object.ToString() Implements IEquatable<T> ICloneable<T> IEquatable<T> See Also MarkupData"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.DateTimePatternType.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.DateTimePatternType.html",
    "title": "Enum DateTimePatternType",
    "summary": "Enum DateTimePatternType DateTime patterns used by Token elements. Namespace: Sdl.Core.Bcm.BcmModel.Tokenization Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [Flags] public enum DateTimePatternType Fields Name Description LongDate The pattern represents a long date pattern LongTime The pattern represents a long time pattern ShortDate The pattern represents a short date pattern ShortTime The pattern represents a short time pattern"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.NumericSeparator.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.NumericSeparator.html",
    "title": "Enum NumericSeparator",
    "summary": "Enum NumericSeparator The numeric separators type which can occur in a number token. Namespace: Sdl.Core.Bcm.BcmModel.Tokenization Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public enum NumericSeparator Fields Name Description Alternate Indicates that an alternate separator (group or decimal separator) is used. None Indicates that no explicit separator is used. Primary Indicates that the culture's primary separator (group or decimal separator) is used."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.SegmentPosition.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.SegmentPosition.html",
    "title": "Class SegmentPosition",
    "summary": "Class SegmentPosition Represents a position within a segment. Inheritance object ExtensionDataContainer SegmentPosition Inherited Members ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Tokenization Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class SegmentPosition : ExtensionDataContainer Constructors SegmentPosition() Initializes a new instance of the SegmentPosition class. Declaration public SegmentPosition() SegmentPosition(int, int) Initializes a new instance with the specified arguments. Declaration public SegmentPosition(int runIndex, int positionInRun) Parameters Type Name Description int runIndex The index of the segment element within the segment. int positionInRun The position within the run. This is only relevant for MediaTypeNames.Text elements, and has no effect for other segment element types. Properties PositionInRun Gets or sets the position within the subsegment. Declaration [DataMember(Name = \"positionInRun\")] public int PositionInRun { get; set; } Property Value Type Description int RunIndex Gets or sets the index of the run (segment element) within the segment. Declaration [DataMember(Name = \"runIndex\")] public int RunIndex { get; set; } Property Value Type Description int Methods Clone() Creates a new instance that is a deep copy of this instance. Declaration public SegmentPosition Clone() Returns Type Description SegmentPosition A new instance that is a deep copy of this instance. Compare(SegmentPosition, SegmentPosition) Compares two segment positions and returns an indication of their sort order. Declaration public static int Compare(SegmentPosition a, SegmentPosition b) Parameters Type Name Description SegmentPosition a The first of the two items to compare. SegmentPosition b The second of the two items to compare. Returns Type Description int An int value less than zero if a precedes b, zero if a denotes the same position as b, and greater than zero if a follows b. Equals(object) System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj The object to compare with the current object. Returns Type Description bool true if the specified object is equal to the current object; otherwise, false. Overrides object.Equals(object) GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description int A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. Overrides object.GetHashCode() ToString() ToString() Declaration public override string ToString() Returns Type Description string A string representation of the object, for display purposes. Overrides object.ToString()"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.SegmentRange.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.SegmentRange.html",
    "title": "Class SegmentRange",
    "summary": "Class SegmentRange A selection of content inside a Segment. Inheritance object ExtensionDataContainer SegmentRange Inherited Members ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel.Tokenization Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class SegmentRange : ExtensionDataContainer Constructors SegmentRange() Initializes a new instance of the SegmentRange class. Declaration public SegmentRange() SegmentRange(SegmentPosition, SegmentPosition) Initializes a new instance with the provided positions. Declaration public SegmentRange(SegmentPosition from, SegmentPosition into) Parameters Type Name Description SegmentPosition from The start position. SegmentPosition into The end position. Remarks No checks are performed to verify that the start position precedes the end position. SegmentRange(int, int, int) Initializes a new instance of with the given parameters. Declaration public SegmentRange(int runIndex, int fromIndex, int intoIndex) Parameters Type Name Description int runIndex The segment element index (run) of the range. int fromIndex The start position in the run. int intoIndex The end position (inclusive) in the run. Properties From Gets or sets the start SegmentPosition in the segment. Declaration [DataMember(Name = \"from\")] public SegmentPosition From { get; set; } Property Value Type Description SegmentPosition The start SegmentPosition in the segment. Into Gets or sets the end SegmentPosition in the segment. Declaration [DataMember(Name = \"into\")] public SegmentPosition Into { get; set; } Property Value Type Description SegmentPosition The end SegmentPosition in the segment. Methods Clone() Creates a new instance that is a deep copy of this instance. Declaration public SegmentRange Clone() Returns Type Description SegmentRange A new instance that is a deep copy of this instance. Compare(SegmentRange, SegmentRange) Compares two segment ranges and returns a value indicating their order. Declaration public static int Compare(SegmentRange a, SegmentRange b) Parameters Type Name Description SegmentRange a The first of the two items to compare. SegmentRange b The second of the two items to compare. Returns Type Description int An integer value less than zero if a precedes b, zero if a and b are in the same range, and a value greater than zero if a follows b. Only the start positions are compared. Equals(SegmentRange) Compares the current range to another segment range. Declaration public bool Equals(SegmentRange other) Parameters Type Name Description SegmentRange other The range to compare with. Returns Type Description bool true if both ranges are identical. Equals(object) System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj The object to compare with the current object. Returns Type Description bool true if the specified object is equal to the current object; otherwise, false. Overrides object.Equals(object) GetHashCode() System.Object.GetHashCode(object) Declaration public override int GetHashCode() Returns Type Description int Overrides object.GetHashCode() ToString() ToString() Declaration public override string ToString() Returns Type Description string A string representation of the object, for display purposes. Overrides object.ToString()"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Sign.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Sign.html",
    "title": "Enum Sign",
    "summary": "Enum Sign The sign of a number Namespace: Sdl.Core.Bcm.BcmModel.Tokenization Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public enum Sign Fields Name Description Minus A minus sign at the start of the number. None No explicit sign at the start of the number. Plus An explicit plus sign at the start of the number."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.TagType.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.TagType.html",
    "title": "Enum TagType",
    "summary": "Enum TagType Types of tags appearing in tokenization data. Namespace: Sdl.Core.Bcm.BcmModel.Tokenization Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public enum TagType Fields Name Description End Represents an ending tag. LockedContent Group of (locked) tag/text content that should be treated as a single placeable. Standalone Represents a standalone tag. Start Represents a starting tag. TextPlaceholder A standalone tag which represents text, not formatting. Undefined Represents an undefined tag type. This is also used for \"dummy tags\" which may be added to a segment in case a tag was deleted from the original segment. Such a situation occurs when the translation engine deletes tags, but the number of tokens must remain constant in the translation proposal as otherwise the token positions will become invalid. UnmatchedEnd For TMX processing only: unmatched end tag (it pos=end) UnmatchedStart For TMX processing only: unmatched start tag (it pos=start)"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.AbbreviationToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.AbbreviationToken.html",
    "title": "Class AbbreviationToken",
    "summary": "Class AbbreviationToken A Token used for abreviations. Inheritance object Token AbbreviationToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class AbbreviationToken : Token, ICloneable<Token> Constructors AbbreviationToken() Initializes a new instance of the AbbreviationToken class. Declaration public AbbreviationToken() AbbreviationToken(string) Initializes a new instance of the AbbreviationToken class. Declaration public AbbreviationToken(string text) Parameters Type Name Description string text The token text Properties Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Implements ICloneable<T> See Also Token"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.AcronymToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.AcronymToken.html",
    "title": "Class AcronymToken",
    "summary": "Class AcronymToken A Token representing acronyms. Inheritance object Token AcronymToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class AcronymToken : Token, ICloneable<Token> Constructors AcronymToken() Initializes a new instance of the AcronymToken class. Declaration public AcronymToken() AcronymToken(string) Initializes a new instance of the AcronymToken class. Declaration public AcronymToken(string text) Parameters Type Name Description string text The text. Properties Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Implements ICloneable<T> See Also Token"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.AlphanumericToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.AlphanumericToken.html",
    "title": "Class AlphanumericToken",
    "summary": "Class AlphanumericToken A Token representing alphanumeric tokens. Inheritance object Token AlphanumericToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class AlphanumericToken : Token, ICloneable<Token> Constructors AlphanumericToken() Initializes a new instance of the AlphanumericToken class. Declaration public AlphanumericToken() AlphanumericToken(string) Initializes a new instance of the AlphanumericToken class. Declaration public AlphanumericToken(string text) Parameters Type Name Description string text The token text Properties Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Implements ICloneable<T> See Also Token"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.CharSequenceToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.CharSequenceToken.html",
    "title": "Class CharSequenceToken",
    "summary": "Class CharSequenceToken A Token representing sequence of characters. Inheritance object Token CharSequenceToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class CharSequenceToken : Token, ICloneable<Token> Remarks This is used in contexts (such as tokenization of some far-east languages) where word boundaries cannot easily be determined. Constructors CharSequenceToken() Initializes a new instance of the CharSequenceToken class. Declaration public CharSequenceToken() CharSequenceToken(string) Initializes a new instance of the CharSequenceToken class. Declaration public CharSequenceToken(string text) Parameters Type Name Description string text The token text Properties Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Implements ICloneable<T> See Also Token"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.DateTimeToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.DateTimeToken.html",
    "title": "Class DateTimeToken",
    "summary": "Class DateTimeToken A Token represent date/time tokens. Inheritance object Token DateTimeToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class DateTimeToken : Token, ICloneable<Token> Constructors DateTimeToken() Initializes a new instance of the DateTimeToken class. Declaration public DateTimeToken() DateTimeToken(string, DateTime, DateTimePatternType) Initializes a new instance with the specified values. Declaration public DateTimeToken(string text, DateTime dateTime, DateTimePatternType type) Parameters Type Name Description string text The text to assign to the token DateTime dateTime The DateTime object to assign to the token's value DateTimePatternType type The type of the date or time token Properties DateTimeType position of segment within the segment Declaration [DataMember(Name = \"dateTimeType\")] public DateTimePatternType DateTimeType { get; set; } Property Value Type Description DateTimePatternType Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Value position of segment within the segment Declaration [DataMember(Name = \"value\")] public DateTime Value { get; set; } Property Value Type Description DateTime Implements ICloneable<T> See Also Token"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.GeneralPunctuationToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.GeneralPunctuationToken.html",
    "title": "Class GeneralPunctuationToken",
    "summary": "Class GeneralPunctuationToken A Token representing general punctuation tokens. Inheritance object Token GeneralPunctuationToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class GeneralPunctuationToken : Token, ICloneable<Token> Constructors GeneralPunctuationToken() Initializes a new instance of the GeneralPunctuationToken class. Declaration public GeneralPunctuationToken() GeneralPunctuationToken(string) Initializes a new instance of the GeneralPunctuationToken class. Declaration public GeneralPunctuationToken(string text) Parameters Type Name Description string text The token text Properties Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Implements ICloneable<T> See Also Token"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.GenericPlaceableToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.GenericPlaceableToken.html",
    "title": "Class GenericPlaceableToken",
    "summary": "Class GenericPlaceableToken Abstract class for different token implementations. Inheritance object Token GenericPlaceableToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class GenericPlaceableToken : Token, ICloneable<Token> Constructors GenericPlaceableToken() Declaration public GenericPlaceableToken() Properties TokenClass Gets the value of the token class which has been used during construction. Declaration [DataMember(Name = \"tokenClass\")] public string TokenClass { get; set; } Property Value Type Description string Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Implements ICloneable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.IPAdressToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.IPAdressToken.html",
    "title": "Class IPAdressToken",
    "summary": "Class IPAdressToken Used for IP address tokens. Inheritance object Token IPAdressToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class IPAdressToken : Token, ICloneable<Token> Constructors IPAdressToken() Initializes a new instance of the IPAdressToken class. Declaration public IPAdressToken() IPAdressToken(string) Initializes a new instance of the IPAdressToken class. Declaration public IPAdressToken(string text) Parameters Type Name Description string text The token text Properties Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Implements ICloneable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.MeasureToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.MeasureToken.html",
    "title": "Class MeasureToken",
    "summary": "Class MeasureToken A Token representing a measurement. Inheritance object Token NumberToken MeasureToken Implements ICloneable<Token> Inherited Members NumberToken.Sign NumberToken.RawSign NumberToken.DecimalSeparator NumberToken.GroupSeparator NumberToken.AlternateGroupSeparator NumberToken.AlternateDecimalSeparator NumberToken.RawFractionalDigits NumberToken.RawDecimalDigits Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class MeasureToken : NumberToken, ICloneable<Token> Remarks A measurement is defined as a combination of a number followed by a unit. Constructors MeasureToken() Initializes a new instance of the MeasureToken class. Declaration public MeasureToken() MeasureToken(string, NumberToken, Unit, string, char) Initializes a new instance with the specified values. This constructor is for internal purposes only and should not be used directly. Declaration public MeasureToken(string text, NumberToken numericPart, Unit unit, string unitString, char unitSeparator) Parameters Type Name Description string text NumberToken numericPart Unit unit string unitString char unitSeparator Properties Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides NumberToken.Type Unit Gets or sets the unit. Declaration [DataMember(Name = \"unit\")] public Unit Unit { get; set; } Property Value Type Description Unit UnitSeparator Gets or sets the unit separator. Declaration [DataMember(Name = \"unitSeparator\")] public char UnitSeparator { get; set; } Property Value Type Description char UnitString Gets or sets the unit string, in case the unit is unknown. Declaration [DataMember(Name = \"unitString\")] public string UnitString { get; set; } Property Value Type Description string Implements ICloneable<T> See Also NumberToken"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.NumberToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.NumberToken.html",
    "title": "Class NumberToken",
    "summary": "Class NumberToken A Token representing a numerical value. Inheritance object Token NumberToken MeasureToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class NumberToken : Token, ICloneable<Token> Constructors NumberToken() Initializes a new instance of the NumberToken class. Declaration public NumberToken() NumberToken(string, NumericSeparator, NumericSeparator, char, char, Sign, string, string, string) Initializes a new instance with the specified values. Declaration public NumberToken(string text, NumericSeparator groupSeparator, NumericSeparator decimalSeparator, char alternateGroupSeparator, char alternateDecimalSeparator, Sign sign, string rawSign, string rawDecimalDigits, string rawFractionalDigits) Parameters Type Name Description string text The text of the token, as it appeared in the input NumericSeparator groupSeparator The type of group separator used NumericSeparator decimalSeparator The type of decimal separator used char alternateGroupSeparator The character of an alternative group separator, if used char alternateDecimalSeparator The character of an alternative decimal separator, if used Sign sign The type of sign used string rawSign The \"raw text\" of the sign string rawDecimalDigits The \"raw decimal digits\", without separators, between 0-9 string rawFractionalDigits The \"raw fractional digits\", without separators, between 0-9 Properties AlternateDecimalSeparator Gets or sets an alternate decimal separator, which is a single char if an alternate separator is used, or the null character if no alternate separator is used. Declaration [DataMember(Name = \"alternateDecimalSeparator\")] public char AlternateDecimalSeparator { get; set; } Property Value Type Description char AlternateGroupSeparator Gets or sets an alternate group separator, which is a single char if an alternate separator is used, or the null character if no alternate separator is used. Declaration [DataMember(Name = \"alternateGroupSeparator\")] public char AlternateGroupSeparator { get; set; } Property Value Type Description char DecimalSeparator Gets or sets the decimal separator Declaration [DataMember(Name = \"decimalSeparator\")] public NumericSeparator DecimalSeparator { get; set; } Property Value Type Description NumericSeparator GroupSeparator Gets or sets the group separator Declaration [DataMember(Name = \"groupSeparator\")] public NumericSeparator GroupSeparator { get; set; } Property Value Type Description NumericSeparator RawDecimalDigits Gets or sets the raw decimal digits, which are a sequence of digits without separators or signs. Declaration [DataMember(Name = \"rawDecimalDigits\")] public string RawDecimalDigits { get; set; } Property Value Type Description string RawFractionalDigits Gets or sets the raw fractional digits, which are a sequence of digits without separators or signs. Declaration [DataMember(Name = \"rawFractionalDigits\")] public string RawFractionalDigits { get; set; } Property Value Type Description string RawSign Gets or sets the \"raw\" sign, i.e. the textual representation of the sign Declaration [DataMember(Name = \"rawSign\")] public string RawSign { get; set; } Property Value Type Description string Sign Gets or sets the sign. Declaration [DataMember(Name = \"sign\")] public Sign Sign { get; set; } Property Value Type Description Sign Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Implements ICloneable<T> See Also Token"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.TagToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.TagToken.html",
    "title": "Class TagToken",
    "summary": "Class TagToken A Token representing a tag element. Inheritance object Token TagToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class TagToken : Token, ICloneable<Token> Constructors TagToken() Initializes a new instance with default values (used for XML serialization only). Declaration public TagToken() TagToken(TagType, string, int, int, string, bool) Initializes a new instance of the Tag class with the specified type and anchor. Declaration public TagToken(TagType type, string tagId, int anchor, int alignmentAnchor, string textEquivalent, bool canHide) Parameters Type Name Description TagType type The tag type. string tagId The tag ID (user-defined) int anchor The tag anchor. int alignmentAnchor An alignment anchor (cross-segment), if available string textEquivalent A text equivalent string (ignored if the tag type is not TextPlaceholder or LockedContent) bool canHide True if the tag represents inline formatting, false otherwise Properties AlignmentAnchor Gets or sets the alignment anchor, which is used to align cross-segment tags. It only needs to be set for the start tag. Declaration [DataMember(Name = \"alignmentAnchor\")] public int? AlignmentAnchor { get; } Property Value Type Description int? Anchor Gets or sets the tag anchor, which is used to bracket two tags (connect start and end tag). The anchor is only relevant for start and end tags and has no cross-segment semantics. Declaration [DataMember(Name = \"anchor\")] public int? Anchor { get; set; } Property Value Type Description int? CanHide Gets or sets the CanHide flag Declaration [DataMember(Name = \"canHide\")] public bool? CanHide { get; set; } Property Value Type Description bool? TagId Gets or sets the tag ID which is a cross-format ID assigned by the filters and which may be used to represent a cross-format formatting class (such as \"bold\"). Declaration [DataMember(Name = \"tagId\")] public string TagId { get; set; } Property Value Type Description string TagType Gets or sets the tag type. Declaration [DataMember(Name = \"tagType\")] public TagType TagType { get; set; } Property Value Type Description TagType TextEquivalent Gets or sets the text equivalent string. This will only be valid for text placeholder tags. Declaration [DataMember(Name = \"textEquivalent\")] public string TextEquivalent { get; set; } Property Value Type Description string Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Methods ToString() ToString() Declaration public override string ToString() Returns Type Description string A string representation of the object, for display purposes. Overrides Token.ToString() Implements ICloneable<T> See Also Token"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.Token.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.Token.html",
    "title": "Class Token",
    "summary": "Class Token Abstract class for different token implementations. Inheritance object Token AbbreviationToken AcronymToken AlphanumericToken CharSequenceToken DateTimeToken GeneralPunctuationToken GenericPlaceableToken IPAdressToken NumberToken TagToken URIToken VariableToken WhiteSpaceToken WordToken Implements ICloneable<Token> Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] [JsonConverter(typeof(TokenCreator))] public abstract class Token : ICloneable<Token> Constructors Token() Initializes a new instance with default values. Declaration protected Token() Token(string) Initializes a new instance with the specified token text. Declaration protected Token(string text) Parameters Type Name Description string text The token text Properties Span Gets or sets the span of text in the Segment representing the Token. Declaration [DataMember(Name = \"span\")] public SegmentRange Span { get; set; } Property Value Type Description SegmentRange The text span. Text Gets or sets the token text. Declaration [DataMember(Name = \"text\")] public string Text { get; set; } Property Value Type Description string The token text. Type Gets the type of Token. Should be overriden with names that uniquely identify the implementations. Declaration [DataMember(Name = \"type\")] protected abstract string Type { get; } Property Value Type Description string The type. Methods Clone() Clones this instance. Declaration public virtual Token Clone() Returns Type Description Token ToString() Converts to string. Declaration public override string ToString() Returns Type Description string A string that represents this instance. Overrides object.ToString() Implements ICloneable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.URIToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.URIToken.html",
    "title": "Class URIToken",
    "summary": "Class URIToken An URI token that is placeable but is not substitutable. Inheritance object Token URIToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class URIToken : Token, ICloneable<Token> Constructors URIToken() Initializes a new instance of the URIToken class. Declaration public URIToken() URIToken(string) Initializes a new instance of the URIToken class. Declaration public URIToken(string text) Parameters Type Name Description string text The token text Properties Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Implements ICloneable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.VariableToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.VariableToken.html",
    "title": "Class VariableToken",
    "summary": "Class VariableToken A Token representing a substitutable variable. Inheritance object Token VariableToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class VariableToken : Token, ICloneable<Token> Constructors VariableToken() Initializes a new instance of the VariableToken class. Declaration public VariableToken() VariableToken(string) Initializes a new instance of the VariableToken class. Declaration public VariableToken(string text) Parameters Type Name Description string text The token text Properties Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Implements ICloneable<T> See Also Token"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.WhiteSpaceToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.WhiteSpaceToken.html",
    "title": "Class WhiteSpaceToken",
    "summary": "Class WhiteSpaceToken A Token representing a a non-empty sequence of whitespace characters. Inheritance object Token WhiteSpaceToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class WhiteSpaceToken : Token, ICloneable<Token> Constructors WhiteSpaceToken() Initializes a new instance of the WhiteSpaceToken class. Declaration public WhiteSpaceToken() WhiteSpaceToken(string) Initializes a new instance of the WhiteSpaceToken class. Declaration public WhiteSpaceToken(string text) Parameters Type Name Description string text The token text Properties Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Implements ICloneable<T> See Also Token"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.WordToken.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.WordToken.html",
    "title": "Class WordToken",
    "summary": "Class WordToken A Token which represents a non-specific word. Inheritance object Token WordToken Implements ICloneable<Token> Inherited Members Token.Clone() Token.ToString() Token.Text Token.Span object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class WordToken : Token, ICloneable<Token> Constructors WordToken() Initializes a new instance with default values Declaration public WordToken() WordToken(string) Initializes a new instance with the specified token text Declaration public WordToken(string text) Parameters Type Name Description string text Properties IsStopword Gets or sets whether this token is a stop word. Declaration [DataMember(Name = \"isStopWord\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public bool IsStopword { get; set; } Property Value Type Description bool Stem An optional stem to assign to this token. Stems are used for TM search and scoring. Declaration [DataMember(Name = \"stem\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public string Stem { get; set; } Property Value Type Description string Type Gets the type of Token. Declaration [DataMember(Name = \"type\")] protected override string Type { get; } Property Value Type Description string The type. Overrides Token.Type Implements ICloneable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Tokens.html",
    "title": "Namespace Sdl.Core.Bcm.BcmModel.Tokenization.Tokens",
    "summary": "Namespace Sdl.Core.Bcm.BcmModel.Tokenization.Tokens Classes AbbreviationToken A Token used for abreviations. AcronymToken A Token representing acronyms. AlphanumericToken A Token representing alphanumeric tokens. CharSequenceToken A Token representing sequence of characters. DateTimeToken A Token represent date/time tokens. GeneralPunctuationToken A Token representing general punctuation tokens. GenericPlaceableToken Abstract class for different token implementations. IPAdressToken Used for IP address tokens. MeasureToken A Token representing a measurement. NumberToken A Token representing a numerical value. TagToken A Token representing a tag element. Token Abstract class for different token implementations. URIToken An URI token that is placeable but is not substitutable. VariableToken A Token representing a substitutable variable. WhiteSpaceToken A Token representing a a non-empty sequence of whitespace characters. WordToken A Token which represents a non-specific word."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Unit.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.Unit.html",
    "title": "Enum Unit",
    "summary": "Enum Unit Enumerates the units supported by Sdl.LanguagePlatform.Core.Tokenization.Unit Namespace: Sdl.Core.Bcm.BcmModel.Tokenization Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public enum Unit Fields Name Description BISacre BISacre BISbuUK BISbuUK BISbuUSDry BISbuUSDry BISflozUK BISflozUK BISflozUS BISflozUS BISft BISft BISft2 BISft2 BISfurlong BISfurlong BISgalUK BISgalUK BISgalUS BISgalUS BISin BISin BISin2 BISin2 BISlb BISlb BISlongHW BISlongHW BISlongTon BISlongTon BISmi BISmi BISmi2 BISmi2 BISoz BISoz BISptUK BISptUK BISptUS BISptUS BISptUSDry BISptUSDry BISqtUK BISqtUK BISshortHW BISshortHW BISshortTon BISshortTon BISstone BISstone BISyd BISyd BISyd2 BISyd2 Currency The unit represents a currency Ma Metric are Mcentigrade Mcentigrade Mcl Metric centiliters Mcm Metric centimeters Mcm2 Metric square centimeters Mcm3 Metric cubic centimeters Mdegree Mdegree Mdl Metric deciliters Mdm Metric decimeters Mfahrenheit Mfahrenheit Mg Metric grams Mha Metric hectare Mkelvin Mkelvin Mkg Metric kilograms Mkm Metric kilometers Mkm2 Metric square kilometers Ml Metric liters Mm Metric meters Mm2 Metric square meters Mm3 Metric cubic meters Mmg Metric milligrams Mml Metric milliliters Mmm Metric millimeters Mmm2 Metric square millimeters Mpercent Mpercent Mt Metric tons NoUnit A sentinel, should not be used Other The unit represents another, general unit for which no cross-system conversion will be available."
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.Tokenization.html",
    "title": "Namespace Sdl.Core.Bcm.BcmModel.Tokenization",
    "summary": "Namespace Sdl.Core.Bcm.BcmModel.Tokenization Classes SegmentPosition Represents a position within a segment. SegmentRange A selection of content inside a Segment. Enums DateTimePatternType DateTime patterns used by Token elements. NumericSeparator The numeric separators type which can occur in a number token. Sign The sign of a number TagType Types of tags appearing in tokenization data. Unit Enumerates the units supported by Sdl.LanguagePlatform.Core.Tokenization.Unit"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.TranslationOrigin.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.TranslationOrigin.html",
    "title": "Class TranslationOrigin",
    "summary": "Class TranslationOrigin Contains information on the origin of translation. Inheritance object ExtensionDataContainer MetadataContainer TranslationOrigin Implements IEquatable<MetadataContainer> ICloneable<TranslationOrigin> IEquatable<TranslationOrigin> Inherited Members MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class TranslationOrigin : MetadataContainer, IEquatable<MetadataContainer>, ICloneable<TranslationOrigin>, IEquatable<TranslationOrigin> Constructors TranslationOrigin() Declaration public TranslationOrigin() TranslationOrigin(string, string, int, bool, bool, TextContextMatchLevel, string, TranslationOrigin) Initializes a new instance of the TranslationOrigin class. Declaration public TranslationOrigin(string originType, string originSystem, int matchPercent, bool isStructureContextMatch, bool isSidContextMatch, TextContextMatchLevel textContextMatchLevel, string originalTranslationHash, TranslationOrigin originBeforeAdaptation) Parameters Type Name Description string originType Type of the origin. string originSystem The origin system. int matchPercent The match percent. bool isStructureContextMatch if set to true the translation is a structure context match. bool isSidContextMatch if set to true the translation is a sID context match. TextContextMatchLevel textContextMatchLevel The text context match level. string originalTranslationHash The original translation hash. TranslationOrigin originBeforeAdaptation The TranslationOrigin before adaptation. Properties ChangeDisplayUsername Gets or sets the created_by_username metadata. Declaration public string ChangeDisplayUsername { get; set; } Property Value Type Description string The created_by_username metadata value. CreatedBy Gets or sets the identifier of the user who created the translation. Declaration [DataMember(Name = \"createdBy\", EmitDefaultValue = false)] public string CreatedBy { get; set; } Property Value Type Description string CreatedOn Gets or sets the date and time when the translation was created. Declaration [DataMember(Name = \"createdOn\", EmitDefaultValue = false)] [JsonConverter(typeof(DateTimeConverter))] public DateTime? CreatedOn { get; set; } Property Value Type Description DateTime? CreationDate Gets or sets the created_on metadata. Made obsolete by the CreatedOn property. Declaration [Obsolete(\"Use the CreatedOn property instead.\")] public string CreationDate { get; set; } Property Value Type Description string The created_on metadata value. CreationDisplayUsername Gets or sets the created_by_username metadata. Declaration public string CreationDisplayUsername { get; set; } Property Value Type Description string The created_by_username metadata value. IsSidContextMatch If true, indicates that the translation originates from a system that takes ID context information into account, and that the ID context matches. Declaration [DataMember(Name = \"isSidContextMatch\", EmitDefaultValue = false)] public bool IsSidContextMatch { get; set; } Property Value Type Description bool true if this instance is sID context match; otherwise, false. IsStructureContextMatch Gets or sets a value indicating whether this instance is structure context match. Declaration [DataMember(Name = \"isStructureContextMatch\", EmitDefaultValue = false)] public bool IsStructureContextMatch { get; set; } Property Value Type Description bool true if this instance is structure context match; otherwise, false. Remarks If true, indicates that the translation originates from a system that takes structural context information into account, and that the structure context matches. LastModifiedDate Gets or sets the modified_on metadata. Made obsolete by the ModifiedOn property. Declaration [Obsolete(\"Use the ModifiedOn property instead.\")] public string LastModifiedDate { get; set; } Property Value Type Description string The modified_on metadata value. LastModifiedUserId Gets or sets the last_modified_by metadata. Made obsolete by the ModifiedBy property. Declaration [Obsolete(\"Use the ModifiedBy property instead.\")] public string LastModifiedUserId { get; set; } Property Value Type Description string The last_modified_by metadata value. LastUsedDate Gets or sets the used_on metadata. Declaration public string LastUsedDate { get; set; } Property Value Type Description string The used_on metadata value. LastUsedUserId Gets or sets the used_by metadata. Declaration public string LastUsedUserId { get; set; } Property Value Type Description string The used_by metadata value. MatchPercent Gets or sets the match percent. Declaration [DataMember(Name = \"matchPercent\")] public int MatchPercent { get; set; } Property Value Type Description int The match value for a translation memory match, or the confidence level for a machine translation. Should be a percentage value from 0 - 100% Remarks When a match gets adapted by interactive translation, the original match value can be read from this property on the OriginBeforeAdaptation properties. ModifiedBy Gets or sets the identifier of the user who modified the translation. Declaration [DataMember(Name = \"modifiedBy\", EmitDefaultValue = false)] public string ModifiedBy { get; set; } Property Value Type Description string ModifiedOn Gets or sets the date and time when the translation was modified. Declaration [DataMember(Name = \"modifiedOn\", EmitDefaultValue = false)] [JsonConverter(typeof(DateTimeConverter))] public DateTime? ModifiedOn { get; set; } Property Value Type Description DateTime? OriginBeforeAdaptation Gets or sets the TranslationOrigin before adaptation. Declaration [DataMember(Name = \"originBeforeAdaptation\", EmitDefaultValue = false)] public TranslationOrigin OriginBeforeAdaptation { get; set; } Property Value Type Description TranslationOrigin The TranslationOrigin before adaptation. Remarks Null or the origin information for the originally adapted target content. OriginSystem Gets or sets the origin system. Declaration [DataMember(Name = \"originSystem\")] public string OriginSystem { get; set; } Property Value Type Description string The originating system name for a segment translation. OriginType Gets or sets the translation origin type. Declaration [DataMember(Name = \"originType\")] public string OriginType { get; set; } Property Value Type Description string The translation origin type. Remarks Seed DefaultTranslationOrigin for default values. OriginalTranslationHash A hash value that identifies the entry in the TM that provided the translation. This is used to update the correct TM entry if a translator provides an updated version of the translation. Declaration [DataMember(Name = \"originalTranslationHash\", EmitDefaultValue = false)] public string OriginalTranslationHash { get; set; } Property Value Type Description string The original translation hash. TextContextMatchLevel Indicates whether the match originates from a source where the textual surrounding content corresponds to the text surrounding this segment. Declaration [DataMember(Name = \"textContextMatchLevel\")] [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public TextContextMatchLevel TextContextMatchLevel { get; set; } Property Value Type Description TextContextMatchLevel The TextContextMatchLevel value. TranslationQualityEstimations Stores a list of TranslationEstimation (persisting TQE data) objects Declaration [DataMember(Name = \"translationQualityEstimations\", EmitDefaultValue = false, IsRequired = false)] public List<TranslationQualityEstimation> TranslationQualityEstimations { get; set; } Property Value Type Description List<TranslationQualityEstimation> UseCount Gets or sets the used_on metadata. Declaration public string UseCount { get; set; } Property Value Type Description string The used_on metadata value. UseDisplayUsername Gets or sets the use_by_username metadata. Declaration public string UseDisplayUsername { get; set; } Property Value Type Description string The use_by_username metadata value. Methods Clone() Clones this instance. Declaration public TranslationOrigin Clone() Returns Type Description TranslationOrigin A deep clone of this instance. Equals(TranslationOrigin) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(TranslationOrigin other) Parameters Type Name Description TranslationOrigin other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides MetadataContainer.Equals(object) GetHashCode() Performs a deep-equals comparison. System.Object.Equals(object) Declaration public override int GetHashCode() Returns Type Description int Overrides MetadataContainer.GetHashCode() Implements IEquatable<T> ICloneable<T> IEquatable<T> See Also MetadataContainer"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.TranslationOriginMetaData.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.TranslationOriginMetaData.html",
    "title": "Class TranslationOriginMetaData",
    "summary": "Class TranslationOriginMetaData Metadata keys used for TranslationOrigin metadata. Inheritance object TranslationOriginMetaData Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public static class TranslationOriginMetaData Fields ChangeDisplayUsername The display name of the user who last modified the translation. Declaration public const string ChangeDisplayUsername = \"modified_by_username\" Field Value Type Description string CreatedBy The user who created the translation. Declaration public const string CreatedBy = \"created_by\" Field Value Type Description string CreationDate The translation creation date. Declaration public const string CreationDate = \"created_on\" Field Value Type Description string CreationDisplayUsername The display name of the user who created the translation. Declaration public const string CreationDisplayUsername = \"created_by_username\" Field Value Type Description string LastModifiedDate The translation modified date. Declaration public const string LastModifiedDate = \"modified_on\" Field Value Type Description string LastModifiedUserId The Id of the last user who updated the translation. Declaration public const string LastModifiedUserId = \"last_modified_by\" Field Value Type Description string LastUsedDate The date when the translation was last applied. Declaration public const string LastUsedDate = \"used_on\" Field Value Type Description string LastUsedUserId The Id of the last user who applied the translation. Declaration public const string LastUsedUserId = \"used_by\" Field Value Type Description string UseCount The translation usage count. Declaration public const string UseCount = \"use_count\" Field Value Type Description string UseDisplayUsername The display name of the user who last applied the translation. Declaration public const string UseDisplayUsername = \"use_by_username\" Field Value Type Description string"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.TranslationQualityEstimation.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.TranslationQualityEstimation.html",
    "title": "Class TranslationQualityEstimation",
    "summary": "Class TranslationQualityEstimation Model for persisting TQE(Translation Quality Estimation) information Inheritance object TranslationQualityEstimation Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax [DataContract] public class TranslationQualityEstimation Constructors TranslationQualityEstimation() Declaration public TranslationQualityEstimation() Properties Description Stores a description which is generated by the system generating the TQE data Declaration [DataMember(Name = \"description\", IsRequired = false)] public string Description { get; set; } Property Value Type Description string EvaluatedAt Stores the UTC date and time when the evaluation took place Declaration [DataMember(Name = \"evaluatedAt\", IsRequired = true)] [JsonConverter(typeof(DateTimeConverter))] public DateTime EvaluatedAt { get; set; } Property Value Type Description DateTime Model Stores the model used for the estimation, - e.g. daVinci, bedrock Declaration [DataMember(Name = \"model\", IsRequired = true)] public string Model { get; set; } Property Value Type Description string Score Stores the score of this estimation (0-100) Declaration [DataMember(Name = \"score\", IsRequired = true)] public int Score { get; set; } Property Value Type Description int System Stores the system which originated this data - e.g. lw-evolve Declaration [DataMember(Name = \"system\", IsRequired = true)] public string System { get; set; } Property Value Type Description string Methods Equals(object) Equals override Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides object.Equals(object) GetHashCode() GetHashCodd override Declaration public override int GetHashCode() Returns Type Description int Overrides object.GetHashCode()"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.UnknownMarkupData.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.UnknownMarkupData.html",
    "title": "Class UnknownMarkupData",
    "summary": "Class UnknownMarkupData A MarkupData which was not recognized during deserialization. Used only to preserve its existing data and should not be used directly in BCM processing. Inheritance object ExtensionDataContainer MetadataContainer MarkupData UnknownMarkupData Implements IEquatable<MetadataContainer> ICloneable<MarkupData> IEquatable<MarkupData> Inherited Members MarkupData.Clone() MarkupData.Equals(MarkupData) MarkupData.Equals(object) MarkupData.GetHashCode() MarkupData.UniqueClone() MarkupData.Id MarkupData.Parent MarkupData.ParentFragment MarkupData.ParentParagraph MarkupData.ParentParagraphUnit MarkupData.Ancestors MarkupData.ParentSegment MarkupData.IsContainer MarkupData.IndexInParent MetadataContainer.GetMetadata(string) MetadataContainer.SetMetadata(string, string) MetadataContainer.Equals(MetadataContainer) MetadataContainer.ShouldSerialize_metadata() MetadataContainer.Metadata ExtensionDataContainer.ExtensionData object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Sdl.Core.Bcm.BcmModel Assembly: Sdl.Core.Bcm.BcmModel.dll Syntax public class UnknownMarkupData : MarkupData, IEquatable<MetadataContainer>, ICloneable<MarkupData>, IEquatable<MarkupData> Constructors UnknownMarkupData() Declaration public UnknownMarkupData() Properties Type Gets or sets the type. Should be implement in derived classes to uniquely identify the type of MarkupData on deserialization. Declaration protected override string Type { get; set; } Property Value Type Description string The type. Overrides MarkupData.Type Methods AcceptVisitor(BcmVisitor) Accepts a visitor of type BcmVisitor. Declaration public override void AcceptVisitor(BcmVisitor visitor) Parameters Type Name Description BcmVisitor visitor The BcmVisitor used to visit this item. Overrides MarkupData.AcceptVisitor(BcmVisitor) Implements IEquatable<T> ICloneable<T> IEquatable<T>"
  },
  "api/bcm/Sdl.Core.Bcm.BcmModel.html": {
    "href": "api/bcm/Sdl.Core.Bcm.BcmModel.html",
    "title": "Namespace Sdl.Core.Bcm.BcmModel",
    "summary": "Namespace Sdl.Core.Bcm.BcmModel Classes DependencyFile Files marked as dependencies for the BCM content. Used for conversion from and to native formats. Document The BCM root element. ExtensionDataContainer A Newtonsoft.Json.JsonExtensionDataAttribute object used as base for elements that need to preserve unrecognized data on deserialization. FeedbackContainer Holds feedback information created during the translation and review process. File BCM data extracted from a native file. FileMetaDataKeys Constants used for File metadata. Fragment Class representing an independent fragment (slice) of a BCM Document. LocalizableSubContent Subcontent of a particular BCM content element. LockedContentContainer Marks content that is locked for editing. MarkupData Abstract entity representing an item that can be included inside a MarkupDataContainer. Examples: TextMarkup, PlaceholderTag, TagPair. MarkupDataContainer A MarkupData element that can hold other MarkupData elements. MetadataContainer An object that contains metadata in the form of a DictionaryEx<TKey, TValue>. Paragraph A MarkupDataContainer containing the source or target content of a ParagraphUnit. ParagraphUnit The main element of translatable content. Contains a source and target Paragraph element. ParagraphUnitMetadataKeys Constants with ParagraphUnit related metadata keys. PlaceholderTag A tag with no translatable content. RevisionContainer Marks revisions to the translated content. Segment Basic unit of translatable content. SegmentMetaDataKeys Constants for Segment metadata. SegmentPair Class grouping together the source and equivalent target Segment. StructureTag A tag that is used for document structure only and has no translatable content. TagPair A tag composed of a start and and end tag. Can contain other MarkupData elements. TagPairMetaDataKeys Constants used a keys for TagPair metadata. TextMarkup A MarkupData containing plain text. TranslationOrigin Contains information on the origin of translation. TranslationOriginMetaData Metadata keys used for TranslationOrigin metadata. TranslationQualityEstimation Model for persisting TQE(Translation Quality Estimation) information UnknownMarkupData A MarkupData which was not recognized during deserialization. Used only to preserve its existing data and should not be used directly in BCM processing. Interfaces ISkeletonItemReference<T> Marks a class as having its definition in the FileSkeleton. Enums ConfirmationLevel Different stages of translation and translation approval for a Segment. DependencyFileUsage Defines the purpose of a DependencyFile. FeedbackType Types of feedback changes created during the translation/review process. RevisionType Types of RevisionContainer. SegmentationHint Information on how specific tags should be segmented. TextContextMatchLevel Used with textual context matches to indicate the level of matching."
  },
  "articles/BCM/BCM.NET_client_API.html": {
    "href": "articles/BCM/BCM.NET_client_API.html",
    "title": "Welcome to the BCM .NET client API documentation",
    "summary": "Welcome to the BCM .NET client API documentation BCM .NET Client API Samples Samples documenting some usages of the BCM .NET Client. Knowledge Base DateTime serialization The official format for DateTime serialization is yyyy-MM-dd'T'HH:mm:ss.fff'Z'. The BCM supports both this format and the default .NET DateTime serialization format MM/dd/yyyy HH:mm:ss Unrecognized Token deserialization Unrecognized Token objects in the serialized BCM are deserialized into a Token of type Word. E.g.: a new type of Token is introduced in the BCM, but an older client, who doesn't recognized this new type of Token, tries to deserialize it. Unrecognized MarkupData deserialization Unrecognized MarkupData objects in the serialized BCM are deserialized into a MarkupData of type UnknownMarkupData. This is to preserve the data of newly introduced MarkupData objects when deserializing BCM using older clients. Elements of type UnknownMarkupData should be ignored when manipulating BCM in memory."
  },
  "articles/BCM/Samples.html": {
    "href": "articles/BCM/Samples.html",
    "title": "BCM .NET Client API Samples",
    "summary": "BCM .NET Client API Samples Operations with comments Get all the comments in a BCM Document Document document; // a BCM Document deserialized from JSON IEnumerable<SegmentPair> allSegmentPairs = document.Files.Select(file => file.ParagraphUnits).SelectMany(p => p.AllSegmentPairs); List<CommentContainer> sourceComments = allSegmentPairs.Select(segmentPair => segmentPair.Source) .SelectMany(segment => segment.AllSubItems.OfType<CommentContainer>()) .ToList(); List<CommentContainer> targetComments = allSegmentPairs.Select(sp => sp.Target) .SelectMany(segment => segment.AllSubItems.OfType<CommentContainer>()) .ToList(); foreach (var comment in sourceComments) { Console.WriteLine($\"Source comment in segment {comment.ParentSegment.SegmentNumber} with text {comment.Definition.Text}\"); } foreach (var comment in targetComments) { Console.WriteLine($\"Target comment in segment {comment.ParentSegment.SegmentNumber} with text {comment.Definition.Text}\"); } Add a comment over a text element Document document; // a BCM Document deserialized from JSON var definition = new CommentDefinition { Text = \"new comment\", CommentSeverity = CommentSeverity.Medium, Author = \"author\", Date = DateTime.Now }; var comment = new CommentContainer { CommentDefinitionId = definition.Id }; // Find a text element on which to add a Comment var text = document.Files.First().ParagraphUnits.SelectMany(x => x.Target.AllSubItems.OfType<TextMarkup>()).First(); // Remove the Text from its current parent var parentElement = text.Parent; var indexInParent = text.IndexInParent; parentElement.Remove(text); // Add the Text to the newly created Comment element comment.Add(text); // Insert the new Comment element to replace the Text, in the same position parentElement.Insert(indexInParent, comment); Remove a comment Document document; // a BCM Document deserialized from JSON var comment = document.Files.First().ParagraphUnits.SelectMany(x => x.Target.AllSubItems.OfType<CommentContainer>()).First(); // Remove it from the FileSkeleton, where the Comment data is stored document.Files.First().Skeleton.CommentDefinitions.Remove(comment.Definition); // Remove the Comment from its parent element comment.Parent.Remove(comment); BCM Visitor This sample gathers the translatable content from a BCM documents and creates a HTML file with the content. HtmlOutputVisitor using Sdl.Core.Bcm.BcmModel; using Sdl.Core.Bcm.BcmModel.Annotations; using Sdl.Core.Bcm.BcmModel.Common; using System.Text; namespace Sdl.Core.Bcm.API.Samples.Visitor { class HtmlOutputVisitor : BcmVisitor { // Gathers HTML content from the BCM content. private readonly StringBuilder _result = new StringBuilder(); /// <summary> /// Creates a new instance of <see cref=\"HtmlOutputVisitor\"/> and gathers content as HTML from <paramref name=\"markupData\"/> and all its descendant elements. /// </summary> /// <param name=\"markupData\">The <see cref=\"MarkupData\"/> element from which to extract HTML content.</param> /// <returns></returns> public static string Collect(MarkupData markupData) { var collector = new HtmlOutputVisitor(); markupData.AcceptVisitor(collector); return collector.Result; } /// <summary> /// After <see cref=\"Collect(MarkupData)\"/> is called, this will contain the HTML output text. /// </summary> /// <value> /// The result. /// </value> public string Result => _result.ToString(); /// <summary> /// Visits all the descendant elements of <paramref name=\"container\"/>. /// </summary> /// <param name=\"container\">The container.</param> public void VisitChildren(MarkupDataContainer container) { foreach (var markupData in container.Children) { markupData.AcceptVisitor(this); } } /// <summary> /// Visits the descendants of a Comment element. /// </summary> /// <param name=\"commentContainer\"></param> public override void VisitCommentContainer(CommentContainer commentContainer) { VisitChildren(commentContainer); } /// <summary> /// Visits the descendants of a Feedback element. /// </summary> /// <param name=\"feedbackContainer\"></param> public override void VisitFeedbackContainer(FeedbackContainer feedbackContainer) { VisitChildren(feedbackContainer); } /// <summary> /// Visits the descendants of a Locked Content element. /// </summary> /// <param name=\"lockedContentContainer\"></param> public override void VisitLockedContentContainer(LockedContentContainer lockedContentContainer) { VisitChildren(lockedContentContainer); } /// <summary> /// Visits the target <see cref=\"Paragraph\"/> and wraps its content inside a DIV tag. /// </summary> /// <param name=\"paragraph\"></param> public override void VisitParagraph(Paragraph paragraph) { _result.Append($\"<div type=\\\"paragraph\\\">\"); VisitChildren(paragraph); _result.Append($\"</div>\"); } /// <summary> /// Visits a <see cref=\"PlaceholderTag\"/> non-translatable element and appends its content as a VAR tag. /// </summary> /// <param name=\"tag\"></param> public override void VisitPlaceholderTag(PlaceholderTag tag) { _result.Append($\"<var id=\\\"{tag.Id}\\\">{tag.Definition.DisplayText}</var>\"); } public override void VisitRevisionContainer(RevisionContainer revisionContainer) { VisitChildren(revisionContainer); } /// <summary> /// Visits a <see cref=\"Segment\"/> translatable element and appends its content as a DIV tag. /// </summary> /// <param name=\"segment\"></param> public override void VisitSegment(Segment segment) { _result.Append($\"<div type=\\\"segment\\\" id=\\\"{segment.Id}\\\">\"); VisitChildren(segment); _result.Append($\"</div>\"); } /// <summary> /// Structure elements are non-translatable elements which are ignored during the translation process. /// </summary> /// <param name=\"structureTag\">The structure tag.</param> public override void VisitStructure(StructureTag structureTag) { } /// <summary> /// Visits a <see cref=\"TagPair\"/> element and appends its content as a SPAN tag. /// Tag pairs are non-translatable elements which can contain translatable content. /// E.g.: Bold formatting (<b>text</b>). The start and end Bold tags form the tag pair and the text is a child element. /// </summary> /// <param name=\"tagPair\"></param> public override void VisitTagPair(TagPair tagPair) { _result.Append($\"<span id=\\\"{tagPair.Id}\\\">\"); VisitChildren(tagPair); _result.Append(\"</span>\"); } /// <summary> /// Visits the descendants of a Terminology Annotation element. /// </summary> /// <param name=\"terminologyAnnotation\"></param> public override void VisitTerminologyContainer(TerminologyAnnotationContainer terminologyAnnotation) { VisitChildren(terminologyAnnotation); } /// <summary> /// Visits a <see cref=\"TextMarkup\"/> element and appends its content as plain text. /// These are translatable text elements. /// </summary> /// <param name=\"text\"></param> public override void VisitText(TextMarkup text) { _result.Append(text.Text); } } } Usage Document document; // a BCM Document deserialized from JSON var visitor = new HtmlOutputVisitor(); // Surround content with an <html> tag. var result = new StringBuilder(\"<html>\"); // Extract content from each BCM File. // A File represents the content extracted from a native file. A BCM Document can have content extracted from multiple files. document.Files.ForEach(file => { // Get all the target content in a File var targetSegments = file.ParagraphUnits.Select(punit => punit.Target); foreach (var targetSegment in targetSegments) { // Visit each target Segment and append its content as HTML result.Append(HtmlOutputVisitor.Collect(targetSegment)); } }); result.Append(\"</html>\");"
  },
  "articles/Extensibility/api/Extensibility-API.v1.html": {
    "href": "articles/Extensibility/api/Extensibility-API.v1.html",
    "title": "Extensibility API Documentation",
    "summary": " View Documentation Fullscreen"
  },
  "articles/Extensibility/docs/Whats-New.html": {
    "href": "articles/Extensibility/docs/Whats-New.html",
    "title": "What's New",
    "summary": "What's New July 2025 We've expanded support for custom tabs to additional locations. You can now use them in the following views: tasks list orders list projects list reports list April 2025 To facilitate the management of large translation requests, batching support has been added for MT provider apps. This update includes the introduction of a new parameter, extensions.configuration.segmentBatchSize, which can be added to your descriptor, along with a new error response featuring status code 413 on the translation endpoint. A new option has been introduced on the app registration page, allowing users to designate their app for development purposes by selecting a checkbox. December 2024 We have officially rebranded from RWS Language Cloud API to Trados Cloud Platform API. All references to our previous brand name will now reflect our new identity, Trados. November 2024 This release introduces support for building apps that work across multiple regions. Existing apps that are already developed and in use will continue to function but will be restricted to the EU region until they are updated. To help you make the required changes for multi-region support, we've provided a new guide, which you can access here. Updated blueprints and sample projects are also available to get you started. October 2024 With this release we deliver a new extension point designed to allow developers to extend and customize the UI elements of our platform. This extension point is being released as BETA. For more details see this page. We unified the Preview documentation pages into a single comprehensive page. We have introduced a new version, known as V2, of our Preview APIs. We extended the information available under Verification Provider page. We have introduced a new version, known as V2, of our Verification APIs. You can now add comments to Submit Task Outcome for the automatic task extensions. June 2024 With this release, we have migrated from the Add-Ons concept to Apps. This significant first step sets the stage for expanding this concept to multiple areas that facilitate integrations. Registered Add-Ons are backward compatible with the new Apps and can be used as is. A major improvement is that an App can now declare the list of webhooks it needs in the descriptor and listen for webhook notifications. The migration guide from an Add-On to an App is available here. October 2023 We added support for dropdown lists to the app configuration. You can now define a set of values in the descriptor's configurations section as an array of strings via the options field. The user will see these values in a dropdown menu in the edit configuration panel. August 2023 With this release we introduced a folder identifier where the translation engines will be added. This can be used to filter the engines by folder. We also added recommendations on best practices for a secure application development. We made additional smaller improvements and corrections to our documentation. April 2023 We added details for the engineId, projectId, sourceFileId and targetFileId parameters of the Translate endpoint. We updated the Registering the app page. February 2023 We introduced requirements that become mandatory for all future apps, namely: acceptance of Terms & Conditions and the Privacy Policy, along with the provisioning of the app's release notes, documentation link and the developer's contact details, starting with descriptor version 1.3. We published newer blueprints for both Java and .NET. We made available headers for developers to implement custom functionality based on the current version of the installed apps: appVersion, extensionPointVersion and extensionId. Added projectId, sourceFileId and targetFileId on the translate request. January 2023 We published new pages with our recommendations for implementing Dynamic Preview. December 2022 We made available app samples for both .NET and Java in GitHub, to allow integrators to get familiar with our framework extension possibilities. We published a new page with Technical Requirements And Best Practices."
  },
  "articles/Extensibility/docs/appManagement/Approvals.html": {
    "href": "articles/Extensibility/docs/appManagement/Approvals.html",
    "title": "Approvals and Support Communication",
    "summary": "Approvals and Support Communication Approval Process All apps have to go through the Approval Process in order to achieve certain results. The Approval Process is our way of validating that your apps comply with the RWS Trados policies. We have a dedicated RWS Support team responsible for the apps validations. The support team has full rights over the registered apps. After having registered your app in Trados, you will gain access to the comments panel within the app's details page. Here you can leave comments or questions for our RWS Support team. The replies received from the Support team members will be displayed in the same panel. Note This is not a live chat, and you should refresh to check for replies. However, you don't need to keep an eye on it always, as we have email notifications in place for both roles: the developer and the support team member. The comments panel is also used to track the approval requests. These requests can only be triggered by the app's developer in one of the following scenarios: Publish the app. See more details here. Publish a new version with major changes. Find more details here. Unpublish the app when installed instances exist publicly. Find more details here. Opening a request triggers the following: The app will be marked with the Pending approval status. The comments log will be updated with the requested change (Publish/Update/Unpublish) along with the associated comment. The support team will be notified to begin the review of your request. During the review phase, our support team will install and test the app. They can also ask for changes via the comments panel. For instance, your app might not have a suitable name or description before going public so they might advise you to change it. After the support team is happy with your request, most likely they are going to approve it. However, they can also reject the request. As a developer, you can cancel the request at any time. The Approval Process ends with one of the following: The request is approved or rejected by the RWS Support team. The request is canceled by the developer. Note During the Approval Process you can still use your app as usual. App Suspended The support team can also suspend an app if they notice a weird behavior. An example would be the case when your app generates a large amount of errors. Suspending an app will result in: Withdrawal from the RWS AppStore , if it was published. Preventing the public consumers from using the app anymore. The developer and support users can still install and use it in order to debug the issues. While the app is suspended, the developer can communicate with the support team in order to sort out the issues. When the problem is fixed, the app is going to be unsuspended by the support team and it will be again publicly available to consumers."
  },
  "articles/Extensibility/docs/appManagement/Foreword.html": {
    "href": "articles/Extensibility/docs/appManagement/Foreword.html",
    "title": "Foreword",
    "summary": "Foreword This section is about managing apps in RWS Trados and it is dedicated to developers. Most of the features presented in these guides are subscription-bound, meaning that, depending on your account subscription, you may or may not benefit from them. The management of the apps is only available to the account administrators. Terms used throughout these guides include: Developer (tenant) - the tenant from which the app was registered. Consumers - the tenants where the app was installed. RWS Support - an RWS Trados internal support team dedicated to helping out with the apps management processes."
  },
  "articles/Extensibility/docs/appManagement/Installing.html": {
    "href": "articles/Extensibility/docs/appManagement/Installing.html",
    "title": "Installing the App",
    "summary": "Installing the App After the app is successfully registered, you can proceed to install it. The installation is tenant-based, which means that all users in the tenant will be able to use the app. To install the app you need to: Find your app in the My Apps tab and select the Install button. When prompted with a form containing placeholders for the account settings details, remember that these are the configuration settings exposed through the descriptor. All mandatory fields will be marked with '*'. Pay attention if the app advertises any scopes, you will be notified by the installation form. Fill in the fields and select Complete. If the app supports validation of settings, it will be automatically performed at installation time via the validation endpoint. Note The configuration settings can be modified anytime by clicking the Edit App Configuration button."
  },
  "articles/Extensibility/docs/appManagement/Publishing.html": {
    "href": "articles/Extensibility/docs/appManagement/Publishing.html",
    "title": "Publishing the App",
    "summary": "Publishing the App The publish operation makes your app publicly available in the RWS AppStore, allowing other tenants to install and use it. After registering, it is recommended that you install and test your app before publishing it to the store. To publish your app you need to: Test that it works as expected. Select your app from the My Apps tab and click the Publish button. A comment box appears, this is where you can leave a message for the RWS support team (not mandatory). Clicking Publish again will trigger the Approval Process. The app will get in a pending state until someone from the support team approves or rejects the publish request. It shouldn't take long to get a response, as the support team is automatically notified when there are new requests. After the support team approves your request, the app becomes publicly available in the RWS AppStore. Note Publishing a private app will always publish its latest version."
  },
  "articles/Extensibility/docs/appManagement/Registering.html": {
    "href": "articles/Extensibility/docs/appManagement/Registering.html",
    "title": "Registering the App",
    "summary": "Registering the App Registration is the first step in integrating your app into the Trados platform. To register a new app, you need to: After you log in, navigate to the RWS AppStore from the user icon menu. Go to My Apps tab, select New App and provide the following details: the Development Name and Development Description, which will only be visible to the developer tenant (do not confuse them with the name and the description of the app descriptor) the App Descriptor URL is the app's descriptor address. This must be a secure URL. the Development App checkbox represents whether your app is intended for development and testing purposes. Development apps cannot be published. After filling in these fields, finish the registration by clicking the Register button. Common issues that may occur during registration include: Issue Fix suggestion Invalid Descriptor URL Make sure the provided URL is formed correctly and it points to your descriptor endpoint. Incorrect BaseUrl If you are using one of our blueprints, check the blueprint guides (.NET or Java) on how to set up the BaseUrl field. Already registered This would normally occur if you already registered your app. If so, you can unregister the old version and perform the registration once again. Descriptor does not comply with the contract Make sure the required fields are returned and the allowed values correspond to the ones from the contract."
  },
  "articles/Extensibility/docs/appManagement/Retiring.html": {
    "href": "articles/Extensibility/docs/appManagement/Retiring.html",
    "title": "Retiring the App",
    "summary": "Retiring the App Before retiring an app, you must first go through the following steps: Unpublish the app Unregister the app Unpublish the App First, if your app is published, you will need to withdraw it from the RWS AppStore. To unpublish the app you need to: Select your app from the My Apps tab and click the Unpublish button. A comment box will appear, where you can leave a message for the RWS Support team (optional). You are also warned that unpublishing the app will cause all the public consumers to lose their installed instances (except for the developer's instance and the shared ones). If you choose to continue, the app will either: Enter the Approval Process, because there were public installations found. In this case, all the consumers will be notified and advised to uninstall the app. Usually, there is a grace period of 30 days. When the grace period ends, if there are still any active instances, they will be automatically removed when the support team approves the request. Become private instantly, because there were no public installations found. Unregister the App After the app becomes private, the only active instances left should be the developer's one and the shared ones (if the app had been previously shared). You can either uninstall them manually or unregister the app directly. The second option will automatically uninstall the instances left, before removing the app. Note An app can only be deleted when there are no other installed instances. To unregister the app, you need to: Select your app from the My Apps tab and click the Delete button. You will be asked if you want to automatically uninstall the shared instances. If you choose to do so, Trados will attempt to remove the remaining instances (if any are found) and eventually delete the app definitively. This is done asynchronously, so you will need to refresh the page to see the changes. If the unregister process fails due to app communication errors, the app will be marked with the Delete failed status and you will have the possibility to force the deletion. The Force Delete button will tell Trados to ignore the communication errors and proceed with the app removal. Force deleting example"
  },
  "articles/Extensibility/docs/appManagement/Sharing.html": {
    "href": "articles/Extensibility/docs/appManagement/Sharing.html",
    "title": "Sharing the App",
    "summary": "Sharing the App By default, a newly registered app is private, meaning that only the developer tenant has access to it. However, you can share your app with other tenants even if it hasn't been published yet. A private version of a public app can also be shared prior to its publication. Please note that once the app is published, the Share button will no longer be visible. To share the app you need to: Test that it works as expected. Select your app from the My Apps tab and click the Share button. You will receive a public link which you can share with other tenants. The link expires after 7 days. The link's recipient will then be able to access and install the app. Note The number of sharing links and shared installed instances is restricted by the sharing benefit quota from your account subscription."
  },
  "articles/Extensibility/docs/appManagement/Updating.html": {
    "href": "articles/Extensibility/docs/appManagement/Updating.html",
    "title": "Updating the App",
    "summary": "Updating the App There might be times when you need to make changes to your app. Whether you want to fix bugs, correct flaws, or add new functionality, the changes should eventually reach your registered app instance. That's why RWS Trados supports app versioning. To update the app you need to: Increment the version field in the app's descriptor, as Trados relies on it to detect the newer versions. Wait for Trados to detect the new version. It could take up to 2 minutes to detect it. You should also receive an email notification informing you that there's a new app version available. Check the new version on the app details page. If you don't see it, please contact our support team. At this point you should be able to install or update to the latest version. Publishing a new version For an app that is already published, you may also choose to publish the new version. To publish an update you need to: Test that your new version works as expected. Select your app from the My Apps tab and click the Publish update button. This could result in one of the following: The app will enter the Approval Process, if the new version's descriptor contains major changes. The following changes are considered major: BaseURL Scopes Standard endpoints Extensions Configuration settings The app's new version will be instantly published if none of the above fields are affected by the changes. Finally, the app consumers will be notified that there is a new version available to which they can upgrade."
  },
  "articles/Extensibility/docs/appManagement/Validating.html": {
    "href": "articles/Extensibility/docs/appManagement/Validating.html",
    "title": "Validating Account Settings",
    "summary": "Validating Account Settings As we have already seen, most apps require some configuration settings in order to serve their purpose. For example, the machine translation apps such as Google and DeepL may need some credentials to communicate with the 3rd party MT provider. Validations There are a couple of places where the settings are validated automatically or where you can perform the validation yourself. Installation The first validation is done when installing the app. If the settings are correct, the installation will complete without any warning messages. Otherwise, if you provide incorrect settings, a warning message will notify you and the invalid field(s) will be highlighted in red (if the app provides such granular information). The installation completes eventually, but your instance will be marked as Not configured and you won't be able to use it. Edit Configuration Once the app has been installed you can edit the settings at any time from the Edit App configuration window. Clicking the Save button will also trigger the validation of the newer settings. Another option is to perform the validation on demand by clicking the Validate saved configuration button. As the name suggests, the validation is done against the saved settings. This means that you would first have to save the settings before clicking the validation button. Automatic Validation Some settings, especially credentials may expire after a while. The purpose of the automatic validation is to detect the instances with expired settings and mark them accordingly. A background job runs daily and checks all the installed instances. When a validation fails, that particular instance will be marked as Not configured, making it unusable anymore. Therefore, if your app has suddenly stopped working, it might be due to expired settings. To fix this state, you can provide new settings by using the Edit App configuration functionality."
  },
  "articles/Extensibility/docs/consumer/Automatic-Task-App-consumer-guide.html": {
    "href": "articles/Extensibility/docs/consumer/Automatic-Task-App-consumer-guide.html",
    "title": "Automatic Task",
    "summary": "Automatic Task Automatic Task apps offer the possibility to add custom functionality within a project's workflow. Examples of automatic tasks: send notifications about the project update project details copy the project files to a shared location Installing the App To benefit from the app's functionality, you first have to install it on your account. You can install an app by following these steps: Navigate to RWS AppStore where you can find all the public apps. Select the desired app. Read the app's documentation by accessing the documentation link. Some Automatic Task apps might also require access to your account resources. The installation window will advertise the requested permissions. Click the Install button and fill in the configuration settings. Only the settings marked with '*' are required. After you have filled in the settings and acknowledged the requested access click Complete. Some apps also support validation of the configured settings. The first validation is automatically performed at installation time. If the provided settings are invalid, you will be prompted with an error message letting you know that the settings are incorrect. Note The configuration settings can be modified at any time by clicking the Edit App Configuration button. Using the Automatic Task App Once you have the app installed on your account, anyone from the account will be able to use it. However, only the account admins have the rights to manage the apps. An app of this type could expose one or more automated tasks that are available to integrate within your workflow templates. Creating a New Workflow Template To use the app's automatic task(s) within your projects, first, you will need a Workflow Template with the task(s) provided by the app. To create a template, follow these steps: Navigate to Resources -> Workflows -> Workflow Templates and click New Workflow Template. Fill in the required fields and start building your custom workflow template. Add the app's automatic task. Configure the task. Click Save configurations and complete your template. When finished, click Save & Activate. Note The above illustrations are based on a template draft. You may need to create the new template from scratch. Creating a New Workflow The workflow template created at the previous step must be assigned to a Workflow. To create a new one, follow these steps: Navigate to Resources > Workflows > Workflows and click New Workflow. Fill in the required fields. Select your newly created template from the dropdown list. Check the tasks in the workflow and configure them. Click Create. Using the App's Automatic Task within a Project To create a Project with the new resources, you can either have them in a Project Template or select them at the project creation time. In this example we will go with the first option: After creating the project, you can track the progress in the Task History tab. Here you can check the app's task status. Depending on the complexity of the task it may take some time to finish. Note The app task illustrated above is just a mockup task that does not have a real purpose."
  },
  "articles/Extensibility/docs/consumer/Dynamic-Preview-guide.html": {
    "href": "articles/Extensibility/docs/consumer/Dynamic-Preview-guide.html",
    "title": "Dynamic Preview",
    "summary": "Dynamic Preview Dynamic Preview apps offer the ability to render previews dynamically based on selections the user makes in the preview page. Installing the App To benefit from the app's functionality first you have to install it on your account. You can install an app by following these steps: Navigate to RWS AppStore where you can find all the public apps. Select the desired app. Read the app's documentation by accessing the documentation link. Click the Install button. When finished, select Complete. Setting up the Preview Under your Trados Enterprise account, set up a new FileType. Select a file type which is supported by your app. In this case, we chose the XML 2: Any XML FileType Follow the steps shown below to add the Dynamic Preview Type to your FileType Preview Settings. Create a project and add your file which you will be previewing to it. Open the Online Editor and select the Preview Type as shown below: In the rendered preview, change the dynamic page which is loaded as shown in the example below. Note: The mechanism for changing the content dynamically will depend on the app implementation and preview rendering."
  },
  "articles/Extensibility/docs/consumer/MT-App-consumer-guide.html": {
    "href": "articles/Extensibility/docs/consumer/MT-App-consumer-guide.html",
    "title": "Machine Translation",
    "summary": "Machine Translation Machine Translation apps offer the possibility to use external machine translation providers within the Trados platform. Installing the App To benefit from the app's functionality first you have to install it on your account. You can install an app by following these steps: Navigate to RWS AppStore where you can find all the public apps. Select the desired app. Read the app's documentation by accessing the documentation link. Click the Install button and fill in the configuration settings. Only the settings marked with '*' are required. When you are done, click Complete. Some apps also support validation of the configured settings. The first validation is automatically performed at installation time. If the provided settings are invalid, you will be prompted with an error message letting you know that the settings are incorrect. Note The configuration settings can be modified at any time by clicking the Edit App Configuration button. Using the Machine Translation App Once you have the app installed on your account, anyone from the account will be able to use it. However, only the account administrators have the permissions to manage the apps. Creating a new Translation Engine To use the MT app within your projects, you will need a Translation Engine with the engines provided by the app. To create one follow these steps: Navigate to Resources -> expand Linguistic Resources -> Translation Engines and click New Translation Engine. Fill in the required fields. Select the desired language pair(s). Under the Machine Translation section click Add Machine Translation Model. The app should provide the supported models for the requested language pair(s). Select the models and click Create. Creating a new Workflow You will need a workflow that contains the Machine Translation step and has at least one of your Translation Engine's language pairs. To create a new one follow these steps: Navigate to Resources > Workflows > Workflows and click New Workflow. Fill in the required fields. Select the language pair(s). Select a template with Machine Translation steps (for example, one could be Simple Translation). Check the tasks in the workflow and configure them. Click Create. Translating with the MT App To create a Project with the new resources you can either have them in a Project Template or select them at the project creation time. In this example we'll go with the first option: Note The project language pair also has to match the ones from the engine and the workflow. Once the project reaches the Translation step, you can open it in Online Editor and check the translated segments from the MT app. You also have the possibility to search for Lookups in order to receive alternative translations. Note The translations illustrated above are just some demonstrative mock-ups."
  },
  "articles/Extensibility/docs/development/Add-On-To-App-Migration.html": {
    "href": "articles/Extensibility/docs/development/Add-On-To-App-Migration.html",
    "title": "Add-on to App Migration",
    "summary": "Add-on to App Migration If you previously have developed an add-on, you have to migrate it to the app concept. Add-ons have in the descriptor the property descriptorVersion with value 1.3 or less. Apps start with descriptorVersion 1.4. Changes The most important changes: Lifecycle events have been renamed for consistency, and the payload have been changed. But the blueprint code covers these and following it should get you started really fast. Auth0 clientId and clientSecret have been moved from install (tenant) scope to app scope. Where before you had a separate set of Auth0 credentials for each install, now you get one set when your app is registered in Trados. That means that you can get the token from Auth0 once (for the period of its validity), and make Trados Cloud Platform API requests for any tenant that has the app installed, by providing the tenant in the X-LC-TenantId header. We've introduced a new Lifecycle event UPDATED which will be used to update the app on various changes. Currently it can update the clientId and clientSecret. That is useful if credentials need to be cycled. The Migration Blueprints cover how to update the add-on to support all these new features. Management changes: Publishing doesn't require you to install the current app version. The current available app version will be published when you publish. When registering, you'll have an extra field where you select people from your account that should receive emails regarding managing your app. Upgrade Process The process of migration should look like: Depending on if your add-on is Java or .NET, go to the appropriate blueprint page: Java Migration Blueprint or .NET Migration Blueprint. This page will contain details on what changes must be done. Perform the changes in your code and deploy it to a test instance Test the changes by having an add-on installed on your account before the app deploy. After the deploy update your install to the new version and confirm it's functioning as previously. Deploy your \"Production\" instance If it was published to App Store, publish the new version Because you might have installs with the old version, you'll have to maintain the code to handle requests for version 1.3 and 1.4 - for example the endpoint paths that were specified in the old descriptor should be still valid."
  },
  "articles/Extensibility/docs/development/App-Descriptor.html": {
    "href": "articles/Extensibility/docs/development/App-Descriptor.html",
    "title": "App Descriptor",
    "summary": "App Descriptor A descriptor defines what the app does. The very first interaction between Trados and an app is requesting the descriptor. The app developer must accurately fill in all the details within the descriptor, specifying the app's functionalities, and then register the app by submitting a URL linking to the descriptor Basic Information The descriptor model defines attributes that provide basic information like name, description, releaseNotes. The model provides documentation for all the fields. Version The version field is used by Trados to detect newer versions of the app's descriptor. You should increase the version every time you make a change in the descriptor, otherwise, your changes won't reach the registered instance from Trados. The version is periodically checked by Trados by performing GET descriptor requests. Base URL baseUrl defines the base for any endpoint defined in the descriptor. All calls from Trados will be made by concatenating baseUrl and the path defined for an endpoint in the descriptor. For example, if we have in the descriptor: { \"baseUrl\": \"https://foo.com\", \"standardEndpoints\": { \"health\": \"/health\" } } Trados will make scheduled GET requests to https://foo.com/health to check the health. Changing Base URL For various reasons you might want to change the host of your App and that can be done from Trados management UI. When updating the host, you also have to update baseUrl to match the new host. You must still support old host as all previous installs will be calling on the baseUrl at the installed version. In order to be able to decomission the old host, you must make sure all consumers updated their installs to latest version. Warning Because request authentication is based on Audience matching 'baseUrl', you must ensure that your authentication code can accept both old and new baseUrl. See Request Authentication. Standard Endpoints An app must implement a set of standard endpoints that are defined in the descriptor schema under standardEndpoints. Not all endpoints are required, as you can see in the descriptor schema. All endpoint paths need to start with the leading character / and are relative to baseUrl. Standard endpoints are defined under the Standard tag. The actual path should be replaced with the one you defined in the descriptor. The expected Request and Responses are defined and should be used as reference. Lifecycle Endpoint Additionally, in the standardEnpoints section we can find the lifecycle endpoint. This endpoint needs to handle different events sent by Trados (similar to webhooks). For instance, when the app is being installed on a certain account, Trados will send an INSTALLED event along with some data for that account. The app should react and save the received data. appLifecycle - is used for all types of events: REGISTERED, UNREGISTERED, INSTALLED, and UNINSTALLED. See the contract here. Note If your app is built from our blueprints, you shouldn't have to change anything, as these endpoints work out of the box. Extensions The list of provided extensions is described under extensions. An app can provide none, one, or more extensions. Any extension will have the generic set of properties: extensionPointId that specifies what extension point it extends. Can be only a value specified in the descriptor contract (ex: lc.mtprovider). extensionPointVersion defines the version of the extension point it extends. The allowed value is defined in the descriptor contract (ex: 1.0). name is defined by the developer, to provide a friendly name for the extension. This is useful when the app provides multiple extensions. description will have a summary describing the extension. configuration defines the extension and the structure depends on the type of the extension that is implemented. { ... \"extensions\": [ { \"extensionPointId\": \"<extension-point-id>\", \"extensionPointVersion\": \"1.0\", \"id\": \"myAwesomeExtension\", \"name\": \"My Awesome Extension\", \"description\": \"An awesome extension that makes magic\", \"configuration\": { ... } } ] ... } Read more on how to define the extensions for your app in our development guides: Automatic Task guide. Machine Translation guide. Preview guide. Configuration An app can request configuration details at installation time (and it can be edited later). Note On an update, new configuration settings can be added, and the user will be requested to enter the newer configuration values. Configurations are app scoped. If you need to assign configuration values for individual extensions within the app, use clear and explicit naming conventions so users understand what information to input into each field. Additionally, tooltips can be provided by setting the description attribute. Configuration settings can be string, number, integer, boolean, datetime or secret. Additionally, the string dataType supports an array of options that will be displayed in a picklist form(for ex: \"options\": [ \"option1\", \"option2\" ]). for boolean a checkbox will be rendered. datetime will render a date time pick control. secret is used for passwords and secrets, the characters being hidden. Example: { ... \"configuration\": [ { \"name\": \"Third party token\", \"id\": \"thirdPartyToken\", \"description\": \"The token used to authenticate to third party API\", \"dataType\": \"string\" } ] ... } Note Note that in the example the optional and defaultValue properties have not been specified, so these will be set to their default values, as specified in the contract ( false for optional and undefined for defaultValue). Moreover, you have the option to define a list of choices using the options field. When this field is filled, the values will be presented in a dropdown menu. It's important to note that the only acceptable dataType in this scenario is string. Scopes Scopes within the app define the extent of access requested to the tenant's data. Depending on the actions carried out by the app, it may require read-only privileges, read/write permissions, or even access to secure projects. The permissible values for scopes are listed under the scopes section. The scopes advised in the descriptor will be presented to the consumers during installation. They can then decide whether to proceed with the installation and grant access to the app. Once access is granted, the app will be able to perform authorized requests to the Trados Cloud Platform API. Note If the app doesn't make requests to Trados Cloud Platform API, no scopes should be specified. Webhooks Webhooks can be registered automatically when declared in the descriptor. See Webhooks page for more details."
  },
  "articles/Extensibility/docs/development/App-Versioning.html": {
    "href": "articles/Extensibility/docs/development/App-Versioning.html",
    "title": "App Versioning",
    "summary": "App Versioning This article explains how the app versions work and how to use multiple versions of your app. Versions in Trados When registering the app, the descriptor is saved in Trados as the initial version. The descriptor includes a version field, which indicates the app's version. This version number should be incremented each time changes are made to the descriptor (such as endpoints or naming) to ensure Trados detects the new version. Only descriptors with higher version numbers are detected and added alongside existing ones. This enables the installed instances to be associated with a particular version of the app. Throughout an app's lifespan, it can be installed in various versions across different tenants. For instance, one tenant might install version 1.0.1, another 1.0.2, and a third 1.0.3. Although they expect to use the app at these particular versions, if no special actions are taken by the developer, they will probably all be using the same instance, which probably has a single implementation and does not take into consideration the expected version. Versioning Pitfall To delve deeper into the issue highlighted above, consider the following scenario: Your app has a public version installed across multiple tenants. Eventually, you opt to modify an extension's functionality. Upon deploying these changes, integrations will utilize the updated instance, thereby adopting the newly implemented business logic. However, this may not align with your intentions, or worse, it could introduce errors for tenants who have installed the older version and expect it to maintain its previous behavior. Versioning Your App To ensure that new behavior only affects new installations and tenants updating to the latest version, you can version the extension endpoints. For example, suppose your app implements an Automatic Task Extension with a submit endpoint like {baseUrl}/v1/submit, as specified in the contract. To prevent older versions from accessing the new functionality, create a new set of endpoints labeled with a new version, such as {baseUrl}/v2/submit, exclusively available in the updated descriptor version. Consequently, older versions won't recognize the existence of the v2 endpoint and will continue to use the v1 endpoint. Ensure that the v1 endpoint remains accessible at the same path defined in the older descriptor. For more details on version updates, refer to this dedicated guide. Versioning Headers An alternative option to handle different business logic based on the installed version is to utilize the provided HTTP headers. These headers (appVersion, extensionPointVersion, extensionId) allow developers to implement custom functionality based on the actual version of the installed apps across different customers."
  },
  "articles/Extensibility/docs/development/Authentication-Overview.html": {
    "href": "articles/Extensibility/docs/development/Authentication-Overview.html",
    "title": "Authentication Overview",
    "summary": "Authentication Overview Communication between Trados and apps is secured through multiple measures, ensuring that both the communication channel is tamper-proof and encrypted to protect against eavesdropping, but also to protect against unauthorized access. Firstly, this is achieved by requiring that all endpoints on the app provide HTTPS using TLS 1.2, but also that Trados is available on HTTPS. This secures the communication both ways. Secondly, the requests from Trados to the apps are authenticated with JWS Bearer tokens, that can be validated against a public key that is exposed in Trados Cloud Platform API and is cycled at regular intervals."
  },
  "articles/Extensibility/docs/development/Automatic-Task-App-development-guide.html": {
    "href": "articles/Extensibility/docs/development/Automatic-Task-App-development-guide.html",
    "title": "Automatic Task",
    "summary": "Automatic Task Automatic Task extensions offer the possibility to add custom functionality within a project's workflow. Examples of automatic tasks: send notifications about the project update project details copy the project files to a shared location Most of the Automatic Task extensions will need to perform certain requests to Trados Cloud Platform API in order to achieve the desired result. The Trados Cloud Platform API SDKs (for Java and .NET) are publicly available. In order to build a new Automatic Task extension we recommend to start by using the provided app blueprints. Automatic Task Extension For an app to offer Automatic Task functionality, it must define at least one Automatic Task extension within its descriptor. For example: { ... \"extensions\": [ { \"extensionPointId\": \"lc.automatictask\", \"id\": \"SAMPLE_AUTOMATICTASK_EXTENSION_ID\", \"name\": \"SAMPLE_AUTOMATICTASK_EXTENSION_NAME\", \"description\": \"SAMPLE_AUTOMATICTASK_EXTENSION_DESCRIPTION\", \"extensionPointVersion\": \"1\", \"configuration\": { \"endpoints\": { \"lc.automatictask.submit\": \"/v1/submit\" }, \"supportedInputFileType\": \"nativeSource\", \"outputFileType\": \"nativeSource\", \"scope\": \"file\", \"outcomes\": [ { \"default\": true, \"description\": \"Done.\", \"outcome\": \"done\" } ], \"workflowTemplateConfigurations\": [ { \"name\": \"SAMPLE_AUTOMATICTASK_EXTENSION_CONFIG_NAME\", \"id\": \"SAMPLE_AUTOMATICTASK_EXTENSION_CONFIG_ID\", \"description\": \"SAMPLE_AUTOMATICTASK_EXTENSION_CONFIG_DESCRIPTION\", \"optional\": false, \"defaultValue\": \"SAMPLE_DEFAULT_VALUE\", \"dataType\": \"string\" } ] } } ] ... } extensionPointId - the identifier of the extension point corresponding to this extensionType: lc.automatictask id - unique extension identifier provided by the app developer name - provide a friendly and unique name. It might be shown to the end user, and it may be useful in helping the user distinguish between multiple extensions description - the description of the automatic task extension extensionPointVersion - the version of the extension point that is implemented in the Extension configuration - the task configuration endpoints lc.automatictask.submit - the path of the endpoint that accepts a task for execution supportedInputFileType - the input file type supported by the task. All tasks can have input files, regardless of their scope. Acceptable values: nativeSource: processes source files in their native upload form (for example: FileTypeDetection, Engineering, FileFormatConversion) bcmSource: processes source files in their converted \"bcm\" form (for example: DocumentContentAnalysis, CopySourceToTarget) bcmTarget: processes target files in their \"bcm\" form (for example: Translation, Linguistic Review, MachineTranslation, TranslationMemoryMatching, TranslationMemoryUpdate, TargetFileGeneration) nativeTarget: processes target files in their native \"generated\" form (for example: DTP, FinalCheck) sdlxliffTarget: processes target files in their \"sdlxliff\" form, specifically for Import tasks. It is not recommended for automated task types at this time (early 2022). none: does not process the file content, neither to read nor to update it outputFileType - describes what the output files are for the given task. Acceptable values: idem with supportedInputFileType The supportedInputFileType and outputFileType parameters affect the extension task order in the workflow template, as follows: an extension task can only follow another task with the same outputFileType as its supportedInputFileType (except for the extension tasks with supportedInputFileType: nativeSource which can be placed first in the workflow). a normal task can only follow an external task with the same outputFileType as its supportedInputFileType. scope - describes the applicability of a task within a project Acceptable values: file: the task will be applicable for every file in the project. It will process either the source or the target files, based on the relation with supportedInputFileType and outputFileType targetLanguage: the task will be applicable for every target language of the project batch: the task is applicable only once for a batch execution within a project task: the task is applicable to other tasks. Specifically tailored for Error tasks. Not recommended for automated task types at this time (early 2022). vendorOrder: the task is part of the vendor negotiation process. Not recommended for automated task types at this time (early 2022). outcomes - the possible outcomes of this automatic task: outcome - a custom outcome value description - the outcome description default - if TRUE, this outcome will be used when no specific outcome is provided. At least one outcome must be set as default. workflowTemplateConfigurations - definitions of the configurations that the app needs at runtime in order to execute a task. The task will be configured when you create a workflow template, a workflow or a project. The configuration values will be passed to the app when a task is submitted for execution. For example, an extension that uploads a file to an FTP can have the location as a configuration. name - short, user-friendly name for the configuration settings id - an alphanumeric identifier, including underscores description - a user-friendly description of the configuration settings, describing what the user should set in the textbox optional - if the configuration setting is optional defaultValue - the default value of the setting dataType - specifies the data type for the value, to be used for input type generation options - a list of setting options You can define as many automatic extensions as you need. They could have the same extension point (submit endpoint) or different ones, depending on your app design. Extension Usage You can integrate your extension task within a Workflow Template as shown below: The workflowTemplateConfigurations can be configured as follows: Based on the created Workflow Template you can create a new Workflow. The last step is to start a Project using the Workflow created in the previous step. Find more details on how to use an Automatic Task app in the consumer guide. Scopes Depending on the actions performed by the app you may need to request access to the account's resources, otherwise the requests to the Trados Cloud Platform API will fail due to insufficient permissions. To request access from the consumers, you need to specify one or more scopes within the app's descriptor, as shown below: { ... \"scopes\" : [ \"TENANT\", \"TENANT_READ\", \"ACCESS_SECURE_PROJECT_CONTENT\" ] ... } The allowed values are: TENANT - Read/write/delete all tenant data (resources). TENANT_READ - Read-only access to all tenant data (resources). ACCESS_SECURE_PROJECT_CONTENT - Access to secure project content. They will be presented to the consumers at installation time in order for them to decide if they want to proceed with the installation and allow access to the app. Submit Endpoint The lc.automatictask.submit endpoint is used to receive and process the tasks from Trados. This endpoint should only schedule the task and return 200. The scheduled task would be picked up by a background process that will send the result to the received callbackUrl. Example: POST /v1/submit X-LC-Tenant: LC-TENANT_ID { \"projectId\": \"SAMPLE_PROJECT_ID\", \"correlationId\": \"SAMPLE_TASK_ID\", \"callbackUrl\": \"http://theCallback/callThisBack\", \"workflowConfiguration\": [ { \"id\": \"SAMPLE_CONFIG_ID\", \"value\": \"SAMPLE_CONFIG_VALUE\" } ] } The correlationId is the task identifier from Trados. You can also find it in the project details page under the Task History tab. The callbackUrl is a Trados endpoint where the app will send the outcome after the task is processed. The X-LC-Tenant header has to be kept in order to perform the callback request. Find more details in the dedicated section below. The blueprints contain placeholders from where you can start implementing the endpoint's functionality: .NET blueprint Java blueprint Please refer to the endpoint's documentation for further details. Callback Endpoint This is a Trados endpoint used to receive the task outcome from the Automatic Task apps. Each automatic task will have its own callback URL. Example: POST /external-job/v1/callback?token=CALLBACK_TOKEN X-LC-Tenant: LC-TENANT_ID { \"success\": true, \"outcome\": \"Done\", \"errors\": null } The request needs to include the X-LC-Tenant header. The token should be already present in the received callbackUrl on the submit endpoint. Please refer to the endpoint's documentation for further details."
  },
  "articles/Extensibility/docs/development/Concepts.html": {
    "href": "articles/Extensibility/docs/development/Concepts.html",
    "title": "Concepts",
    "summary": "Concepts Trados apps offer a way to extend the Trados functionality. Apps An app is a Rest API service, hosted by the developer, that is registered with Trados and will be invoked in the flows it is registered to handle. For example, an app can implement a new Machine Translation engine and register it with Trados. The new machine translation option will be available to whoever installs the app on their account. Apps can be either private or published to the store where they can be freely installed on other accounts. Extensions An app can have many extensions or none at all. An extension is an atomic functionality design to provide functionality defined by an Extension Point. For instance, an app might include a Machine Translation Extension, which lets it translate text using a service not built into Trados. Imagine the app as a box, with each extension as a piece that enhances it. You're not restricted to just one Machine Translation extension in the app. You can add as many extensions as you want, maybe different translation services. Also, it's fine to mix different types of extensions in one app. Extension Points Trados defines Extension Points that can be implemented in apps. For example, Machine Translation is an Extension Point. The actual implementation in an app is called an Extension."
  },
  "articles/Extensibility/docs/development/Deployment-Strategy.html": {
    "href": "articles/Extensibility/docs/development/Deployment-Strategy.html",
    "title": "Deployment Strategy",
    "summary": "Deployment Strategy In this guide, we will outline the recommended deployment strategy, the main ideas behind it, and how you can apply it. The proposed strategy involves hosting at least 2 instances of your app: The preview instance The live instance The Preview Instance The preview instance is designated for testing and experimenting with new things, such as extensions, configurations, etc. This instance must not be published. If needed, for testing purposes, it can be shared with other tenants. We suggest using a distinctive development name and description to differentiate it from the live instance. For example: Note Make sure you use a descriptor URL different from the one you need for the live instance. You cannot register two apps with the same descriptor URL. The Live Instance The live instance is the one you'll be using for production purposes. It might already be installed and used on a particular account, or shared with other accounts, or it may be the instance that is currently being published. Registration example: Finally, here is a comparison between the 2 instances:"
  },
  "articles/Extensibility/docs/development/Lifecycle.html": {
    "href": "articles/Extensibility/docs/development/Lifecycle.html",
    "title": "Lifecycle",
    "summary": "Lifecycle Communication between Trados and an app service involves several lifecycles. Some examples include: registration, installation, publishing, and more. The very basic flow of when an app is first registered by a developer and installed (optional, but recommended, step for developers) looks like this: A summary of all standard endpoints and their role in the lifecycle of an app: GET /descriptor is the very first endpoint that will be invoked when the app owner tries to register it in Trados. POST /app-lifecycle will be the next in order, with an identifier of REGISTERED. POST /app-lifecycle will be again invoked with id INSTALLED. GET /configuration will be invoked to get the list of configuration settings (including default values, current values) that need to be provided by the administrator who installed the app on their tenantId. POST /configuration will set the configuration values for the tenantId. Note: not all the settings can be sent in a single request. There may be multiple requests that are setting different configuration values. The app should keep these settings safe. Also note that this endpoint can be called any time after uninstall if the administrator decides to change any of the settings. Lifecyle Events The lifecycle events are handled by the lifecycle endpoint. Registered Event The lifecycle for registering the app in Trados: POST /app-lifecycle with id REGISTERED will notify the app service that it has been registered. From that moment on, administrators can install the app on their accounts, share it or publish. The payload will contain the clientId and clientSecret which can be used for authenticating with RWS Language Cloud API. That data should be stored securely in the app database. Installed Event The lifecycle for installing of the app in an account: POST /app-lifecycle with id INSTALLED is sent when the app is installed on an account. Only tenant identifier should be stored securely in the app database for keeping track of installed accounts. Uninstalled Event The lifecycle for uninstalling of the app from an account: POST /app-lifecycle will notify the app service, by providing the id UNINSTALLED. The app should delete any account-related data. Unregistered Event The lifecycle for unregistering an app from Trados: POST /app-lifecycle will be invoked with id UNREGISTERED. If there are accounts that haven't been previously uninstalled, they should be considered so, and all the related data be deleted. Updated Event A special lifecycle event has been introduced to help with the upgrade from 1.3 to 1.4 descriptor versions (from add-ons to apps). Also it will be used in the future for refreshing clientId and clientSecret: POST /app-lifecycle will provide credentials update when has the id UPDATED. The payload is similar to REGISTERED event. Other Endpoints There are also endpoints that can be called at any point in time: GET /descriptor - can be called before registration, during registration, after registration, on scheduled intervals, and so on. GET /health - will be called during and after registration. It is scheduled to be checked periodically. GET /documentation - can be called at any time. Additionally, there are also the Extension endpoints which are invoked in the business lifecycle."
  },
  "articles/Extensibility/docs/development/MT-App-development-guide.html": {
    "href": "articles/Extensibility/docs/development/MT-App-development-guide.html",
    "title": "Machine Translation",
    "summary": "Machine Translation Machine Translation apps offer the possibility to use external machine translation providers within the Trados platform. To build a new MT app we recommend starting by using the provided app blueprints. Machine Translation Extension An MT app needs to define at least one MT extension within its descriptor. For example: { ... \"extensions\": [ { \"id\": \"SAMPLE_MT_EXTENSION_ID\", \"name\": \"SAMPLE_MT_EXTENSION_NAME\", \"extensionPointVersion\": \"1\", \"extensionPointId\": \"lc.mtprovider\", \"description\": \"SAMPLE_MT_EXTENSION_DESCRIPTION\", \"configuration\": { \"endpoints\": { \"lc.mtprovider.translate\": \"/v1/translate\", \"lc.mtprovider.engines\": \"/v1/translation-engines\" }, \"format\": \"html\" // or \"bcm\" } } ] ... } id - unique extension identifier provided by the app Developer name - provide a friendly and unique name. It might be shown to the end user, and it may be useful in helping the user distinguish between multiple extensions extensionPointVersion - the version of the extension point that is implemented in the Extension extensionPointId - the extension point identifier corresponding to this extensionType: lc.mtprovider description - the MT extension description configuration - the extension configuration endpoints - the required endpoints for the MT extension lc.mtprovider.translate - the endpoint used to receive and translate content from Trados lc.mtprovider.engines - the endpoint used to retrieve the available translation engines (supported language pairs) format - the content's format supported by the app on the translate endpoint. Translation Engines Endpoint The lc.mtprovider.engines endpoint provides the available translation engines for the requested language pairs. Example: GET /v1/translation-engines?model=NEURAL&sourceLanguage=en-US&targetLanguage=ro-RO&targetLanguage=ro-MD&targetLanguage=fr-FR&exactMatch=true The model is the translation engine's type and its value can be either NEURAL or BASELINE. The exactMatch will enforce the result to include only the languages that match the exact values of the requested languages. There could be multiple target languages requested, thus the endpoint should return all translation engines for the supported ones. The response would look like this: { \"items\": [ { \"id\": \"en_fr_nmt\", \"model\": \"nmt\", \"name\": \"nmt\", \"engineSourceLanguage\": \"en\", \"engineTargetLanguage\": \"fr\", \"matchingSourceLanguage\": \"en-US\", \"matchingTargetLanguages\": [ \"fr-FR\" ] }, { \"id\": \"en_ro_nmt\", \"model\": \"nmt\", \"name\": \"nmt\", \"engineSourceLanguage\": \"en\", \"engineTargetLanguage\": \"ro\", \"matchingSourceLanguage\": \"en-US\", \"matchingTargetLanguages\": [ \"ro-RO\", \"ro-MD\" ] } ], \"itemCount\": 2 } nmt stands for \"NEURAL MACHINE TRANSLATION\" Endpoint usage This endpoint is going to be used when creating a new Translation Engine resource as shown below: The Machine Translation models are provided by the app via the lc.mtprovider.engines endpoint. The blueprints contain placeholders from where you can start implementing the endpoint's functionality: .NET blueprint Java blueprint Please refer to the endpoint's documentation for further details. Translate Endpoint The lc.mtprovider.translate endpoint translates the content, namely the text provided in the format specified in the descriptor (html of bcm). Example: POST /v1/translate { \"contents\": [ \"<div i=\\\"24\\\">Herea a smiley face <img i=\\\"25\\\"/></div>\", \"<div i=\\\"10\\\">Heres a table:</div>\" ], \"engineId\": \"en_ro_nmt\" } The engineId is the identifier of the engine used to translate the contents. The response would look like this: { \"translations\": [ \"<div i=\\\"24\\\"> Iat un chip zmbet <img i=\\\"25\\\"/></div>\", \"<div i=\\\"10\\\"> Iat un tabel: </div>\" ] } <div i=\"1\"> .. </div> might cause problems for some engines. You can parse them out before sending them to the translation service if the order of the segments can be guaranteed. Once the translated segments are available, these need to be added back when sending the response. Endpoint usage To test the endpoint, first, you will need a workflow that contains the Machine Translation automatic task and the Translation human task. For example: Using that workflow and the translation engine created in the previous step, you can start a new project like this: When the project reaches Translation, you can open it in the Online Editor and check the target segments. This is where you should find the translations performed by your app in the Machine Translation step. You can also search for Lookups to obtain alternative translations. This will invoke again the lc.mtprovider.translate endpoint. You can find more details on how to use an MT app in the consumer guide. The blueprints contain placeholders from where you can start implementing the endpoint's functionality: .NET blueprint Java blueprint Please refer to the endpoint's documentation for further details."
  },
  "articles/Extensibility/docs/development/Multi-Region.html": {
    "href": "articles/Extensibility/docs/development/Multi-Region.html",
    "title": "Multi-Region",
    "summary": "Multi-Region To fulfill the requirements of our customers, Trados Enterprise allows multi-region deployments of your app. To enable multi-region on your app you must provide regional instances of your app and include their regionalBaseUrls in your descriptor. Note Multi-Region is only supported on apps starting with decriptorVersion: 1.4 Warning Please note that the responsibility for ensuring region-specific URLs lies with the developer. The URLs should accurately reflect the physical location of the instances. Currently, the supported regions are Europe(eu) and Canada(ca). Depending on where your app is deployed you can choose either one or both of them. This will tell Trados what endpoints to invoke based on where the consumer tenant is living. Warning All instances, in all regions should provide the exact same descriptor. Installing an App with Multi-Region support When a consumer installs an app, if regionalBaseUrls is present and same region as consumer's is available, that region will be used. If your app does not provide the region where the consumer tenant belongs, the consumer will be notified before installing the app that the global region (baseUrl) will be used instead. Warning Once installed globally, if the app adds support for a new region, the consumers will have to reinstall it to change the region. The INSTALLED lifecycle event now includes the region information for the account where the app is installed so you can save it in the database and use it to identify to which regions calls should be made (for ex. which region/url to use for Public API). That is already implemented in the provided Java and .NET blueprints. Base URL vs Multi-Region Base URLs The baseUrl property from descriptor remains mandatory even if you add the regionalBaseUrls property(which is optional). Warning The baseUrl in your app should stay fixed and not change based on region. When an App is registered, baseUrl from that initial descriptor is used for setting audience for all future authentication requests, independent of regions (it is possible to change it later, see Changing Base URL. Your \"multi-region descriptor\" should look something like this: { // baseUrl - also treated as global path \"baseUrl\": \"foo.com/app/v1\" \"regionalBaseUrls\": { \"eu\": \"eu.foo.com/app/v1\", \"ca\": \"ca.foo.com/app/v1\" } //.. } Note It is also acceptable to have the same URL in baseUrl as for one of regions in your regionalBaseUrls property. The baseUrl is treated as a global region URL and is still used in the following scenarios even if regionalBaseUrls is also defined: Health checks - the /health endpoint that is periodically invoked to check the health status of your app Version checks - the /descriptor endpoint that is periodically invoked to check for new versions(by the version property). Note It is the developer's responsibility to keep the version of the regional instances in sync. UPDATED lifecycle event - explained below in the Special Case section. The regional URLs from regionalBaseUrl are used in the following scenarios: REGISTERED/UNREGISTERED lifecycle events - each regional URL is invoked and baseUrl. If baseUrl is same as one of the regional URLs, the events will be sent only once for that URL, to avoid duplicating them. Tenant-based requests(if install was done with a region and not a baseUrl - region was available at the time of install): INSTALLED/UNINSTALLED lifecycle events GET/Update/Validate configuration Webhooks - if your app supports webhooks they will be sent to your regional URLs Extension endpoints Examples If your app offers only a baseUrl with no regionalBaseUrls, for ex: ... \"baseUrl\": \"foo.com/app/v1\" ... When someone will try to install it, they will see a popup informing them that the app does not provide data residency in the same region as them and will ask them to confirm if they want to proceed with installation. Let's see another example where only one region is specified: ... \"baseUrl\": \"foo.com/app/v1\", \"regionalBaseUrls\": { \"ca\": \"ca.foo.com/app/v1\" } ... If a user in Canada region tries to install the App, the installation will go per usual. If a user in Europe, tries to install it, the confirmation popup will show up because Europe is not specified explicitly. For the case were all currently supported regions are specified: ... \"baseUrl\": \"foo.com/app/v1\" \"regionalBaseUrls\": { \"eu\": \"eu.foo.com/app/v1\", \"ca\": \"ca.foo.com/app/v1\" } ... When someone installs the app from Canada region or from Europe region, the installation will proceed as usual with no popups. If in the future a new region is introduced, but the app is not updated, users in the new region will be able to install the app but they will be met with the confirmation popup. baseUrl can be any valid url where calls will be processed as per documentation. Any of the following are valid: ... \"baseUrl\": \"foo.com/app/v1\" \"regionalBaseUrls\": { \"eu\": \"eu.foo.com/app/v1\", \"ca\": \"ca.foo.com/app/v1\" } ... ... \"baseUrl\": \"eu.foo.com/app/v1\" \"regionalBaseUrls\": { \"eu\": \"eu.foo.com/app/v1\", \"ca\": \"ca.foo.com/app/v1\" } ... ... \"baseUrl\": \"ca.foo.com/app/v1\" \"regionalBaseUrls\": { \"eu\": \"eu.foo.com/app/v1\", \"ca\": \"ca.foo.com/app/v1\" } ... Multi-Region on Fresh Apps Registering a new app that comes from the start with regionalBaseUrls will trigger the REGISTERED event notifications for each regional base URL as well as for baseUrl if not already present in the regionalBaseUrls. The same pair of credentials will be sent to each URL. Multi-Region on Existing Apps If your app has been registered without the regionalBaseUrls property it means it was only available globally via the baseUrl property. To add regional support you will have to include regionalBaseUrls in your descriptor. When Trados detects the new version it will sent the REGISTERED event only to the regional URLs that have been added in that new version. The same pair of credentials that were initially sent to the baseUrl will also be sent to the regional URLs. It is necessary that all your app deployments know to handle the event and store the received credentials securely. Special Case This section is for old add-ons(decriptorVersion:1.3) that have to be migrated to apps(decriptorVersion:1.4) and also want to support multi-region on the new version. As described in the migration guide when a descriptor with decriptorVersion:1.4 is detected, Trados will send the UPDATED event with a new pair of credentials. This event will be sent globally(only to the baseUrl) as before. After the UPDATED event was successfully received by the app, Trados will also send the REGISTERED event for each of the regional base URLs with the same pair of credentials from the previously sent UPDATED event. Recommendations To comply with data residency rules, make sure you provide instances for all supported regions, and your instances are physically in the specified region and there communication channel does not cross the region borders. Don't hard code the regions in your code. Make sure your code is flexible and can handle any new region. That way you will future proof your app as we are adding new regions. Decide on a primary region and set the baseUrl to that region url. That should simplify your deployment and configuration."
  },
  "articles/Extensibility/docs/development/Preview-App-development-guide.html": {
    "href": "articles/Extensibility/docs/development/Preview-App-development-guide.html",
    "title": "Preview Provider",
    "summary": "Preview Provider Introduction Preview apps offer the possibility to use external preview providers within the Trados Enterprise platform. The type of preview generated is known as \"Dynamic Preview\" as it can dynamically adjust depending on choices the user might make in the browser, for instance, selecting different preview sections or views from the rendered preview. The extension acts as a webserver which implements custom endpoints to serve the content to the browser. This content can be anything which the browser is able to parse and display accordingly. To build a new preview app we recommend to start by using the provided app blueprints. Preview App Extension A preview app needs to define at least one preview extension within its descriptor. For example: { ... \"extensions\": [ { \"extensionPointId\": \"lc.previewprovider\", \"id\": \"string\", \"name\": \"string\", \"description\": \"string\", \"extensionPointVersion\": \"string\", \"configuration\": { \"endpoints\": { \"lc.preview.startpreview\": \"string\", \"lc.preview.refreshpreview\": \"string\", \"lc.preview.updatesegment\": \"string\", \"lc.preview.endpreview\": \"string\" }, \"supportedFileTypes\": \"html\", \"requiredInputFiles\": { \"bilingualDocument\": true, \"previewPackageTemplate\": true, \"nativeFile\": true, \"nativeAnnotatedFile\": true }, \"outputType\": \"previewPackage\" } } ] ... } id - unique extension identifier provided by the app Developer. name - provide a friendly and unique name. It might be shown to the end user, and may be useful to help the user distinguish between multiple extensions. extensionPointVersion - the version of the extension point that is implemented in the Extension. extensionPointId - the extension point identifier corresponding to this extensionType: lc.previewprovider. description - the preview extension description configuration - the extension configuration. endpoints - the required endpoints for the preview extension, should be relative to your baseUrl. lc.previewprovider.startpreview - the endpoint used to start the preview generation. For ex: /start-preview. lc.previewprovider.refreshpreview - the endpoint used to refresh the existing preview session. For ex: refresh-preview. lc.previewprovider.updatesegment - the endpoint used to update a segment based on a BCM document fragment. For ex: update-segment. lc.previewprovider.endpreview - the endpoint used to clean up any state associated with a given preview session. For ex: end-preview. supportedFileTypes - A list of FileTypeDefinitionIds which this app may be associated with requiredInputFiles - provides details about which types of input files this extension will require for generating a preview. bilingualDocument - request an endpoint for downloading a BCM document. previewPackageTemplate - request an endpoint for downloading a preview Package Template. nativeFile - request an endpoint for downloading a native file. nativeAnnotatedFile - request an endpoint for downloading a native annotated file. outputType - Indicates which type of output is generated by the extension. For v1, this can be \"previewPackage\" for package-based previews or \"previewUrl\" for dynamic URL-based previews. Preview App Endpoints StartPreview The startPreview endpoint initiates a background preview generation session and returns after creating the background worker which generates the actual preview. The result is sent via calling the URL set in the callbackUrl field. An important field is the previewSessionId which indicates the session this preview is associated with. If the app needs to store any state, it should associate it with this identifier. The very first call for a given session should always be startPreview. If other endpoints are called before this, they should return an error. If the app is generating a previewPackage or standalone HTML result, it should be uploaded via the URL defined in the previewResultFileUrl field. The resulting resource identifier returned from this call should be set in the previewResult field of the callback response. For dynamic previews (outputType: \"previewUrl\"), the preview content is served by the app via one or more endpoints the app implements. The content can be any format, as long as the browser hosting the preview can parse and display that content. This includes HTML, PDF, streamed video etc. The resulting URL returned from this call should be set in the previewResult field of the callback response. Example: POST https://your-app.com/start-preview The request is as follows: { \"previewSessionId\": \"string\", \"fileInformation\": { \"name\": \"string\", \"sourceLanguage\": \"string\", \"targetLanguage\": \"string\" }, \"inputFiles\": { \"bilingualDocumentUrl\": \"string\", \"previewPackageTemplateUrl\": \"string\", \"nativeFileUrl\": \"string\", \"nativeAnnotatedFileUrl\": \"string\" }, \"previewResultFileUrl\": \"string\", \"callbackUrl\": \"string\", \"scope\": \"source\" } The response after setting up the background worker, would look like this: { \"errorCode\": \"string\", \"message\": \"string\", \"details\": [ { \"name\": \"string\", \"code\": \"string\", \"value\": \"string\" } ] } The final result, which is sent on the callback, is shown below: { \"previewSessionId\": \"string\", \"previewResult\": \"string\", \"errors\": [ { \"errorCode\": \"string\", \"message\": \"string\", \"details\": [ { \"name\": \"string\", \"code\": \"string\", \"value\": \"string\" } ] } ] } Endpoint usage: This endpoint is used to initiate a preview session on the app. When this endpoint is called, the app should generate the initial preview and associate it (internally, if any state is kept) - with the previewSessionId. This should be the first endpoint called for any given session - if another endpoint is called for a given session ID before this one, an error should be returned. Please refer to the endpoint's documentation for further details. RefreshPreview The refreshPreview endpoint refreshes an existing preview. The mechanism for this in entirely up to the Extension implementation in that it might keep state from the initial preview generation from startPreview in order to speed up the refresh. The request and responses (REST and Callback) are identical to the startPreview endpoint. Example: POST https://your-app.com/refresh-preview Endpoint usage: This endpoint is called when a preview refresh is requested by the user. Any state the app holds from the initial preview generation may be used to speed up the refresh. Please refer to the endpoint's documentation for further details. UpdateSegment The updateSegment endpoint accepts a list of BCM document fragments along with their associated segment IDs. The Extension will generate and return an HTML rendered fragment for each BCM document fragment sent in this manner. Example: POST https://your-app.com/update-segment The request is as follows: { \"previewSessionId\": \"string\", \"segments\": [ { \"segmentId\": \"string\", \"fragment\": {} } ], \"fileInformation\": { \"name\": \"string\", \"sourceLanguage\": \"string\", \"targetLanguage\": \"string\" }, \"scope\": \"source\" } previewSessionId - unique ID of current preview session. segments - an array of segments with the following details: segmentId - ID of segment being rendered. fragment - BCM document JSON fragment. fileInformation - provides information relating to the file for which the rendered HTML is being generated. scope - indicates whether the generation is happening for source or target content. The response would look like this: { \"previewSessionId\": \"string\", \"renderedTranslations\": [ { \"html\": \"string\", \"segmentId\": \"string\", \"errorCode\": \"string\" } ] } previewSessionId - unique ID of current preview session. renderedTranslations - an array of rendered translations with the following details: html - rendered HTML content for this segment. segmentId - ID of this segment. errorCode - Error code for this segment (App/Extension specific). Endpoint usage: This endpoint is called when the user is updating one or more segments in the Editor. For each segment, the extension will render an equivalent HTML fragment based on the input BCM document fragment. Please refer to the endpoint's documentation for further details. EndPreview The endPreview endpoint is called when a given preview session associated with the previewSessionId is finished. This is called so that the app may perform any required cleanup. Example: POST https://your-app.com/end-preview { \"previewSessionId\": \"string\" } Endpoint usage: Called to indicate a preview session has terminated. Any required cleanup should be performed by the app. Please refer to the endpoint's documentation for further details. Javascript Communication Protocol The Online Editor Container communicates with the Preview Viewer iframe using the Javascript postMessage mechanism. The API is detailed below: \"use strict\"; /* Communication Protocol between the RWS Online Editor and the preview loaded into it. * * Based on passing global events back and forth (events on the window object). * Used for: * * - navigation from one segment to the other (either happening on the editor and * getting propagated to the preview, or happening on the preview - by clicking * a segment - and getting propagated to the editor) * * - segment updates: when the translation for a segment changes, the segment * update flow will yield some piece of string (usually html content) that * will be sent to the preview currently being loaded in the editor * * - showing messages (could not navigate to the segment currently selected * in editor / cannot update the translation for certain segment) */ // IE compatibility Element.prototype.remove = function () { this.parentElement.removeChild(this); } if (!window.sdlPreviewScriptIncludeGuard) { // when the preview package gets inlined into a single html file, the script can // get included multiple times; we use this guard to only subscribe to the events // once window.sdlPreviewScriptIncludeGuard = true; //state var selectedSegmentId = \"\"; var segmentIdToSigCache = {}; var initialized = false; // names of the events var PREVIEW_SEGMENT_SELECTED = \"Preview:segmentSelected\"; var PREVIEW_SHOW_MESSAGE = \"Preview:showMessage\"; var UE_SEGMENT_SELECTED = \"UE:segmentSelected\"; var UE_UPDATE_SEGMENT = \"UE:updateSegment\"; document.addEventListener(\"DOMContentLoaded\", function (event) { /* preparations can be done here */ }); window.addEventListener(UE_SEGMENT_SELECTED, function (event) { // event.detail will contain the id of the segment we need to navigate to // the segment with this id can be highlighted and scrolled into view // if the segment cannot be highlighted on the preview: reportError(\"CannotNavigateToSegment\"); }); window.addEventListener(UE_UPDATE_SEGMENT, function(event) { // the id of the segment being updated var segmentId = event.detail.segmentId; // the string (html snippet) returned by the segment updater var segmentSnippet = event.detail.snippet; /* the contents of the corresponding page element can be changed * here according to the snippet */ // if the update cannot be done: reportError(\"PreviewCannotUpdate\"); }); } function reportError(type) { // types currently being used are \"CannotNavigateToSegment\" and \"PreviewCannotUpdate\" // TBD if we can support custom messages being sent in the detail attribute here window.dispatchEvent(new CustomEvent( PREVIEW_SHOW_MESSAGE, { detail: type } )); } function somethingWasClicked() { // can be handler of onclick on page elements corresponding to segments var previousSelection = \"...\"; var segmentId = \"...\"; if (segmentId !== previousSelection) { window.dispatchEvent(new CustomEvent( PREVIEW_SEGMENT_SELECTED, { detail: segmentId } // this informs the editor which segment it should navigate to )); } } For dynamic previews, a more comprehensive Javascript API is available that handles communication via postMessage between the iframe and the Online Editor. This includes: Navigation between segments Segment updates with translation changes Error messaging Scroll synchronization for side-by-side preview Segment highlighting and selection Session Management and Tenant Separation It is up to the app to manage any session state internally and have an expiry mechanism for this. Also, any data which is tenant specific needs to be kept separate from any other data and the app also needs to manage tenant separation concerns internally. Input Files The preview provider works with various types of input files: PreviewPackageTemplate - a zip package containing content used in preview generation (XML, HTML, images, CSS, XSLT, Javascript etc.) Native File - the native format being translated or previewed (Word, Excel, XML documents etc.) Annotated Native File - a native file annotated with special characters encoding segment identifiers and boundaries Dynamic Preview Concepts (for outputType: \"previewUrl\") When implementing dynamic previews: The app acts as a web server implementing custom endpoints TLS (Transport Layer Security) must be enabled on all custom endpoints Authorization via hard-to-guess access tokens with TTL support Content can be dynamically updated based on user selections Support for different renderings or views of the same BCM document content The URL format for dynamic preview endpoints: https://my.extension/custom-endpoint?sessionId={sessionId}&tenant={tenantId}&accessToken={hard-to-guess-access-token}&page={pageId}"
  },
  "articles/Extensibility/docs/development/Request-Authentication.html": {
    "href": "articles/Extensibility/docs/development/Request-Authentication.html",
    "title": "Request Authentication",
    "summary": "Request Authentication Requests made from Trados to the app are authenticated, except for some public endpoints on the app. Getting the current account identity is explained in this article in the Trados Claims section. Endpoints All but a few of the endpoints are required to check for valid Authentication. The API documentation specifies for each endpoint if authentication is required. Trados might send the Authorization header even on the endpoints that do not need authentication, but the app is not required to validate them. If the header is sent, the app should either ignore it or validate it. But if the token is not valid, then this should result in a 401/403 result. Note Note: the provided blueprints (both Java and .NET Core) have authentication implemented and working out of the box. You can skip the rest of this document unless you're interested in the technical details. Authorization header The HTTPS requests are all authenticated using the x-lc-signature header using a JWS token. For example: x-lc-signature: <JWS Token> JSON Web Signature token Trados follows the JWS RFCs [RFC 7797] and [RFC 7515] for defining the structure of the JSON Web Signature token that contains the signature that validates the authenticity of the request. If you're already familiar with JWT tokens, you can treat the JWS as a JWT, with the main difference being the token-body component, which is not part of the token (in our Trados implementation) - it is replaced with the hash signature of the request body. All claims are sent in the JWS header. JWS validation The JWS token consists of 3 parts: <JWS header>.<JWS body>.<JWS signature> The 3 parts are Base64url encoded and separated with a dot: '.'. The JWS token that is received in the x-lc-signature header has only the header and signature components, with the body missing (<JWS header>..<JWS signature>). <JWS body> is omitted from the received JWS, following the RFC 7515 - Detached content approach. It should be calculated, when received, on the app side: <JWS body> = Base64url(SHA256(HTTP Payload)) If the request does not contain a body (ex. in the case of GET requests), then it's calculated as an empty string ''. In that case <JWS body> can be replaced with the constant: 47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU which is equivalent to Base64url(SHA256('')). Once the <JWS body> is calculated, the JWS token should be considered in its entirety as <JWS header>.<JWS body>.<JWS signature>. The <JWS signature> on the received JWS token needs to be validated. The validation is done using the public keys that are available at https://lc-api.sdl.com/public-api/v1/.well-known/jwks.json (this endpoint is public and does not require authentication). Since the JWS body is the hash of the HTTP request payload, the JWS token will have all the claims defined in the header segment <JWS header>. JWS kid claim is used to identify the public key that the JWS was signed with. Signing will be done using the SHA256withRSA algorithm which is standard for JWS (\"alg\":\"RS256\"). But since algorithms change, you should not hard code the algorithms, but always rely on the alg claim to identify the signing algorithm. Once the signature was validated, you should also validate the other claims: iss - the issuer of the token. Must be https://languagecloud.rws.com/. It is required. aud - the audience should match baseUrl from the descriptor. This ensures that the token was generated for that particular app. It is required. exp - expiry time of the token, expired tokens should not be accepted. It is required. iat - issued at time. Tokens issued in the future should not be allowed. It is optional and should be validated only if present. Clock skew should be taken into consideration when validating time claims. A few seconds (up to 60) should be added to validation limits. For example for iat claim, it should be checked that it's not issued before now() - clockSkew, otherwise with under 1-second clock differences there might be cases where iat can be in the future because the receiving server clock is 1 second behind the Trados server, and the token will not validate. Validating multiple audiences There will always be a single aud claim in the JWS. But in the rare case when an App changes baseUrl, the received aud will be either the old or new baseUrl. All operations for accounts that did not yet update to the version with the new baseUrl will send aud claim with the old baseUrl. The provided blueprints and samples by default handle a single baseUrl, and will fail with authentication issues in such a scenario. In .NET, validating aud against multiple audiences is fairly simple. In appsettings.json add a key for previousBaseUrl set it to the value of previous baseUrl. In Startup.cs find services.AddAuthentication and update it to looks similar to: services.AddAuthentication(JwsDefaults.AuthenticationScheme) .AddJws(options => { options.JwksUri = Configuration[\"Authorization:JwksUri\"]; options.TokenValidationParameters.ValidIssuer = Configuration[\"Authorization:Issuer\"]; options.TokenValidationParameters.ValidAudiences = new[] { Configuration[\"baseUrl\"], Configuration[\"previousBaseUrl\"] }; }); In Java, this can be accomplished by adding multiple values, separated by commas, to the authentication.audience parameter in the application.yml file. For example: authentication: ... audience: https://my.base.url,https://my.previous.base.url Trados Claims Trados can send any number of custom claims (in the JWS header segment), to provide additional information as to the current identity. aid is used for identifying the current Account(known as Tenant). This should be used for any operations that perform account-related operations. For example: saving the configuration to a database should always be tied to an account."
  },
  "articles/Extensibility/docs/development/Technical-Requirements-And-Best-Practices.html": {
    "href": "articles/Extensibility/docs/development/Technical-Requirements-And-Best-Practices.html",
    "title": "Technical Requirements And Best Practices",
    "summary": "Technical Requirements And Best Practices Technical requirements for Apps Most technical requirements are driven by the app's developer. For example, CPU/Memory requirements should be decided by the developer after taking into consideration the particular functionality of the app and its expected load. For reference, a typical machine translation app built on the .NET Core Blueprint, which adapts a third party translation engine, with 250,000 transactions per month, only requires very minimal hardware resources, with 0.1 CPU and 500 MB RAM. But there are certain aspects that still need to be covered to ensure secure and resilient operations. Framework Apps can be developed using any framework, but we provide two blueprints to help you get started: one for .NET Core 8 and the other for Java. Redundancy A load balanced, two instance deployment is recommended to ensure there are no interruptions in operation in case of failures, or more importantly, no downtime when a new version is deployed (by using rolling deployments). This recommended setup can be easily achieved if the application is deployed on a cloud platform. Security All communication should be secured against interfering and eavesdropping. This includes the communication between the Trados platform and the App, and also between the app and the resources it uses: third party Machine Translation Engines, databases and other resources. Trados uses two mechanisms to secure the apps communication: HTTPS support is mandatory, and Trados will not communicate with the app over an unsecured HTTP channel, or via a channel with expired or invalid certificates. The app can also validate that the caller is indeed Trados, by verifying the signature in each call with the Public Key available from Trados on an HTTPS endpoint. An additional security mechanism used by Trados is signing the request body. This provides an extra layer of validation, but it can also be used in case the application gets compromised, and an analysis is required to identify which messages are authentic and which aren't. For that, all incoming messages need to be logged or audited in some form. By following these guidelines, app developers can ensure that their code is secure and resistant to attacks, protecting sensitive data and maintaining the confidentiality, integrity, and availability of their applications, while also staying aware of and addressing any potential vulnerabilities in their dependencies: Input Validation: Always validate user inputs to ensure they are within the expected range and format. This helps to prevent injection attacks such as SQL injection or Cross-Site Scripting (XSS). Secure Configuration: Configure your app securely by avoiding default settings and keeping all passwords and sensitive information out of code. Secure Coding Practices: Follow secure coding practices such as avoiding hardcoded passwords, using secure coding patterns and libraries, and avoiding dynamic code execution. Access Control: Ensure that access controls are in place to prevent unauthorized access to sensitive data or functions within the application. Error Handling: Implement proper error handling to prevent sensitive information from being exposed to attackers. Manage Vulnerable Dependencies: Keep track of the dependencies used in your application and regularly check for any known vulnerabilities in those dependencies. Update to the latest version of the dependency as soon as possible to reduce the risk of exploitation. Logging Logging is required for tracking the flow of operations and for debugging any possible issues. Logging is already set up for both blueprints, but you need to adjust the template of the logs and their destinations. Important components in the logs, already present in the blueprints, include: timestamp - this should have a timezone, to avoid any confusion of whether it's local time or UTC. trace id - each request sent from Trados contains a trace id which can be used to track a complete flow. This is also propagated in the code from the moment a request is performed until a response is returned. thread id host/node name - this depends on your infrastructure setup, and we recommend having it logged, especially if you have more than one instance running. account id message - an informative description of what is happening error and stack trace Do not log sensitive information in the logs, like personal identification information, API keys, incoming authentication details or signatures. Metrics Metrics help answer questions like: Usage - how many/how much? Hardware requirements - are the currently allocated resources enough? Do we need to scale up or can we scale down to save on running costs? This is not a strict requirement, but it is strongly recommended to have some form of metrics set up. This should be set up in such a way to enable you to: Track the number of failed request/errors. Track the total number of transactions. Track the timing of the transactions/requests (this can be addressed by various metrics like max, min, median, percentile). Monitor CPU and Memory utilization. This should be used to correlate transactions with resource usage. Error Responses It's important to follow the specification for the endpoints when it comes to returning error responses. Each endpoint defines a set of expected error responses and the error response model. Implementing the contract correctly allows Trados to parse the response correctly and, in some situations, to handle the error and make decisions on it. Endpoints can have a set of predefined error codes that Trados can interpret. One such example would be the invalidConfiguration. Error responses can even pinpoint further the source of the problem, in the details array that might indicate, for example, the actual field with the incorrect value, along with a corresponding code, for example, invalidValue or nullValue."
  },
  "articles/Extensibility/docs/development/Tehnical-Requirements-And-Best-Practices.html": {
    "href": "articles/Extensibility/docs/development/Tehnical-Requirements-And-Best-Practices.html",
    "title": "Technical Requirements And Best Practices",
    "summary": "Technical Requirements And Best Practices Technical requirements for Apps Most technical requirements are driven by the app's developer. For example, CPU/Memory requirements should be decided by the developer after taking into consideration the particular functionality of the app and its expected load. For reference, a typical machine translation app built on the .NET Core Blueprint, which adapts a third party translation engine, with 250,000 transactions per month, only requires very minimal hardware resources, with 0.1 CPU and 500 MB RAM. But there are certain aspects that still need to be covered to ensure secure and resilient operations. Framework Apps can be developed using any framework, but we provide two blueprints to help you get started: one for .NET Core 8 and the other for Java. Redundancy A load balanced, two instance deployment is recommended to ensure there are no interruptions in operation in case of failures, or more importantly, no downtime when a new version is deployed (by using rolling deployments). This recommended setup can be easily achieved if the application is deployed on a cloud platform. Security All communication should be secured against interfering and eavesdropping. This includes the communication between the Trados platform and the App, and also between the app and the resources it uses: third party Machine Translation Engines, databases and other resources. Trados uses two mechanisms to secure the apps communication: HTTPS support is mandatory, and Trados will not communicate with the app over an unsecured HTTP channel, or via a channel with expired or invalid certificates. The app can also validate that the caller is indeed Trados, by verifying the signature in each call with the Public Key available from Trados on an HTTPS endpoint. An additional security mechanism used by Trados is signing the request body. This provides an extra layer of validation, but it can also be used in case the application gets compromised, and an analysis is required to identify which messages are authentic and which aren't. For that, all incoming messages need to be logged or audited in some form. By following these guidelines, app developers can ensure that their code is secure and resistant to attacks, protecting sensitive data and maintaining the confidentiality, integrity, and availability of their applications, while also staying aware of and addressing any potential vulnerabilities in their dependencies: Input Validation: Always validate user inputs to ensure they are within the expected range and format. This helps to prevent injection attacks such as SQL injection or Cross-Site Scripting (XSS). Secure Configuration: Configure your app securely by avoiding default settings and keeping all passwords and sensitive information out of code. Secure Coding Practices: Follow secure coding practices such as avoiding hardcoded passwords, using secure coding patterns and libraries, and avoiding dynamic code execution. Access Control: Ensure that access controls are in place to prevent unauthorized access to sensitive data or functions within the application. Error Handling: Implement proper error handling to prevent sensitive information from being exposed to attackers. Manage Vulnerable Dependencies: Keep track of the dependencies used in your application and regularly check for any known vulnerabilities in those dependencies. Update to the latest version of the dependency as soon as possible to reduce the risk of exploitation. Logging Logging is required for tracking the flow of operations and for debugging any possible issues. Logging is already set up for both blueprints, but you need to adjust the template of the logs and their destinations. Important components in the logs, already present in the blueprints, include: timestamp - this should have a timezone, to avoid any confusion of whether it's local time or UTC. trace id - each request sent from Trados contains a trace id which can be used to track a complete flow. This is also propagated in the code from the moment a request is performed until a response is returned. thread id host/node name - this depends on your infrastructure setup, and we recommend having it logged, especially if you have more than one instance running. account id message - an informative description of what is happening error and stack trace Do not log sensitive information in the logs, like personal identification information, API keys, incoming authentication details or signatures. Metrics Metrics help answer questions like: Usage - how many/how much? Hardware requirements - are the currently allocated resources enough? Do we need to scale up or can we scale down to save on running costs? This is not a strict requirement, but it is strongly recommended to have some form of metrics set up. This should be set up in such a way to enable you to: Track the number of failed request/errors. Track the total number of transactions. Track the timing of the transactions/requests (this can be addressed by various metrics like max, min, median, percentile). Monitor CPU and Memory utilization. This should be used to correlate transactions with resource usage. Error Responses It's important to follow the specification for the endpoints when it comes to returning error responses. Each endpoint defines a set of expected error responses and the error response model. Implementing the contract correctly allows Trados to parse the response correctly and, in some situations, to handle the error and make decisions on it. Endpoints can have a set of predefined error codes that Trados can interpret. One such example would be the invalidConfiguration. Error responses can even pinpoint further the source of the problem, in the details array that might indicate, for example, the actual field with the incorrect value, along with a corresponding code, for example, invalidValue or nullValue."
  },
  "articles/Extensibility/docs/development/Trados-Cloud-API.html": {
    "href": "articles/Extensibility/docs/development/Trados-Cloud-API.html",
    "title": "Trados Cloud Platform API",
    "summary": "Trados Cloud Platform API Communication to Trados Cloud Platform API is also authenticated and the process is described in the Trados Cloud Platform API documentation. Credentials When an app is registered, credentials (clientId and clientSecret) are sent to the app with the REGISTERED lifecycle event on the App Lifecycle endpoint. An example payload: { \"id\": \"REGISTERED\", \"timestamp\": \"2019-08-24T14:15:22Z\", \"data\": { \"clientCredentials\": { \"clientId\": \"<client id>\", \"clientSecret\": \"<client secret>\" } } } Here clientId and clientSecret represent the credentials for the Trados Cloud Platform API and can be used for getting a token for communicating with the Trados Cloud Platform API, as described by the Trados Cloud Platform API documentation. When an app is installed on an account, a service user will be created in Trados and an event will be sent on the App Lifecycle endpoint with event id being INSTALLED. Account ID should always be used from the request authentication header token. This is built in in the provided blueprints. Scopes Access to the Trados Cloud Platform API is not allowed implicitly from the app. In order for the Trados Cloud Platform API credentials to have the permissions to read or edit data in Trados, the desired scopes must be listed in the app's scopes property in the descriptor. Scopes that can be viewed as a list of permissions that need to be granted to the service user (and are shown to and approved by the administrator who installs the app on the account). For example, to request the permission to edit data on an account, the TENANT scope must be specified in the scopes in the descriptor. For read only access, TENANT_READ is enough. The scopes are cumulative, so if you specify TENANT, you don't have to specify TENANT_READ."
  },
  "articles/Extensibility/docs/development/UI-App-custom-elements-locations.html": {
    "href": "articles/Extensibility/docs/development/UI-App-custom-elements-locations.html",
    "title": "Custom Elements and Locations",
    "summary": "Custom Elements and Locations The platform supports the addition of various UI elements, including buttons (generic, link, and dropdown) and panels (generic, sidebar, and tab). These elements can be incorporated into specific sections of the user interface in the Inbox, Orders, Projects and Reports areas. Section View Location key Supported element types Default on-render selector keys Notes Inbox Tasks list tasks-list-tabpanel tab New tasks list new-tasks-list-sidebar sidebarBox inboxActiveTab, selectedNewTasks new-tasks-list-toolbar button inboxActiveTab, newTaskPreview Active tasks list active-tasks-list-toolbar button inboxActiveTab, selectedActiveTasks active-tasks-list-sidebar sidebarBox inboxActiveTab, activeTaskPreview Completed tasks list completed-tasks-list-toolbar button inboxActiveTab, selectedCompletedTasks completed-tasks-list-sidebar sidebarBox inboxActiveTab, completedTaskPreview Task task-toolbar button taskActiveTab, task task-tabpanel tab taskActiveTab, task task-sidebar sidebarBox taskActiveTab, task task-details-toolbar button taskActiveTab, task task-details-main panel taskActiveTab, task task-files-toolbar button taskActiveTab, task Orders Orders list orders-list-tabpanel tab Projects Projects list projects-list-tabpanel tab projects-list-toolbar button selectedProjects project-details-dashboard-sidebar * sidebarBox projectDetailsActiveTab, projectDetails element visible in two views Project project-details-toolbar button projectDetailsActiveTab, projectDetails project-details-tabpanel tab projectDetailsActiveTab, projectDetails project-details-dashboard-toolbar button projectDetailsActiveTab, projectDetails project-details-dashboard-main panel projectDetailsActiveTab, projectDetails project-details-dashboard-sidebar * sidebarBox projectDetailsActiveTab, projectDetails element visible in two views project-details-stages-toolbar button projectDetailsActiveTab, projectDetails, projectStages project-details-files-toolbar button projectDetailsActiveTab, projectDetails, projectFiles project-details-task-history-toolbar button projectDetailsActiveTab, projectDetails, projectTaskHistory project-details-task-history-sidebar sidebarBox projectDetailsActiveTab, projectDetails, projectTaskHistory Reports Reports list reports-list-tabpanel tab * The sidebarBox element targeting the project-details-dashboard-sidebar location key is also displayed in the Projects list view when a project in the list is selected."
  },
  "articles/Extensibility/docs/development/UI-App-development-guide.html": {
    "href": "articles/Extensibility/docs/development/UI-App-development-guide.html",
    "title": "User Interface App Development Guide",
    "summary": "User Interface App Development Guide UI extensions offer the possibility to add custom user interface elements and functionality. Custom buttons and panels can be added to specific places within the user interface. Caution This feature is currently in BETA. Please note that in a future phase, we will introduce significant changes as we move towards the official release: The current implementation utilizes the authorization token of the logged-in Trados user for the Trados Cloud Platform API and the app's own API calls. In a future update, a different authorization token will be introduced for these operation. As a result, access to the Trados Cloud Platform API functionality of a UI extension app will be governed not only by the Trados user's permissions but also by the app's scopes. A UI extension's JavaScript file will be loaded in an isolated context, independent from Trados. The communication model between App UI and Backend will change in the final version and will have to be redesigned. A UI extension is defined in the app descriptor in the extensions array. { ... \"extensions\": [ { \"extensionPointId\": \"lc.ui\", \"id\": \"SAMPLE_UI_EXTENSION_ID\", \"name\": \"SAMPLE_UI_EXTENSION_NAME\", \"description\": \"SAMPLE_UI_EXTENSION_DESCRIPTION\", \"extensionPointVersion\": \"1.0\", \"configuration\": { \"scriptPath\": \"/PATH/TO/JAVASCRIPT/FILE.JS\", \"endpoints\": {} } } ] ... } The extensionPointId is always \"lc.ui\". The configuration's scriptPath is the path of the JavaScript file which will be loaded in the Trados user interface. The path is relative to the basePath in the descriptor. This JavaScript file contains the code describing the custom elements that will be added to the user interface and their functionality. Prerequisites Node.js If you don't already have Node.js installed, you can download the most recent LTS (Long-Term Support) version of Node.js from nodejs.org. Dependencies @trados/trados-ui-extensibility v0.1.5 GitHub repository GitHub wiki Development dependencies ts-loader webpack webpack-cli Getting started Note Make sure you are familiar with Trados app development and testing presented in the Getting Started with Blueprints and Testing articles. Download the .NET sample app which contains a UI extension. The sample can be run out of the box with the same requirements as for the blueprint, a local Mongo database. For different setups please see the blueprint and testing articles as you'll need to adjust your configuration. Open the sample app solution in your IDE of choice. Follow the steps presented in the Getting Started with Blueprints and Testing articles to get your app running, then register and install it. Open Trados in a browser and go to the Projects section. Notice some custom elements were added by the sample app's UI extension. To alter the UI extension, make your changes in the Rws.LC.UISampleApp/Resources/frontend folder, then open a terminal from the Rws.LC.UISampleApp/Resources/frontend location. Install the dependencies for your UI extension by running this command: npm install Build the UI extension to output the Javascript file that will be loaded by Trados for your UI extension: npm run build You can also build the UI extension using development mode: npm run build-dev The build (or build-dev) command will create a my-ui-extension-script.js file in Rws.LC.UISampleApp/Resources/frontend/dist/. This is the path you need to use in the descriptor for your extension's configuration scriptPath, for example Rws.LC.UISampleApp/Resources/frontend/dist/my-ui-extension-script.js. You can change the my-ui-extension-script.js file name by editing the module.exports' output.filename property in Rws.LC.UISampleApp/Resources/frontend/webpack.config.js and the extension's configuration scriptPath field. Note If your app is already registered, after changing the extension's configuration scriptPath field you need to update your app to a new version. Once you have built your new JavaScript file, refresh the Trados browser tab to see your changes. Sample app UI code overview Open the sample app which contains a UI extension in your IDE. Open the index.ts file. import { trados, ExtensionElement, ExtensibilityEventDetail } from \"@trados/trados-ui-extensibility\"; The trados import is the main import in your UI extension and allows you to use the available extensibility functionality. The ExtensionElement and ExtensibilityEventDetail imports are TypeScript types. Your UI extension adds custom elements to the Trados UI. Define them in an array of type ExtensionElement. const elements: ExtensionElement[] = [ { elementId: \"myCustomButton\", location: \"project-details-toolbar\", text: \"My Custom Button\", type: \"button\", actions: [ { eventType: \"onclick\", eventHandler: (detail: ExtensibilityEventDetail) => { console.log(\"My custom button was clicked\", detail.project); }, payload: [\"project\"] } ] } ]; Each custom element has an elementId, a type, and a location. Each element in your extension must have a unique elementId. The type and location properties can only have values described in Custom elements and locations. Other properties depend on the custom element's type. For example, the menu property is only available for the button element type and indicates the button has a dropdown menu. Custom elements can have an actions property, which is an array of objects describing the behavior of the custom element in the case of specific events. The supported values for an action's eventType are: onrender for all element types and onclick which is specific to button elements. An action's payload property indicates the data portions available in the Trados UI that will be send inside the event detail to be consumed by the event handler function. In the code snippet above, the onclick event is handled by the eventHandler function which has a single argument called detail. Since this action's payload is an array containing the project data selector key, the eventHandler's detail argument will also contain a project field representing the current project object in the Trados UI. After you have defined the custom elements your UI extension will add to the Trados UI in the elements array, you must enable communication between your UI extension and Trados UI by calling the trados.onReady function. trados.onReady(elements, () => { console.log(\"Communication with Trados UI enabled\"); }); The onReady function inside the trados object has two arguments: the elements array describing all custom elements your UI extension adds to the Trados UI, and a callback function that is called once your UI extension's script is loaded in the browser and communication with Trados UI is available. Calling your own app's API In the sample app code, open the index.ts file and find the element with id callAppApiButton. The actions field has the callAppApiButtonClicked eventHandler. Go to this function's implementation in handlers/buttonsHandlers.ts and notice the trados.callAppApi function being called: trados.callAppApi({ url: `api/greeting/`, method: \"GET\" }) The object passed as argument has the url property set to api/greeting which is the route of the endpoint implemented in GreetingController.cs in the Controllers folder. The second property is the method set to GET. The argument object has two mandatory properties, url and method, and can have other properties depending on your use case, such as params, formData, body, headers. The callAppApi function returns a Promise, so you can use then/catch to handle the API call's response. Calling the Trados Cloud Platform API In the sample app code, open the index.ts file and find the element with id callPublicApiButton. The actions field is an array of two items, one handling the onrender event and the other handling the onclick event. Go to the callPublicApiButtonClicked function's implementation in handlers/buttonsHandlers.ts and notice the tradosProjectTemplateApi function being called: tradosProjectTemplateApi() .getProjectTemplate({ projectTemplateId: projectTemplateId, ...trados.getRegistrationResult() }) Each Trados Cloud Platform API needs to be imported separately from @trados/trados-ui-extensibility and is represented by a function. In this example, the tradosProjectTemplateApi function is imported and called to initialize the API. The next function call, getProjectTemplate, is the call to a specific endpoint from the tradosProjectTemplateApi. The projectTemplateId is the mandatory field needed for the getProjectTemplate API endpoint call. Notice the ...trados.getRegistrationResult() passed inside the argument. This extends the argument object with additional mandatory fields like the account identifier and authorization token. For each Trados Cloud Platform API, all endpoint functions function return a Promise, so you can use then/catch to handle the API call's response. Using data available in the Trados UI In the sample app code, open the index.ts file and find the element with id myGetUiDataButton. The actions field has the myGetUiDataButtonClicked eventHandler. Go to this function's implementation in handlers/buttonsHandlers.ts and notice the trados.getLocalData function being called: trados.getLocalData(trados.contexts.projects, trados.dataSelectors.selectedProjects) The getLocalData function provides access to portions of data currently available in the Trados UI. The first argument is the trados.contexts.projects. This indicates in which main section of the application the needed data resides. The second argument is the data portion selector, in this example trados.dataSelectors.selectedProjects. This will provide the array of Project objects selected by the user in the Projects list view. The getLocalData function returns a Promise, so you can use then/catch to handle the success or failure of the data retrieval. Changing a custom element In the sample app code, open the index.ts file and find the element with id myDropdownButton. Notice that it has a menu property which is an array describing the dropdown menu options of the button. Besides the icon and text properties, each menu option has a value set to an arbitrary string. Scroll down to the button's actions property and notice the onclick eventHandler function. It contains a switch statement parsing the value received from the onclick event's detail object. When a user clicks a dropdown menu option, its value is passed to the eventHandler. Every dropdown menu option in myDropdownButton updates properties of another custom element in the UI extension, myTargetButton. Notice the trados.updateELement function being called: trados.updateElement(\"myTargetButton\", { disabled: true }) The first argument is the id property of the custom element that will be updated. The second argument is an object containing the properties to update and their new values. The id, type and location of a custom element can not be changed. Properties that can be changed depend on the custom element's type: custom elements with type button can have these properties changed: disabled, hidden, icon, text, menuItems. For each object in menuItems you can also change disabled, hidden, icon, text. When setting the icon property of a button or dropdown menu option, use string values from Font Awesome. custom elements with type panel, sidebarBox, tab can only have their text property changes. To change the content, see Adding content to a panel, sidebarBox or tab. The updateElement function returns a Promise, so you can use then/catch to handle the success or failure of the update. Navigating inside Trados UI In the sample app code, open the index.ts file and find the element with id myNavigateButton. The actions field has the myNavigateButtonClicked eventHandler. Go to this function's implementation in handlers/buttonsHandlers.ts and notice the trados.navigate function being called: trados.navigate(projectTemplatePath, trados.navigationTypes.route) The first argument is the path to which the application will navigate. Note this is not a URL, but only the portion after /lc/{myAccount}/ in the Trados URL. In the example, it's resources/project-templates/${projectTemplateId}. The second argument is optional and indicates the type of routing navigation will use, either route or load. The default is route and will cause Trados UI to navigate to the desired path without a page load. The load navigation type will cause the Trados UI to reload to the new path. Adding content to a panel, sidebarBox or tab In the sample app code, open the index.ts file and find the element with id myCustomPanel. The actions field has the myCustomPanelRendered eventHandler. Go to this function's implementation in handlers/panelsHandlers.ts and notice this code line: const panelContentWrapper = document.getElementById(detail.domElementId); The onrender event's handler is passed the detail argument which contains the domElementId property. This is the DOM element to which you can add HTML content using JavaScript. Note that adding script tags is not allowed and scripts from sources that are not white-listed in Trados are blocked. Adding script tags that are served from the same source as your app is also not allowed. Only the script file set in your app's descriptor will be loaded by Trados. Notes Note Custom elements display order Within a single UI extension: custom elements in your extension that have the same location are displayed in the same order in which they are present in your ExtensionElements array. With multiple UI extensions: the display order is determined by the order in which each UI extension's script file is loaded in the Trados UI. Note Unexpected re-renders A custom element's onrender event can be triggered multiple times depending on state changes in the Trados UI and depending on user's interactions with Trados UI. Subsequently, the corresponding eventHandler gets executed multiple times. You can add logic specific to you use-case to protect your UI extension against unneeded execution of onrender eventHandler."
  },
  "articles/Extensibility/docs/development/Verification-App-development-guide.html": {
    "href": "articles/Extensibility/docs/development/Verification-App-development-guide.html",
    "title": "Verification Provider",
    "summary": "Verification Provider Overview Trados provides verification functionality on translatable content (source and/or target) in several ways: Batch Verification Task (set in project workflows) Editor Document Verification Task Editor Segment-level Verification operation The first two verification tasks validate the whole document, whereas the last operation, validates a single segment. For document validation, native verification is also possible. This allows for validation of a native file or a native annotated file. The difference between an annotated file and a non-annotated file is that the first allows for the generation of location information and the second does not. For native verification, a verification resource package may also be retrieved by the extension. This would contain ancillary files such as schemas, for example, in the case of XML validation. Trados supports a set of internal verifiers which are fixed in nature and the user can decide, through settings, what will be verified using these. Some of them are, for example: QA Checker Tag Verifier To allow for extending of the verification functionality, Trados supports the creation of extensible or external verifiers. These are hosted in apps which are essentially a self-contained serviced offering the verification functionality. Extensible verifiers would normally only support a small set of verification types, such as a target segment length check (against the length of the source) for example, or perhaps, a punctuation checker. There are 2 types of verification which are supported by extensibility: Bilingual Document Verification Native File Verification With Bilingual Document Verification, the verifier has access to the BCM document and can validate each segment as required Native File Verification validates the native source or target file. This file might also be annotated to allow for the easy determination of segment identifiers. An example of native file verification would be schema validation on an XML file. The aim of native verification is to establish if the translation process has broken any of the document structure and rendered an invalid document. Each verifier will generate a set of error or warning messages based on the type of validation they perform. The user can change validation settings in the LC UI Project Settings which will affect how or when the messages are generated. External verifiers also have the option to specify resource packages in the settings which will allow the user to upload support files required during the validation process. This option is verifier specific as not all verifiers might require a package. The user can see generated verification messages in the Editor UI and can choose to ignore certain messages by message type or individually, depending on their needs. They can subsequently un-ignore them at a later stage if desired. Verifiers may also provide localized messages which can be displayed in the same language the Editor UI is presenting in. Flows: Notes on the Flow Diagrams The StartVerification request initiates the background job on the extension. The background job will be responsible for generating the verification messages. The DownloadDependencyFiles calls to the Trados Cloud Platform API implies using various URLs to call endpoints as defined in the StartVerification request defined below. These resources can include Native files, Native annotated files, BCM documents, Verification Resource Packages, Language Resource Templates and Translation Engine resources. The PublishMessages endpoint is used to publish batches of verification messages as they are generated by the extension to the Trados Cloud Platform API. See below for more details. The publishMessageUrl is defined in the initial StartVerification request. The PublishEndResult is a call to the callbackUrl which is defined in the StartVerification request. This is called to indicate that all messages have been generated by the extension. Please see below for more details. App implementation overview The app receives a VerifyDocument request from Trados. The request specifies certain URLs relating the the required resources the app will need for performing its verification task in addition to callback URLs for publishing verification messages and finalizing the operation. These resources are downloaded to the app via the Trados Cloud Platform API and can be stored locally during the verification operation. When the request is received, the app responds with 201(Created) and starts a background job which will generate the verification messages. For each verification error or warning the app creates, it needs to send this back to Trados via the Trados Cloud Platform API. These messages may be grouped into batches to minimize chatty behavior between the app and the Trados Cloud Platform API. The app may also receive a request to verify a single segment. All interactions between the app and Trados Cloud Platform API are via REST calls. API Overview The extensible verifier API consists of a number of endpoints - an overview of their purpose is given here: A verification extension defines the following in its descriptor: { \"extensionPointId\": \"lc.verificationprovider\", \"id\": \"string\", \"name\": \"string\", \"description\": \"string\", \"extensionPointVersion\": \"1.0\", \"configuration\": { \"endpoints\": { \"lc.verification.startverification\": \"string\", \"lc.verification.verifysegment\": \"string\", \"lc.verification.getmessagesbyculture\": \"string\", \"lc.verification.getsettingsschema\": \"string\" }, \"validationInputType\": \"string\", } } The extensionPointId must always be \"lc.verificationprovider\" The validationInputType defines which type of validation will happen based on the input document: BilingualDocument NativeSource NativeTarget NativeAnnotatedTarget The respective download URL(s) will be provided in the StartVerification request and the extension must download and store these resources as required. endpoints - the required endpoints for the verification extension, should be relative to your baseUrl. lc.verification.startverification - the endpoint used to start the verification operation. For ex: /verify/document. lc.verification.verifysegment - the endpoint used to verify a single segment. For ex: /verify/segment. lc.verification.getmessagesbyculture - the endpoint used to retrieve localized messages. For ex: /messages. lc.verification.getsettingsschema - the endpoint used to retrieve the settings schema. For ex: /schemas. There are four endpoints which the extension supports: StartVerification VerifySegment GetMessagesByCulture GetSettingsSchema There are described in a little more detail here: StartVerification This endpoint is called by Trados to initiate the document verification operation. Generally, a background job is started when this call is made and it returns 201(Created) The background job then prepares batches of verification messages which it then publishes to Trados via the Trados Cloud Platform API using the PublishMessages endpoint URL which is provided in the initial StartVerification request. Please see the API documentation for more details: StartVerification Example: POST https://your-app.com/verify/document The request for StartVerification is shown below: { \"inputResourceDetails\": { \"nativeFileUrl\": \"string\", \"bilingualDocumentUrl\": \"string\", \"bilingualDocumentVersion\": 0, \"nativeAnnotatedFileUrl\": \"string\", \"languageResourceTemplateId\": \"string\", \"verificationResourcePackageUrl\": \"string\", \"translationProfileId\": \"string\" }, \"callbackUrl\": \"string\", \"sourceLanguage\": \"string\", \"targetLanguage\": \"string\", \"publishMessageUrl\": \"string\", \"verifierSettings\": {}, \"sessionId\": \"string\" } inputResourceDetails - contains all relevant fields relating to the inputs for the verification operation - this includes: nativeFileUrl - a download URL for retrieving the native file. This is only used in the context of native file verification such as XML schema validation bilingualDocumentUrl - a download URL for retrieving the bilingual document (BCM) - this is used in the context of document validation bilingualDocumentVersion - the version of the document which is to be used for validation nativeAnnotatedFileUrl - a download URL for retrieving the native annotated file. This is only used in the context for native file verification where annotated information is also required. This annotated information can be used to determine segment IDs which would be used in reporting the error location languageResourceTemplateId - Id used when retrieving a Language Resource Template. Certain validations might require access to this. verificationResourcePackageUrl - a download URL for retrieving the verification resource package. This would be used in the context of native file validation, for instance, where a schema and any ancillary files might be needed for XML validation. translationProfileId - this ID can be used to retrieve TranslationEngine resources. An example of its use might be for a terminology verifier. callbackUrl - this endpoint is called when the validation operation is completed. sourceLanguage - source language code targetLanguage - target language code publishMessageUrl - endpoint called to publish batches of verification messages to the Trados Cloud Platform API verifierSettings - a JSON object representing any settings for this extension - these are extension specific and are defined in a JSON schema as detailed below sessionId - a unique ID associated with this particular verification request PublishMessages Body The PublishMessage endpoint should be called with batches of verification messages, as they are generated by the background job. The model used for defining these batches is shown below: { \"messages\": [ { \"id\": 1, \"messageType\": \"string\", \"verifier\": \"string\", \"level\": \"string\", \"segmentId\": \"string\", \"tagId\": \"string\", \"isSource\": \"bool\", \"messageArguments\": [ \"string\" ], \"segmentLocation\": { \"fileId\": \"string\", \"paragraphUnitId\": \"string\", \"segmentNumber\": \"string\" }, \"messageLocation\": { \"fromLocation\": 0, \"toLocation\": 0 } } ], \"sessionId\": \"string\" } messages - an array of messages Each message contains the following fields: id - a one-based index of the message generated by the extension. The first message should have an id of '1' and subsequent messages should be consecutively numbered 2,3,4 etc... messageType - the message type identifier. This should be a string ID which is pre-pended with the extension ID verifier - this will be the same as the extension ID level - error level of this message segmentId - the segment ID in which the error occurs tagId - the id of the tag which the error relates to isSource - a boolean indicating if the error/warning relates to the source or target messageArguments - an array of the arguments for the relevant message defined for this messageType. The message is usually stored as a resource with placeholders in the extension and is returned by the GetMessagesByCulture endpoint described below - for each placeholder in the message, an argument should exist in this array segmentLocation - the location of the segment messageLocation - the offsets within the segment representing the error span VerifySegment This endpoint is called by Trados to validate an individual segment. This endpoint responds with a collection of messages which relate to any issues found for this segment. Please see the API documentation for more details: VerifySegment Example: POST https://your-app.com/verify/segment The request is structured as follows: { \"fragment\": {}, \"languageResourceTemplateId\": \"4db79181-4ff4-4d01-8e33-44e7520ac6a6\", \"translationProfileId\": \"string\", \"verifierSettings\": {}, \"sourceLanguage\": \"string\", \"targetLanguage\": \"string\", \"segmentLocation\": { \"fileId\": \"string\", \"paragraphUnitId\": \"string\", \"segmentNumber\": \"string\" } } fragment - a json object containing a BCM fragment languageResourceTemplateId - Id of the language resource template to be requested for this session translationProfileId - Id used to retrieve translation engine resources verifierSettings - a json object containing the settings to be applied during the segment validation operation sourceLanguage - the source language code targetLanguage - the target language code segmentLocation - location details of the segment - these are: fileId - id of file paragraphUnitId - id of paragraph unit in file segmentNumber - the segment number within the paragraph (source/target) GetMessagesByCulture This endpoint is called by Trados to retrieve localized resources for the messages. The culture is specified in the call as a URL parameter. The app can support localized resources for various languages which will allow the messages to be displayed in the native language of the user in the UI. Please see the API documentation for more details: GetMessagesByCulture Example: GET https://your-app.com/messages/es-ES GetSettingsSchema This endpoint is called by Trados to retrieve the schema related to any settings which the extension supports. A note on schemas - once you define your settings schema for the extension, it should only be modified in a backwards compatible way, i.e. only adding of extra fields is allowed, not removing or renaming existing fields. Please see the API documentation for more details: GetSettingsSchema Example: GET https://your-app.com/schemas An example schema is shown below: { \"$schema\": \"https://json-schema.org/draft/2020-12/schema\", \"$id\": \"https://rws.com/verification-sample-extension-settings.schema.json\", \"title\": \"Length-check Verifier\", \"description\": \"Validates if the target segment length exceeds the source segment length by a given amount.\", \"type\": \"object\", \"properties\": { \"enabled\": { \"type\": \"boolean\", \"default\": true }, \"verificationResourcePackage\": { \"type\": \"object\", \"properties\": { \"platformSettingType\": { \"type\": \"string\", \"enum\": [ \"file\" ] }, \"platformSettingValue\": { \"type\": \"string\" } } }, \"dateTest\": { \"type\": \"string\", \"format\": \"date\" }, \"dateTimeTest\": { \"type\": \"string\", \"format\": \"date-time\" }, \"lengthCheckCharacterLimit\": { \"type\": \"integer\", \"default\": 20, \"minimum\": 1, \"maximum\": 1000 }, \"numberTest\": { \"type\": \"number\", \"default\": 10, \"minimum\": 1, \"maximum\": 1000 }, \"stringTest\": { \"type\": \"string\", \"default\": \"testSetting\", \"minLength\": 10, \"maxLength\": 100 }, \"gender\": { \"type\": \"string\", \"enum\": [ \"Female\", \"Male\" ] } }, \"required\": [ \"enabled\", \"dateTimeTest\", \"gender\", \"lengthCheckCharacterLimit\" ] } Relevant IDs which need to be passed from requests to responses The only ID which is passed through from the request to response is the sessionId. This is used in the StartVerification request and sent back in the PublishMessage request."
  },
  "articles/Extensibility/docs/development/Webhooks.html": {
    "href": "articles/Extensibility/docs/development/Webhooks.html",
    "title": "Webhooks",
    "summary": "Webhooks Apps can specify a list of webhooks that will be registered automatically when the app is installed on an account. That allows the app to specify a list of webhooks and consume them, allowing for asynchronous scenarios where the app can wait for events instead of polling constantly to check for a particular event or state improving performance both for the app and for Trados. Constraints Not all accounts have webhooks enabled. Installing of the app requiring webhooks will be disabled (grayed out in UI) on accounts that don't have webhooks enabled. Warning Webhooks require one of the following scopes to be delivered: TENANT or TENANT_READ. Setup The required list of webhooks must be specified in the descriptor in the webhooks property. webhooks is an array of URLs and corresponding event types. You can specify a single URL for all webhook event types, or one URL for each event type, or any combination. This is done for maximum flexibility so you can decide if you want to ingest all webhooks through a single endpoint or have multiple endpoints maybe by event type or category, etc. url can be an absolute URL or a path relative to basePath. Example of a webhooks property in the app descriptor: { ... \"webhooks\": [ { \"url\": \"/webhooks-endpoint\", \"evenTypes\": [ { \"eventType\": \"PROJECT.TASK.ACCEPTED\" }, { \"eventType\": \"PROJECT.TASK.CREATED\" } ] } ] ... } That example will subscribe to PROJECT.TASK.ACCEPTED and PROJECT.TASK.CREATED events and will receive these events on the <basePath>/webhooks-endpoint URL. Webhook events and payloads Webhooks for apps are sent in a batched format. The webhook payload description can be found in our Trados Cloud Platform API documentation. Webhooks are grouped in batches by callback URL, so it is likely that events from different tenants will be included in the same batch. It is the responsability of the app developer to handle the events from the batch accordingly to their accountId from the event body. Note Note: For Webhook Authenticity, ignore the described behavior in the above link and only consider the following chapter about Signature Validation. Signature Validation Unlike webhooks created in the UI through the Applications, webhooks that are declared in the descriptor are received using app signature. The endpoint that receives the webhook should treat these as signed with JWS, just as any other endpoint in the app. See Request Authentication page for more details."
  },
  "articles/Extensibility/docs/development/blueprints/Dot-Net-Blueprint.html": {
    "href": "articles/Extensibility/docs/development/blueprints/Dot-Net-Blueprint.html",
    "title": ".NET Blueprint",
    "summary": ".NET Blueprint Our .NET blueprint uses .NET 6.0, it can be run out of the box and it can even be registered in Trados immediately, although it will not provide any functional extensions. The only dependencies are on MongoDB and the NLog nugets. Getting the blueprint The blueprint is available in our GitHub repository: https://github.com/RWS/language-cloud-extensibility/tree/main/blueprints/dotNetAppBlueprint Solution structure To explain the code structure for the blueprint we can have an overview look in the Solution Explorer: The following areas are important for developers: Controllers: it covers the standard endpoints and also placeholders for the Extension specific controllers. DAL: it contains complete functionality for account management backed by MongoDB. Exceptions: it's used for returning errors to Trados. Models: it has the pre-built classes for all models from the contract. Services is where the main functionality can be concentrated. You can use it as a thin business layer. appsettings.json is where all your configurations go. descriptor.json is the file that describes the app functionality according to the contract. Dockerfile: it is used for debugging within the Docker containers. First steps Rename the solution and the project files, and then rename the namespaces to make them your own. Run it and ensure there are no problems before continuing with your customization. Go through all the files and take note of placeholders - methods without implementation, or comments saying, for example, \"implementation needed\" . The blueprint is a placeholder with as much plumbing in place as possible, but it still needs filling with your details. Depending on the extensions you are building, you may want to add one or more 'Service' classes that will have your business code. Some files are there as an example and if you don't need them, feel free to remove them. For example, there are two extension files: the AutomaticTaskController.cs and the TranslationController.cs. Most apps will implement only one extension type, so you may want to keep one and remove the other. appsettings.json The default configuration for ASP.NET Core. The blueprint provides a very minimalist file: { \"Logging\": { \"LogLevel\": { //\"Default\": \"Information\", \"Microsoft\": \"Warning\", \"Microsoft.Hosting.Lifetime\": \"Information\" } }, \"Authorization\": { \"JwksUri\": \"https://lc-api.sdl.com/public-api/v1/.well-known/jwks.json\", \"Issuer\": \"https://languagecloud.rws.com/\" }, \"baseUrl\": \"TODO: replace with a proper URL\", \"AllowedHosts\": \"*\", \"documentationUrl\": \"docUrl\", \"MongoDb\": { \"Connection\": \"mongodb://localhost:27017\", \"Name\": \"lc-blueprint-app\" } } The Logging section instructs ASP.NET on what logs to produce. Note that NLog will receive the filtered logs and then also apply its filters. The Authorization section provides the settings required by the app to authorize the requests from Trados. The baseUrl is used to populate the property with the same name from the descriptor. The AllowedHosts is a CORS configuration. By setting it to * we allow Trados to call and render the response in the UI. This is a future-proof configuration. The documentationUrl specifies the URL where to redirect for the full documentation. You need to specify a valid URL here. Alternatively you can return a full HTML page in the Documentation() action within the StandardController instead of using redirection. The MongoDb provides the connection string for MongoDB and also the database name. The database will be automatically created and doesn't need to be provisioned upfront. If you decide to go with another database, you can remove it. descriptor.json This file will be returned from the /descriptor endpoint as described in the API Contract. It is used to describe the functionality of the app, inform Trados of all the paths to the endpoints, provide names, descriptions, and also instruct what configuration settings are required from the user when it's installed. Database The blueprint is using MongoDB as a database engine. This is not a requirement and it can be substituted for any database. There is the IRepository interface that can be implemented with another concrete class that supports another database engine. POCO classes in the Entities folder might need adjustments as these are tailored for MongoDB. The next step would be to update the Startup.cs to change the service for IRepository to the new concrete class. Or if the Repository class is rewritten, no changes would be needed here. The health checks also need to be updated against the new database engine. Authentication and Authorization Most endpoints in the app need to be secured. The API Contract specifies which endpoints are secured and which are not. For example, /descriptor endpoint should not be secured as this is not sensitive information but it is valuable for manually invoking the endpoint and checking that the correct descriptor is returned. The [Authorize] attribute is already placed on all the required standard endpoints (action methods, in the StandardController.cs file). All the infrastructure code is already in place, and no other configuration is required. When implementing extension endpoints, since all extension endpoints need to be secured, you must make sure to place the [Authorize] attribute on all action methods (note that this is already done in the AutomaticTaskController.cs and the TranslationController.cs). Context Since the apps can be used on multiple accounts it's important to understand for which account the current call is being executed to get either Service User credentials or configuration settings. To get the current account you can use the GetTenantId extension method (from the Helpers folder) that is executed over the HttpContext object. This can be done in the Controller Action methods like this: string tenantId = this.HttpContext.GetTenantId(); If you need access to the identifier from other classes, you can either pass the identifier as a parameter in the request chain or access HttpContext through other mechanisms that are available in ASP.NET Core: Access HttpContext in ASP.NET Core. The blueprint provides access to Configuration data and Account Information out of the box. If you need more data to be stored, you can extend the Repository. Access to account data is available by injecting the IRepository interface and using one of the available methods, for example: Task<AccountInfoEntity> GetAccountInfoByTenantId(string tenantId); This will provide access to both the ConfigurationValues as well as the ClientCredentials. The ClientCredentials type provides the ClientId and ClientSecret that are used for making calls to the RWS Language Cloud API. Logs The blueprint is configured to use out of the box the standard Logging in .NET Core and ASP.NET Core approach configured with NLog to log to console. It will write only Info level logs by default. This can be changed in the nlog.config by changing from Info to Warn: <logger minLevel=\"${when:when='${environment:LOG_LEVEL}' != '':inner=${environment:LOG_LEVEL}:else=Info}\" writeTo=\"coloredConsole\" /> Note that you can also set the LOG_LEVEL environment variable to set to your desired minimum logging level. This works great when you need to change the logging level in a Docker container, you just send the environment settings when you start the container. Moreover, logging to files can easily be enabled from nlog.config by uncommenting the logFile target: <!--<logger minLevel=\"Debug\" writeTo=\"logFile\" />--> Health checks Trados will make sure that the app is up and running by making requests to the /health endpoint. The blueprint provides a default implementation where it checks that MongoDB is available. Additional changes can be implemented. The blueprint implements the ASP.NET Core Health Check. For more details check: Health checks in ASP.NET Core. Error reporting When you need to return an error to Trados, it's enough to raise an Exception of type AppException. The various constructor overloads allow for customization of the response. The plumbing in the blueprint will take care to transform the exception into an error payload according to the contract. Make sure to follow the contract specifications to send error codes that Trados can interpret. You are not limited to, and can send any codes, but that would mean that special cases will not be treated."
  },
  "articles/Extensibility/docs/development/blueprints/Dot-Net-Migration-Blueprint.html": {
    "href": "articles/Extensibility/docs/development/blueprints/Dot-Net-Migration-Blueprint.html",
    "title": ".NET Migration Blueprint",
    "summary": ".NET Migration Blueprint This blueprint should be used exclusively to upgrade your existing .NET add-on to an app while maintaining the compatibility with the old add-on installs. The migration blueprint can be found here. There are a couple of main points to consider when doing the upgrade: Descriptor Changes Descriptor Version First and foremost you'll need to change the descriptorVersion field to 1.4 in the descriptor JSON. This is the version that tells Trados Enterprise that your add-on has became an app and needs to be handled accordingly. Note In addition to descriptorVersion, the version field also needs to be updated to signal Trados Enterprise that there's a new descriptor available, as per usual. App Lifecycle Endpoint The old addonLifecycle standard endpoint needs to be replaced with the appLifecycle endpoint but at the same time the old route must be kept along the new route for backwards compatibility. New Lifecycle Events Some lifecycle events have been renamed while others have been added. INSTALLED The ACTIVATED event is now called INSTALLED. To ensure backwards compatibility with the old form, the migration blueprint knows to handle both. UNINSTALLED Similarly to the ACTIVATED event, the DEACTIVATED event is now called UNINSTALLED. Once again, the migration blueprint supports both. UPDATED To explain the purpose of the UPDATED event we have to reflect on the REGISTERED changes. Previously, Trados Enterprise was providing different pairs of credentials for each tenant that was installing the add-on. An app is now provided with a single pair of credentials just once, at registration. Since, your app has already been registered as an add-on, the REGISTERED event will no longer be sent so Trados Enterprise will provide the credentials in the same manner but via the new UPDATED event. The UPDATED event is sent by Trados Enterprise when the descriptorVersion: 1.4 is detected. When this event is invoked, the app(former add-on) needs to save the received pair of credentials(clientId/clientSecret) per registration and discard the old credentials saved per tenant installs. Trados Cloud Platform API Authentication If your add-on was integrating with Trados Cloud Platform API, the credentials used to authenticate came from the tenant installation(Accounts collection). With the new approach the credentials should now be retrieved from the app registration(AppRegistration collection). To access the registration credentials you can call the Rws.LC.AppBlueprint.Interfaces.GetRegistrationInfo method. For eg: AppRegistrationEntity appRegistration = await _appRegistrationRepository.GetRegistrationInfo().ConfigureAwait(false); ClientCredentialsEntity clientCredentials = appRegistration.ClientCredentials; For more details see the Trados Cloud Platform API guide. Summary To help you quickly implement the migration changes we gathered below a list of files that you need to look into: descriptor.json StandardController.cs AccountService.cs IAccountService.cs RegisteredUpdatedEvent.cs (formerly RegisteredEvent.cs) Repository.cs IRepository.cs AppRegistrationRepository.cs AppLifecycleEventEnum.cs"
  },
  "articles/Extensibility/docs/development/blueprints/Getting-Started.html": {
    "href": "articles/Extensibility/docs/development/blueprints/Getting-Started.html",
    "title": "Getting Started with Blueprints",
    "summary": "Getting Started with Blueprints Although you can start your app development from scratch, to help developers, we provide blueprints that have all the required components already included out of the box. Blueprints are available for .NET and Java. Can you develop an app without using the blueprints? Definitely! But how nice is it to have a base app up and running within an hour, then write all that boilerplate yourself? What the blueprints provide There is boilerplate to get an app service up and running in minutes, most notable being: Authentication is already implemented. Standard endpoints are implemented either completely or as stubs that need minimal code to be completed (for example: the health endpoint). Models from the contract are already implemented. Database integration is provided with support for MongoDB. If a different database will be used, then only changes to the Data Access Layer need to be implemented. Dockerfile provided if you want to get started quickly with Docker. Getting the blueprints The blueprints are available in our github repository: https://github.com/RWS/language-cloud-extensibility Next steps Once you decided that you want to start development using a blueprint and decided on the technology, follow the instructions on the page for that blueprint technology."
  },
  "articles/Extensibility/docs/development/blueprints/Java-Blueprint.html": {
    "href": "articles/Extensibility/docs/development/blueprints/Java-Blueprint.html",
    "title": "Java Blueprint",
    "summary": "Java Blueprint Our Java blueprint is a Spring Boot web application built on Java 11, it can be run out of the box and it can even be registered in Trados immediately, although it will not provide any functional extensions. Getting the blueprint The blueprint is available in our GitHub repository: https://github.com/RWS/language-cloud-extensibility/tree/main/blueprints/javaAppBlueprint Project structure To explain the code structure for the blueprint we can have an overview look at the Project tree: For a developer, the following areas may be of interest: web: this includes the controllers for standard endpoints and also placeholders for Extensions. persistence: it contains complete functionality for account management backed by MongoDB. exception: it's used for returning errors to Trados. transfer: it has the pre-built classes for all the models from the contract. service: this is where the main functionality can be concentrated. You can use it as a thin business layer. resources/application.yml is where all your configurations go. resources/descriptor.json is the file that describes the app functionality according to the contract. docker/Dockerfile: it is used for debugging in Docker containers. First steps First, let's make the blueprint yours by renaming the files and the configuration settings. A quick tip would be to search by these keywords: blueprint, rws. Some of the renaming actions you may want to consider: Rename the main package com.rws.lt.lc.blueprint Update the pom.xml <groupId>com.rws.lt.lc.app.blueprint</groupId> <artifactId>lc-blueprint-app</artifactId> <version>1.0-SNAPSHOT</version> <packaging>jar</packaging> <name>LC Blueprint App Service</name> Rename the main class BlueprintApplication Update the following places from application.yml application: name: lc.app.blueprint ... spring: application: name: lc-blueprint-app data: mongodb: ... database: lc-blueprint-app Update Dockerfile if you plan to use it Run it and ensure there are no problems before you continue with your customization. Go through all the files and take note of placeholders - methods without implementation, or TODOs. The blueprint is a placeholder with as much plumbing in place as possible, but it still needs filling with your details. Depending on the extensions you are building, you might want to add one or more 'Service' classes that will have your business code. Some files are placed there as examples, and if you don't need them, you can remove them. For example, there is the AutomaticTaskController.java for the lc.automatictask extension or TranslateController.java and TranslationEnginesController.java for the lc.mtprovider extension. Most apps will implement only one extension type, so you might want to keep one and remove the other. application.yml This is the default configuration for Spring Boot. The blueprint provides a rather simple file with various sections. The ones of interest are: ... # TODO: replace with a real URL baseUrl: \"replace-me\" ... spring: ... data: mongodb: authentication-database: admin database: lc-blueprint-app uri: mongodb://localhost:27017 ssl-enabled: false auto-index-creation: false ... # Logging logging: level: com.rws: INFO ... # TODO: replace with a real doc URL documentation.url: \"replace-me\" integration: public-api: basePublicApiV1Url: https://languagecloud.sdl.com/lc-api/public-api/v1 retrievePublicKeyByIdUrl: ${integration.public-api.basePublicApiV1Url}/.well-known/jwks.json/{kid} The baseUrl above is used to populate the property with the same name from the descriptor. The spring.data.mongodb provides the connection string for MongoDB and also the database name. The database will be created automatically and doesn't need to be provisioned upfront. If you decide to go with another database, you can remove it. The logging section sets the minimum log level for Lombok. The documentation.url specifies the address where to redirect for a full documentation set. You need to specify a valid URL here. Alternatively, you can return a full HTML page in the getDocumentation() action in the DocumentationController instead of using redirection. The integration.public-api section provides the settings required by the app to authorize the requests from Trados. descriptor.json This file will be returned from the /descriptor endpoint as described in the API Contract. It is used to describe the functionality of the app, inform Trados of all the paths to the endpoints, provide names and descriptions, and also instruct which configuration settings are required from the user during the installation. Database The blueprint is using MongoDB as its database engine. This is not a requirement, and it can be substituted for any database. There is the AccountSettingsRepository interface that extends the CrudRepository from Spring. The interface methods can be replaced or implemented in a concrete class. POJO classes in the domain package might need adjustments as these are tailored for MongoDB. The next step would be to replace the MongoConfiguration.javaclass with a configuration class for your database. Authentication and Authorization Most endpoints in the app need to be secured. The API Contract specifies which endpoints are secured and which are not. For example, the /descriptor endpoint should not be secured, as this is not sensitive information, but it is valuable for manually invoking the endpoint and checking that the correct descriptor is returned. By default, all the endpoints in the blueprint are secured except for the ones annotated with @GenericAuthorization. These endpoints are: /descriptor, /health and /documentation. All the infrastructure code is already in place, and no other configuration is required. When implementing extension endpoints, since all extension endpoints need to be secured, you must NOT annotate the action methods with @GenericAuthorization. You can check AutomaticTaskController.java, TranslateController.java, or TranslationEnginesController.java as references. Context Since the apps can be used on multiple accounts it's important to understand for which account the current call is being executed, to get either Service User credentials or configuration settings. To get the current account, you can use the getActiveAccountId() method (from the RequestLocalContext.java) that retrieves the value from the context object which is a ThreadLocal map. This can be done anywhere in the code as long as you are in an HTTP context: String tenantId = RequestLocalContext.getActiveAccountId(); The blueprint provides access to Configuration data and Account Information out of the box. If you need more data to be stored, you can extend the Repository. Access to account data is available by injecting the AccountSettingsRepository interface and using one of the available methods, for example: AccountSettings entity = accountSettingsRepository.findAccountSettings(tenantId); This will provide access to the configurations as well as to the clientCredentials. The clientCredentials type provides the clientId and clientSecret that are used for making calls to the Trados Cloud Platform API. Logs The blueprint is configured to use the Lombok logging approach out of the box. It will write only INFO level logs by default. This can be changed in the logback.xml by changing from INFO to WARN: <root level=\"INFO\"> <appender-ref ref=\"CONSOLE\" /> </root> You can enable the LOGGER anywhere in the code by annotating the classes with the @Slf4j annotation from Lombok. Example of logging: LOGGER.info(\"getDescriptor >>\"); Among other useful details, the logs will include by default the tenantId and the traceId which can be helpful when debugging. Note that you can also set the logging.level.com.rws environment variable to your desired minimum logging level. This works great when you need to change the logging level in a Docker container, as you just send the environment settings when you start the container. Health checks Trados will make sure that the app is up and running by making requests to the /health endpoint. The blueprint provides a default implementation that relies on the Spring HealthEndpoint. Additional changes can be implemented. Error reporting When you need to return an error to Trados, it's enough to raise an Exception of type AppException. The various constructor overloads allow for customization of the response. The plumbing in the blueprint will take care to transform the exception into an error payload according to the contract. Make sure to follow the contract specifications to send error codes that Trados can interpret. You are not limited to these, and you can send any codes, but that would mean that special cases will not be addressed."
  },
  "articles/Extensibility/docs/development/blueprints/Java-Migration-Blueprint.html": {
    "href": "articles/Extensibility/docs/development/blueprints/Java-Migration-Blueprint.html",
    "title": "Java Migration Blueprint",
    "summary": "Java Migration Blueprint This blueprint should be used exclusively to upgrade your existing Java add-on to an app while maintaining the compatibility with the old add-on installs. The migration blueprint can be found here. There are a couple of main points to consider when doing the upgrade: Descriptor Changes Descriptor Version First and foremost you'll need to change the descriptorVersion field to 1.4 in the descriptor JSON. This is the version that tells Trados Enterprise that your add-on has became an app and needs to be handled accordingly. Note In addition to descriptorVersion, the version field also needs to be updated to signal Trados Enterprise that there's a new descriptor available, as per usual. App Lifecycle Endpoint The old addonLifecycle standard endpoint needs to be replaced with the appLifecycle endpoint but at the same time the old route must be kept along the new route for backwards compatibility. New Lifecycle Events Some lifecycle events have been renamed while others have been added. INSTALLED The ACTIVATED event is now called INSTALLED. To ensure backwards compatibility with the old form, the migration blueprint knows to handle both. UNINSTALLED Similarly to the ACTIVATED event, the DEACTIVATED event is now called UNINSTALLED. Once again, the migration blueprint supports both. UPDATED To explain the purpose of the UPDATED event we have to reflect on the REGISTERED changes. Previously, Trados Enterprise was providing different pairs of credentials for each tenant that was installing the add-on. An app is now provided with a single pair of credentials just once, at registration. Since, your app has already been registered as an add-on, the REGISTERED event will no longer be sent so Trados Enterprise will provide the credentials in the same manner but via the new UPDATED event. The UPDATED event is sent by Trados Enterprise when the descriptorVersion: 1.4 is detected. When this event is invoked, the app(former add-on) needs to save the received pair of credentials(clientId/clientSecret) per registration and discard the old credentials saved per tenant installs. Trados Cloud Platform API Authentication If your add-on was integrating with Trados Cloud Platform API, the credentials used to authenticate came from the tenant installation(accountSettings collection). With the new approach the credentials should now be retrieved from the app registration(appRegistration collection). To access the registration credentials you can call the com.rws.lt.lc.blueprint.persistence.findFirst method. For eg: AppRegistration entity = appRegistrationRepository.findFirst(); ClientCredentials clientCredentials = entity.getClientCredentials(); For more details see the Trados Cloud Platform API guide. Summary To help you quickly implement the migration changes we gathered below a list of files that you need to look into: descriptor.json LifecycleController.java UpdatedEvent.java AppLifecycleEvent.java AccountSettingsService.java AccountSettingsAtomicRepository.java AccountSettingsAtomicRepositoryImpl.java AccountSettingsRepository.java"
  },
  "articles/Extensibility/docs/development/blueprints/Testing-with-Docker.html": {
    "href": "articles/Extensibility/docs/development/blueprints/Testing-with-Docker.html",
    "title": "Testing with Docker",
    "summary": "Testing with Docker This guide is mainly aimed at developers who want to deploy the app within a Docker container. Throughout the guide, we will see how we can run and test the app behavior when containerized. Before continuing here, we recommend reading the basic testing guide. The only additional prerequisite to Ngrok and MongoDB (which we mention in the basic guide) is Docker Desktop. You can find a setup guide here. Note Please note that Docker Desktop is no longer free for large businesses. Docker files Each of our blueprints include a Dockerfile: .NET blueprint Java blueprint The Dockerfile contains instructions based on which Docker will build the images. No changes should be required to these files. Configuring Mongo Before proceeding to run the app from a Docker container, there are a few configuration changes needed for MongoDB. Because a Linux Docker container can be considered as a VM, and communicating from your container to your host machine cannot be done through localhost, you need to allow MongoDB connections on your machine IP, so that the application from your container can connect to it from an \"external\" machine. Warning This might open your database to access from outside your machine if your firewall is not configured correctly or installed. To configure your MongoDB follow these steps: Open CLI and run this command: ipconfig Copy the IPv4 Address IP address. Note - your IP can change depending on your network settings, and you might need to update it from time to time. Go to your MongoDB /bin location (usually 'C:/Program Files/MongoDB/Server/<version>/bin'), open mongod.cfg as Administrator and add the copied address to the bindIp configuration setting. For example: ... net: port: 27017 bindIp: 127.0.0.1, <copiedIPAddress> ... Save mongod.cfg From Task Manager navigate to the Services tab and search for 'MongoDB'. Right click and select Restart. This is needed so that the previous changes take effect. Using the same IP address, edit the blueprint's Mongo configuration settings, as follows: appsettings.json for the .NET blueprint { ... \"MongoDb\": { \"Connection\": \"mongodb://<copiedIPAddress>:27017\", \"Name\": \"lc-blueprint-app\" } } application.yml for the Java blueprint ... spring: ... data: mongodb: ... uri: mongodb://<copiedIPAddress>:27017 ... ... Running apps in containers There may be many ways of running applications in Docker containers. Below is a suggestion for each of our blueprints (.NET and Java). .NET blueprint The .NET blueprint comes with Visual Studio Docker Support enabled. See Rws.LC.AppBlueprint.csproj: <Project Sdk=\"Microsoft.NET.Sdk.Web\"> <PropertyGroup> ... <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS> </PropertyGroup> ... </Project> To run the solution from a container, follow these steps: Open Docker Desktop. From Visual Studio, select the Docker option from the Run dropdown menu. When running it for the first time, it may take a while to create the image. Once it's done, the Containers window will open. Here you can see the details and the logs of your running containers. You can also check the container logs in Docker Desktop. Check that the application is running correctly by performing a GET request to your descriptor endpoint. For example: GET http://localhost:5000/v1/descriptor Java blueprint For the Java blueprint, we are going to explicitly create a Docker image and run it with Docker Desktop. To achieve this, you need to: Run the Maven package command, so you generate the .jar file for the blueprint project. Make sure that the .jar file was generated in the /target folder. By default, it is called lc-blueprint-app-1.0-SNAPSHOT.jar. Copy the .jar file into the same directory with the Dockerfile > /src/main/docker. Build the Docker image by using the build command: docker build --tag <image_name> <blueprint_location>/lc-blueprint-app-public/src/main/docker Open Docker Desktop and search for the image by the <image_name> you previously set (java_bp in this example). Click RUN and bind the exposed ports to localhost, as follows: Check that the application is running correctly by performing a GET request to your descriptor endpoint. For example: GET http://localhost:5000/v1/descriptor"
  },
  "articles/Extensibility/docs/development/blueprints/Testing.html": {
    "href": "articles/Extensibility/docs/development/blueprints/Testing.html",
    "title": "Testing",
    "summary": "Testing This guide explains the ways we can test the app from our local environment. This will help with solving the potential bugs or issues before deploying the app. Prerequisites: Ngrok MongoDB Ngrok Ngrok exposes local servers to the public internet over secure tunnels. The app endpoints need to be public for Trados to find them. You can find a quick guide on how to install and set up Ngrok here. Usage Find the port on which the app runs in the configuration files: launchSettings.json for the .NET blueprint { ... \"Rws.LC.AppBlueprint\": { ... \"applicationUrl\": \"http://localhost:5000\" } } application.yml for the Java blueprint ... server: port: 5000 ... Open a Command-line tool (for example cmd, PowerShell), navigate to your Ngrok location, and run this command for your port: ngrok http 5000 Configuration After having started a new session, you can find the exposed URLs in the Command-line. Copy the URL that uses https. For example: Locate the baseUrl setting in the configuration files and replace it with the copied URL: appsettings.json for the .NET blueprint application.yml for the Java blueprint Testing Although you could access the descriptor URL from a browser, we recommend using a testing client like Postman to perform the GET request to your descriptor URL, namely https://<ngrokURL>/<descriptorPath>. For example: GET https://47b6-78-96-152-25.ngrok.io/v1/descriptor If you have problems accessing the URL, you can try running Ngrok using one of these alternative commands: ngrok http 5000 -host-header=\"localhost:5000\" ngrok http https://localhost:5000 -host-header=\"localhost:5000\" Make sure the descriptor response contains the correct value for the baseUrl field. Register the app in Trados using the URL provided by Ngrok. Note You can restart the app application anytime while running a Ngrok session, without having to start a new session. MongoDB We recommend using MongoDB as it is free and fairly easy to use. For testing purposes, the community version should be enough. The installation package should also include the MongoDB Compass Community application which is the user interface for your database. Here we can see the collections with the documents inserted by the app at runtime. For example: You can edit the Mongo settings in the configuration files of the blueprints: appsettings.json for the .NET blueprint { ... \"MongoDb\": { \"Connection\": \"mongodb://localhost:27017\", \"Name\": \"lc-local-appblueprint\" } } application.yml for the Java blueprint ... spring: ... data: mongodb: authentication-database: admin database: lc-blueprint-app uri: mongodb://localhost:27017 ssl-enabled: false auto-index-creation: false ... Warning If you decide to use a different database, you should also modify your code accordingly. If you plan to package your app into a Docker container, here is a dedicated article for Testing with Docker."
  },
  "articles/Extensibility/docs/development/samples/Dot-Net-Samples.html": {
    "href": "articles/Extensibility/docs/development/samples/Dot-Net-Samples.html",
    "title": ".NET Samples",
    "summary": ".NET Samples We create .NET samples to demonstrate basic implementations of specific extensions. They serve as examples for common tasks related to that extension. These samples are developed using the provided .NET Blueprint. For testing please see the guidelines from the Blueprints section: Testing and Testing with Docker. Machine Translation You can find the sample in our GitHub repository here. It provides an implementation for the Google Machine Translation. But you can run it using a built-in mock, so there is no need to create a Google account to test it out. For enabling the mock please update the appsettings.json: \"mockExtension\": { \"enabled\": true // will enable the mock instead true google integration }, The sample can be run out of the box with the same requirements as for the blueprint, a local Mongo database. For different setups please see the blueprint and testing articles as you'll need to adjust your configuration."
  },
  "articles/Extensibility/docs/development/samples/Java-Samples.html": {
    "href": "articles/Extensibility/docs/development/samples/Java-Samples.html",
    "title": "Java Samples",
    "summary": "Java Samples We create Java samples to demonstrate basic implementations of specific extensions. They serve as examples for common tasks related to that extension. These samples are developed using the provided Java Blueprint. For testing please see the guidelines from the Blueprints section: Testing and Testing with Docker. Machine Translation You can find the sample in our GitHub repository here. It provides an implementation for the Google Machine Translation. But you can run it using a built-in mock, so there is no need to create a Google account to test it out. For enabling the mock please update the application.yml: mockExtension: enabled: true # will enable the mock instead true google integration The sample can be run out of the box with the same requirements as for the blueprint, a local Mongo database. For different setups please see the blueprint and testing articles as you'll need to adjust your configuration."
  },
  "articles/LCPublicAPI/api/Data-Bridge-API.v1.html": {
    "href": "articles/LCPublicAPI/api/Data-Bridge-API.v1.html",
    "title": "Data Bridge API Documentation",
    "summary": " View Documentation Fullscreen"
  },
  "articles/LCPublicAPI/api/Global-Public-API.v1.html": {
    "href": "articles/LCPublicAPI/api/Global-Public-API.v1.html",
    "title": "Global Public API Documentation",
    "summary": " View Documentation Fullscreen"
  },
  "articles/LCPublicAPI/api/Public-API.v1.html": {
    "href": "articles/LCPublicAPI/api/Public-API.v1.html",
    "title": "Public API Documentation",
    "summary": " View Documentation Fullscreen"
  },
  "articles/LCPublicAPI/api/Webhooks.v1.html": {
    "href": "articles/LCPublicAPI/api/Webhooks.v1.html",
    "title": "Extensibility API Documentation",
    "summary": " View Documentation Fullscreen"
  },
  "articles/LCPublicAPI/docs/API-rate-limits.html": {
    "href": "articles/LCPublicAPI/docs/API-rate-limits.html",
    "title": "API rate limits",
    "summary": "API rate limits Trados Cloud Platform API enforces rate limits to prevent overuse and spikes of requests that could degrade the platform performance. The default limits are chosen as to cover the needs of most integrators, but there might be cases when these limits are insufficient. In this case you should contact support for help in increasing your account limits. Default Trados Cloud Platform API Rate Limits Note Please remember our current limits and that they are subject to change without notice. You must always rely on response headers and never hardcode any limit values. Note Daily limits are calculated in a fixed time window, that is reset nightly at 00:00 UTC. Each tenant is entitled to: Up to 10 API requests per second. Up to 200 API requests per minute. Up to 200 000 API requests per day. Projects Rate Limits For Create Project Operation: each tenant is entitled to: Up to 2 API requests per second. Up to 10 API requests per minute. Up to 500 API requests per day. Export Quote Rate Limits For Export Quote Report: each tenant is entitled to: Up to 2 API requests per second. Up to 10 API requests per minute. Up to 1000 API requests per day. Import / Export Translation Memory limits: Up to 2 API requests per second. Up to 10 API requests per minute. Up to 2000 API requests per day. Project Files Rate Limits For each of the API operations listed below: Add Source File Download Source File Version Download Exported Target File Version Download Target File Version Add Source File Version Add Target File Version Import Target File Version each tenant is entitled to: Up to 5 API requests per second. Up to 200 API requests per minute. Up to 5000 API requests per day. Rate Limit verification endpoint Individual rate limits can be consulted below: List Rate Limits Rejection response In case a request is blocked or rejected the following details are sent to the Client: Error Response Status Code: TOO_MANY_REQUESTS (429, \"Too Many Requests\"). Example of a response message: { \"errorCode\": \"TOO_MANY_REQUESTS_EXCEPTION\", \"message\": \"Quota exceeded. Please check X-RateLimit-Reset response header\", \"details\": [] } Response headers can provide more details: X-RateLimit-Limit: the limit that was exceeded. For example, the value \"2\" represents the available quota. It does not provide the type of limit that has been exceeded, for those details the X-RateLimit-Reset and X-RateLimit-Policy should be used (for deciding when to retry the call). X-RateLimit-Reset: the exact moment in time when the Client can resume activity. This is datetime in RFC-1123 format, for example: \"Tue, 3 Jun 2008 11:05:30 GMT\". X-RateLimit-Remaining: the value is always \"0\". This is reserved for future enhancements. X-RateLimit-Policy: the name of the Rate Limit policy that was violated, made up by the operation and the time interval. Please see also the List Rate Limits. Implementation recommendations Unless it's a time-critical scenario, don't make requests in parallel. It is better to keep all the requests in sequence. It's important to handle responses with the HTTP Status 429. There are multiple approaches to handle it and a simple strategy would be: Expect the HTTP code (429) Block all the requests, and wait until X-RateLimit-Reset Try again."
  },
  "articles/LCPublicAPI/docs/Authentication.html": {
    "href": "articles/LCPublicAPI/docs/Authentication.html",
    "title": "Authentication",
    "summary": "Authentication We recommend using the provided Postman Collection to get started. Base API URL The base API address is https://api.{REGION_CODE}.cloud.trados.com/public-api/v1/. Note Check the Multi-Region page for regional API details. Authorization headers When making any call to the Trados Cloud Platform API, make sure you provide the following Header information: Authorization = access token X-LC-Tenant = tenant ID Also note that the Authorization header should use the Bearer schema, for example: Authorization: Bearer {{token}} How do I find the tenant ID? A service user can be part of only one account. If you're not sure what the tenant ID is for a service user, you can: Log in to the Trados UI, and make sure to select the same account where the service user was created. In the top right-hand corner, select your profile, and then select Manage Account. In the Account Information tab, check the value for Trados Account ID. Note There are 2 identifiers that might be confused. The identifier you need looks something like this: 2ef3c10e74fc39104e633c11. Generating the Bearer Token For generating the token, Trados Cloud Platform API uses the Auth0 authorization server (https://sdl-prod.eu.auth0.com/oauth/token) and the client credentials flow. The request to Auth0 can be done using JSON or URL Form Encoded. There is no difference between them, so you can choose whichever best suits you in terms of code. Here are some example payloads for both approaches: POST to https://sdl-prod.eu.auth0.com/oauth/token with Content-Type: application/json: { \"client_id\": \"{{the client ID for the application}}\", \"client_secret\": \"{{the Client Secret for the application}}\", \"grant_type\": \"client_credentials\", \"audience\":\"https://api.sdl.com\" } Alternatively, you can POST to https://sdl-prod.eu.auth0.com/oauth/token with Content-Type: application/x-www-form-urlencoded: client_id={{the Client ID for the application}}&client_secret={{the Client Secret for the application}}&grant_type=client_credentials&audience=https://api.sdl.com The response will be a JSON that contains the token, for example: { \"access_token\": \"eyJhbGciO....4NXz8TXatw\", \"expires_in\": 86400, \"token_type\": \"Bearer\" } The token is provided in the access_token property. This is then used to make authenticated calls to the Trados Cloud Platform API by using the Authorization header, and the X-LC-Tenant header: Authorization: Bearer {{access_token}} X-LC-Tenant: {{tenantId}} Token management The previous example of an Auth0 response body that contains the access_token, also contains an expiry value \"expires_in\": 86400. That property informs the service of how long the token is valid for. An application should use this value to cache the token for that duration minus a few minutes (to avoid clock drift issues). The application is responsible for getting a fresh token once the token is about to expire, by using the same mechanism described above. Note While it's technically possible to get a fresh token for every single call, there is no reason to do so, and the calling application IP risks to be blocked by Auth0 as it might consider it a DoS attack. Warning Please limit the number of requests for the Bearer token to a maximum of 16 per day. It's acceptable to exceed this limit only if you need to deploy multiple versions of your application, in a single day. Token caching behavior Since Auth0 returns tokens with a 24-hour expiry, a well-implemented integration should typically only make a single Auth0 token request per day. However, additional token requests may occur in the following scenarios: Multiple application instances: Each instance holds its own cache, so multiple instances of the same application will each request their own token. Application restarts: Stopping or restarting the application will destroy the cache and the bearer token, resulting in a new call to Auth0 upon restart. Note The 16 requests per day limit refers specifically to Auth0 token requests, not to API calls. You can make many more API calls (up to the rate limits) using a single cached token."
  },
  "articles/LCPublicAPI/docs/Basic-project-creation-flow.html": {
    "href": "articles/LCPublicAPI/docs/Basic-project-creation-flow.html",
    "title": "Basic project creation flow",
    "summary": "Basic project creation flow Please read carefully about authentication and prerequisites , and take into consideration that some steps might be done by Trados engineering. Details about what are the rate limits for Trados Cloud Platform API can be found on API rate limits page. Additional information regarding file and project size limits can be found here. Note This small Postman collection can help you get started with the basic project creation flow. For details on Postman setup please see the main Postman page. In the Create Project endpoint body, the projectTemplate value should be replaced with a valid templateId. From that point on all the necessary identifiers will be automatically populated throughout Postman. Check the Multi-Region page for regional API details. Steps to create a basic translation project: Create Project Add project source file Start Project List Project's Tasks List Project Target Files Download File Complete Project List Projects 1. Create Project Creates a new project. Endpoint: POST /projects For running this endpoint you need to supply the required project details (body tab in Postman): Note POST https://api.{REGION_CODE}.cloud.trados.com/public-api/v1/projects { \"name\": \"Name of the Project\", \"description\": \"Test Project\", \"dueBy\": \"2021-09-04T08:14:05.858Z\", \"projectTemplate\": { \"id\": \"xxxxxxxxxxxxxxxxxxxxxxxx\" // Provided by RWS }, \"languageDirections\": [ { \"sourceLanguage\": { \"languageCode\": \"en-US\" }, \"targetLanguage\": { \"languageCode\": \"fr-FR\" } } ] } Source and Target Language Codes can be obtained from here. The API should respond with: HTTP Status Code: 201 Created. Body - your project details consisting of projectId, project name, language direction, location and other optional fields. Example: { \"id\": \"xxxxxxxxxxxxxxxxxxxxxxxx\", // The project identifier. \"name\": \"Name of the Project\", \"languageDirections\": [ { \"sourceLanguage\": { \"languageCode\": \"en-US\", \"englishName\": \"English (United States)\" }, \"targetLanguage\": { \"languageCode\": \"fr-FR\", \"englishName\": \"French (France)\" } } ], \"location\": { \"id\": \"xxxxxxxxxxxxxxxxxxxxxxxx\", \"name\": \"Project Location\" } } Scenario: If your company has multiple divisions, you can imagine a hierarchy like this: YOUR COMPANY Marketing Division Management Division HR Division If you want to create projects for different divisions, this can be done by using the location parameter, which will be added in the body. When location is not set, the system will try to create the resource in the higher folder in the hierarchy, the Root folder. It might not have access to that folder and the request will fail with forbidden error. { \"name\": \"Name of the Project\", \"description\": \"Test Project\", \"dueBy\": \"2021-09-04T08:14:05.858Z\", \"projectTemplate\": { \"id\": \"xxxxxxxxxxxxxxxxxxxxxxxx\" // Provided by RWS }, \"languageDirections\": [ { \"sourceLanguage\": { \"languageCode\": \"en-US\" }, \"targetLanguage\": { \"languageCode\": \"fr-FR\" } } ], \"location\": \"xxxxxxxxxxxxxxxxxxxxxxxx\" // Provided by RWS } Using this request your project will be created in the specified Division and it will be visible only there. Detailed information about location and folders can be found on the How to use location and folders page. More details about this endpoint can be found here. 2. Add Source File Adds a source file to the project. Endpoint: POST /projects/{projectId}/source-files For running this endpoint you need to: Replace {projectId} from the URL with the identifier received from the Create Project endpoint response: Note POST https://api.{REGION_CODE}.cloud.trados.com/public-api/v1/projects/{projectId}/source-files Add the file to the request body. Complete the details from Body tab - Properties field. Properties field: { \"language\": \"en-US\", \"type\": \"native\", \"role\": \"translatable\", \"name\": \"nameOfTheFile.extension\" } Responses: HTTP Code 201 Created. Body - a list with the identifier, name and role of the file. More details about this endpoint can be found here. 3. Start Project Starts a project. Endpoint: PUT /projects/{projectId}/start For running this endpoint you need to: Replace {projectId} from the URL with the identifier received from the Create Project endpoint response: Note PUT https://api.{REGION_CODE}.cloud.trados.com/public-api/v1/projects/{projectId}/start Responses: HTTP Code 202 Accepted More details about this endpoint can be found here. 4. List Project's Tasks List the tasks of a specific project. If all the tasks have the status completed, all the files are translated. Endpoint: GET /projects/{projectId}/tasks For running this endpoint you need to: Replace {projectId} from the URL with the identifier received from the Create Project endpoint response: Note GET https://api.{REGION_CODE}.cloud.trados.com/public-api/v1/projects/{projectId}/tasks?fields=taskType,status Use ?fields=taskType if you want to observe the task name. Responses: HTTP Code 200 Ok. Body - a list with task identifier and status. Example: { \"items\": [ { \"id\": \"613f621fe5ed2804ba31870e\", \"status\": \"completed\", \"taskType\": { \"id\": \"607932f25c7cc701241f0f60\", \"key\": \"scan\", \"name\": \"File Type Detection\" } }, { \"id\": \"613f623040d9943308ef7c3b\", \"status\": \"completed\", \"taskType\": { \"id\": \"607932f3ce8af15851b70205\", \"key\": \"convert\", \"name\": \"File Format Conversion\" } }, ... ], \"itemCount\": 11 } More details about this endpoint can be found here. 5. List Project Target Files Retrieves the target fileId for a project and the latest version for the translated file. Endpoint: GET /projects/{projectId}/target-files For running this endpoint you need to: Replace {projectId} from the URL with the identifier received from the Create Project endpoint response: Note GET https://api.{REGION_CODE}.cloud.trados.com/public-api/v1/projects/{projectId}/target-files?fields=latestVersion Responses: HTTP Code 200 Ok. Body - a list with objects that contain: source file and target file identifiers source and target languages Example: { \"items\": [ { \"id\": \"613f623ae5ed2804ba318a40\", // This is the target file identifier. \"latestVersion\": { \"id\": \"613f628540d9943308ef8497\", // This is the file version identifier. \"type\": \"native\" } }, { \"id\": \"613f623ae5ed2804ba318a43\", \"latestVersion\": { \"id\": \"613f628a40d9943308ef84cd\", \"type\": \"native\" } } ], \"itemCount\": 2 } More details about this endpoint can be found here. 6. Download File Downloads the translated file. Endpoint: GET /projects/{projectId}/target-files/{targetFileId}/versions/{fileVersionId}/download For running this endpoint you need to: Replace {projectId} from the URL with the identifier received from the Create Project endpoint response Replace {targetFileId} from the URL with the identifier received from the List Project Target Files endpoint response Replace {fileVersionId} from the URL with the identifier received from the List Project Target Files endpoint response Note GET https://api.{REGION_CODE}.cloud.trados.com/public-api/v1/projects/{projectId}/target-files/{targetFileId}/versions/{fileVersionId}/download Responses: HTTP Code 200 OK. Body - the translated file. The file can be also saved from Save Response option. More details about this endpoint can be found here. 7. Complete Project Marks a project as completed. Endpoint: PUT /projects/{projectId}/complete For running this endpoint you need to: Replace {projectId} from the URL with the identifier received from the Create Project endpoint response Note PUT https://api.{REGION_CODE}.cloud.trados.com/public-api/v1/projects/{projectId}/complete Responses: HTTP Code 204 No Content. More details about this endpoint can be found here. 8. List Projects Retrieves a list of all the projects in the account. Endpoint: GET /projects For running this endpoint make a request to: Note GET https://api.{REGION_CODE}.cloud.trados.com/public-api/v1/projects Responses: HTTP Code 200 OK. Body - a list of projects with details consisting of project identifier, project name, language direction, location and other optional fields Example: { \"items\": [ { \"id\": \"xxxxxxxxxxxxxxxxxxxxxxxx\", \"name\": \"Translation Project 1\", \"languageDirections\": [ { \"sourceLanguage\": { \"languageCode\": \"en-US\", \"englishName\": \"English (United States)\" }, \"targetLanguage\": { \"languageCode\": \"fr-FR\", \"englishName\": \"French (France)\" } } ], \"location\": { \"id\": \"xxxxxxxxxxxxxxxxxxxxxxxx\", \"name\": \"Project Location\" } }, { \"id\": \"xxxxxxxxxxxxxxxxxxxxxxxx\", \"name\": \"Translation Project 2\", \"languageDirections\": [ { \"sourceLanguage\": { \"languageCode\": \"en-US\", \"englishName\": \"English (United States)\" }, \"targetLanguage\": { \"languageCode\": \"fr-FR\", \"englishName\": \"French (France)\" } } ], \"location\": { \"id\": \"xxxxxxxxxxxxxxxxxxxxxxxx\", \"name\": \"Project Location\" } } ], \"itemCount\": 2 } More details about this endpoint can be found here."
  },
  "articles/LCPublicAPI/docs/Create-projects.html": {
    "href": "articles/LCPublicAPI/docs/Create-projects.html",
    "title": "Create projects",
    "summary": "Create projects To create a project, you need to specify the following resources: A translation engine: determines which translation memories, MT engines and termbases should be used in the project A file processing configuration: determines which translatable file types this project should support, and the specific configuration of those file types A pricing model: the set of rules based on which the project quote is calculated A workflow: the sequence of steps the project goes through from inception to completion and the assignees for each step Instead of specifying every resource separately, you can also specify a project template, which brings together all the elements needed during project creation: a translation engine, a file processing configuration, a pricing model, and a workflow. You must define your project resources before you start creating your project. This API version does not allow any POST requests to create project resources. Your project resources must be created from the Trados UI beforehand. Create projects from scratch You can create projects from scratch, which means that you must add all the project resources (all their identifiers) above to your project, one by one. You cannot specify custom fields and project settings directly via the Trados Cloud Platform API. These can only be configured within a project template from the Trados UI. Therefore, if you want to include custom fields and project settings in your project, you must create projects from a project template which is already configured in the Trados UI. 1. Decide which project resources you want to use. Make a GET request to the following resource endpoints and identify the identifiers of the resources you want to include in your project: /translation-engine required /file-processing-configuration required /workflow required /pricing-model optional /custom-field-definitions optional 2. Decide which language pairs (source - target) you want to use. Make a GET request to the /languages endpoint and identify the languageCode parameter values. 3. Decide where you want to save your project. When you create your project, you must save it in a location (or customer folder). You will need the locationId of that customer folder. To retrieve the locationId of a given customer folder, make a GET request to the /customers/{customerId} endpoint and check the locationId value in the response. If you do not specify a location, the project will be created in the Root folder. 4. Create your project. Make a POST request to the /projects endpoint. You must provide identifiers for all the required resources: translation engine, file processing configuration and workflow. Each resource object has a strategy parameter you must specify in the request body. The strategy parameter has 2 available values: copy and use. Trados recommends that you choose the copy value, which means that you include a copy (clone) of your resource in the project. If you choose the use value, then the actual resource is included in your project. Note Issues may arise when strategy=use because you have no control over how the resource is updated from the other places where it is being used. Make sure that you remember the value of the project id parameter in the response. You will need it for tracking your project, interacting with tasks, and completing projects. 5. Add your project files. Make a POST request to the /projects/{projectId}/source-files endpoint. You can add both translatable files and reference files (by specifying the role property), and various file formats (by specifying the type property - native/bcm/sdxliff). You must provide the language of your source file, and, optionally, the values of the targetLanguages and path elements. 5.1 Perfect Match (optional) At this point you can make use of the PerfectMatch feature. You can read more about it here. 6. Start your project. Make a PUT request to the /projects/{projectId}/start endpoint. Create projects based on a template You can create projects based on a project template already configured from the Trados UI, which means that you must only add a project template (its identifier) to your project. All the resources in your project template are automatically included in your project. 1. Decide which project template you want to use. Make a GET request to the /project-templates endpoint. Remember the project template id parameter in the response. 2. Decide which language pairs (source - target) you want to use. A project template may include more languages than you need. If this is the case, you can keep only the languages of interest. Make a GET request to the /languages endpoint and identify the languageCode parameter values. 3. Decide where you want to save your project. A project template is saved in a location or a customer folder. Most of the times, when you create your project, you want to save it in the same location (customer folder) as the project template it is based on. You will need the locationId of that customer folder. To retrieve the locationId of a given customer folder, make a GET request to the /customers/{customerId} endpoint and check the locationId value in the response. 4. Create your project. Make a POST request to the /projects endpoint. Provide the project template id and the location id. Make sure that you remember the value of the project id parameter in the response. You will need it for tracking your project, interacting with tasks, and completing projects. 5. Add your project files Make a POST request to the /projects/{projectId}/source-files endpoint. You can add both translatable files and reference files (by specifying the role property), and various file formats (by specifying the type property - native/bcm/sdxliff). You must provide the language of your source file, and, optionally, the values of the targetLanguages and path elements. 5.1 Perfect Match (optional) At this point you can make use of the PerfectMatch feature. You can read more about it here. 6. Start your project. Make a PUT request to the /projects/{projectId}/start endpoint. Restrict file downloads for a project To restrict file downloads for certain roles, you may create a project as usual and choose to: Use a project template that has the restriction enabled or Create a project from scratch Create the project as usual, but specify an additional boolean field named forceOnline in the project creation request: { \"name\": \"Restricted Project Name\", \"description\": \"Restricted Project Description\", ..., \"forceOnline\": true }"
  },
  "articles/LCPublicAPI/docs/Custom-Fields.html": {
    "href": "articles/LCPublicAPI/docs/Custom-Fields.html",
    "title": "Custom fields",
    "summary": "Custom fields Custom Fields allow associating custom data with a project. Custom Fields can be defined in the UI, and then listed and accessed using the List and Get endpoints. The Custom Field values are retrieved through the Project endpoints. Custom Field Definitions To list the available Custom Field Definitions make a GET request to the /custom-field-definitions endpoint. The response contains: the Custom Fields total count, and by default, the id and the name for each Custom Field. By specifying the fields query parameter, the other properties of these entities can be retrieved. To get a particular Custom Field Definition make a GET request to the /custom-field-definitions/{customFieldDefinitionId} endpoint, and specify the customFieldDefinitionId path parameter. The default fields for custom field are id and name, but the other fields can be seen by specifying them into fields query param. For example: id,key,description,type,defaultValue A default value can be specified on the Custom Field Definition, which will be applied to a project if no other value is specified when creating the project. Custom fields in Projects At project level, Custom Fields can be set either when creating a project or when updating one. Moreover, custom fields are exposed when users search for a project or list all projects. Creating projects with Custom Fields To create or update a project with Custom Fields, follow the instructions for creating/updating projects, but also populate the customFields property in the request payload. The key property is mandatory and must be specified for each Custom Field. Its value, however, is optional and the Custom Field Definition might contain a default value that will be applied if not otherwise specified. If the value doesn't correspond to the type of Custom Field selected, a validation message with a Bad Request status will be returned in the response. The value type can be checked in the Custom Field Definition in the type field, for ex: DATE, STRING, PICKLIST. When creating a project using a template, Custom Fields that are marked with isMandatory: true must be included in the create request and values set, if a default value is not specified. The following is an example for creating a project body with valid Custom Fields: Request: ... { \"name\": \"API project with valid custom fields\", \"projectTemplate\": { \"id\": \"60c1f06d1d8ff66537d674c3\" }, \"languageDirections\": [ { \"sourceLanguage\": { \"languageCode\": \"en-gb\" }, \"targetLanguage\": { \"languageCode\": \"fr-be\" } } ], \"location\": \"d1d6bd4e2ec14ab99e2ec41682553ac0\", \"customFields\": [ { \"key\": \"Custom_Field_Boolean_ps0xw\", \"value\": true }, { \"key\": \"Custom_Field_Long_Text_qq4olq\", \"value\": \"Test custom field\" } ] } ... Response: ... { \"id\": \"60fa9b729011f339266a2e3b\", \"name\": \"API project with valid custom fields\", \"languageDirections\": [ { \"sourceLanguage\": { \"languageCode\": \"en-GB\", \"englishName\": \"English (United Kingdom)\" }, \"targetLanguage\": { \"languageCode\": \"fr-BE\", \"englishName\": \"French (Belgium)\" } } ], \"location\": { \"id\": \"d1d6bd4e2ec14ab99e2ec41682553ac0\", \"name\": \"RWS\" }, \"customFields\": [ { \"id\": \"60c3539b06e09d00019c0a2d\" }, { \"id\": \"60c353ec06e09d00019c0a2f\" } ] } ... An example for creating a project with an invalid value set for a custom field: Request: ... { \"name\": \"API project with invalid custom fields\", \"projectTemplate\": { \"id\": \"60c1f06d1d8ff66537d674c3\" }, \"languageDirections\": [ { \"sourceLanguage\": { \"languageCode\": \"en-gb\" }, \"targetLanguage\": { \"languageCode\": \"fr-be\" } } ], \"location\": \"d1d6bd4e2ec14ab99e2ec41682553ac0\", \"customFields\": [ { \"key\": \"Custom_Field_Boolean_ps0xw\", \"value\": \"Test custom field\" //invalid value } ] } ... Response: This will have an HTTP code 400 Bad Request ... { \"message\": \"Invalid input on create project.\", \"errorCode\": \"invalidInput\", \"details\": [ { \"name\": \"project.customFields[0]\", \"code\": \"invalidInput\", \"value\": \"Test custom field\" } ] } ... Updating projects with Custom Fields To update the Custom Fields of a project make a PUT request to the /projects/{projectId} endpoint. Specify new values for the Custom Fields that need updating. Getting Custom Fields for projects To get the Custom Fields for a project, make a GET request to the /projects/{projectId} endpoint and request the desired fields in the fields query parameters: customFields.id,customFields.key,customFields.value. Similarly, this can be done when making a GET request to the /projects endpoint. Custom Fields in Project Templates Custom Fields can be defined in Project Templates. isMandatory on a Custom Field indicates that it must be populated when a project is created with that template. To get the Custom Fields for a project template, make a GET request to the /project-templates/{projectTemplateId} endpoint or a GET request to the /project-templates endpoint and specify the desired fields in the fields query parameters: customFields.id,customFields.key,customFields.value."
  },
  "articles/LCPublicAPI/docs/Developing-Language-Cloud-Add-Ons.html": {
    "href": "articles/LCPublicAPI/docs/Developing-Language-Cloud-Add-Ons.html",
    "title": "Developing Trados Cloud Platform Add-Ons",
    "summary": "TODO: Needs removing Developing Trados Cloud Platform Add-Ons Design Notes The developer can choose any development environment, programming language or hosting options, as long as the required set of APIs are implemented according to specification. Blueprints and samples, for getting to speed, are provided. When using the provided blueprint - either Java or .Net, some concerns will be already covered in the blueprint, like: logging health check authorization default handling of account and add-on lifecycle events Sample Dockerfile for containerizing the application Terminology The 3 big concepts that need to be clearly separated: Add-On - a REST API service implementing the API for Language Cloud Add-Ons Extension Point - a functionality from RWS Language Cloud that can be implemented by Add-On Services Extension - a new functionality for a given Extension Point, provided by an Add-On Service. An Add-On Service can implement multiple extensions for the same Extension Point, ex. offer 3 translation engines for the MT extension point. Add-On Descriptor The Add-On Descriptor is a JSON formatted document that describes an Add-On. The Stoplight documentation can be found at https://language-cloud-public-api-proposal.docs.stoplight.io/lc/api-docs/extensibility-api/models/addondescriptor. Fields are documented to explain their usage. The less documented feature is how to define extension endpoints. This is done under the configuration  endpoints element of an extension (in extensions). The path for each endpoint is defined for the property which is the name in the stoplight for that endpoint. Ex: \"configuration\":{ \"endpoints\":{ \"sdl.lc.extensionpoint.machinetranslationprovider.translate\":\"/translate\", \"sdl.lc.extensionpoint.machinetranslationprovider.engines\":\"/translation-engines\" } } baseUrl property in the descriptor sets the base path for all endpoints defined. All other URLs are relative to this. The descriptor should be accessible at an URL that starts with baseUrl, as it will be called on at scheduled intervals to check for updates. Endpoints When thinking about the endpoints that need to be implemented by the Add-On service, they are split into two: Standard endpoints Extension endpoints Standard endpoints are required to be implemented by all Add-On Services. These are operations that will be called on by the Add-On Management Service. Not all of them are required but it's recommended to provide them. Check in the Stoplight which are required (can be found in the documentation for the AddOnDescriptor model). Extension endpoints are implemented depending on the Extension Points supported by the Service. The list of standard endpoints and Extension endpoints (grouped by extension) can be found in Stoplight. In the previous image, which captures the endpoints for an Add-On from the Stoplight, are visible the list of standard endpoints, as well as the two endpoints under the \"Machine Translation Provider\" Extension Point. If the Add-On service is providing an Extension for that Extension Point, it must implement both endpoints (Translate and Get Translation Engines). The path for each extension endpoint is described in the Stoplight content and has the format of a namespace. Please see Stoplight for more details on each Extension Point. Add-On Lifecycle This section attempts to explain what is the order of the endpoints that should be expected to be invoked in the lifecycle of the Add-On Service. An ordinary Add-On registration and activation lifecycle should look like that: GET /descriptor is the very first endpoint that will be executed when the add-on owner tries to register it in Language Cloud. POST /addon-lifecycle will be the next in order, with an identifier of \"REGISTER\", meaning that the Add-On has been registered. From that moment on, administrators can activate the Add-On on their accounts. POST /addon-lifecycle will be again invoked when the Add-On is activated on an account. This time the payload will provide a \"tenantId\" (Account ID), and \"publicKey\" which will be used for validating future request. That data should be stored in the Add-On system. GET /configuration - will be invoked to get the list of configuration settings (including default values, current values) that need to be provided by the administrator that activated the Add-On on their tenantId. POST /configuration - will set the configuration values for the tenantId. Note: not all settings can be sent in a single request. There might be multiple requests setting different config values. The Add-On should keep these settings safe. Also note that this endpoint can be called any time after activation if the administrator decides to change any of the settings. The lifecycle for de-activation of the Add-On from an account: POST /account-lifecyle will notify the Add-On Service, by providing the identifier \"DEACTIVATED\". The tenantId, in this case will be provided in the header \"X-LC-Tenant\" which is standard for all request that are related to an account. The Add-On should delete any account related data. The lifecycle for un-registering an Add-On from RWS Language Cloud: POST /addon-lifecycle will be invoked with identifier \"UNREGISTERED\". If there are accounts that haven't been previously deactivated, they should be considered so, and all related data be deleted. There are also endpoints that can be called at any point in time: GET /descriptor - can be called before registration, during registration, after registration, on scheduled intervals, etc. GET /health - will be called during and after registration. It is scheduled to be checked periodically. GET /documentation - can be called at any time. Of course there are also the Extension endpoints which are invoked in the business life-cycle. Understanding the incoming request There are two types of endpoint invocations: Related to the Add-On - ex: registering, health checks, documentation, does not know and doesn't make sense to be related to a tenant Related to an account (tenant) - operations that only make sense in relation with a tenant: activating, getting/setting configurations, extensions Only the endpoints relating to an account are authenticated, as the authentication is account-bounded. The only exception is \"activating\" which will receive the public key for signature validation, which needs to be saved for that account. Two headers are defined in the Stoplight that need to be handled: TR_ID - represent the trace identifier that is sent from the RWS Language Cloud, and should be propagated through all the stacks and added to the logs. When making requests to RWS Language Cloud in the context of an extension, the same TR_ID should be used (if it's a synchronous operation) X-LC-Tenant - provided only for the endpoints which are related to an account. Provides the tenant ID (account ID) to which the request is related. Implementing extensions Extensions Points are defined in Stoplight, and are defined by a number of endpoints that together support an extension. For example the Extension Point \"Machine Translation Provider\" has two endpoints defined: /sdl.lc.extensionpoint.machinetranslationprovider.translate /sdl.lc.extensionpoint.machinetranslationprovider.engines Implementing these endpoints, will allow for the Add-On to provide the extension that implements support for \"Machine Translation Provider\" Extension Point. Note: the path for these endpoints does not necessary have to be the same as defined in the Stoplight. The path is configurable from the descriptor, and can be set to any path, under the base path that is also defined in the descriptor. Multiple Extensions can be implemented that support the same Extension Point. All that's needed is to define a set of endpoints for each Extension. Meaning, if you want to implement Extension Point \"Machine Translation Provider\", by providing 3 machine translation options, you'll need to create 3 sets of endpoints, which is 6 endpoints. In the descriptor, for each extension, you'll define which endpoints are used. Asynchronous endpoints Some extensions will require you to implement asynchronous endpoints. An example is the Automatic Task Extension: https://language-cloud-public-api-proposal.docs.stoplight.io/lc/api-docs/extensibility-api/automatic-task-type-provider/automatictasktypeexecutetask In this case the '/lc.automatictask.submit' endpoint will need to accept a task, execute it on a separate thread and then call the provided callback url with the result. The sequence diagram below explains this flow: Multitenancy Unless an Add-On is developed to be used only in Developers Account, Multitenancy must be supported. Primarily that means ensuring that data from one account does not transpire to another account. Sharing data between two accounts should be avoided. Requests that are account specific contain the header X-LC-Tenant, with the account ID. It can be used to store the data, compartmentalized by account, and also to filter the requested data. Security The Add-On Service should provide all endpoints with HTTPS support, with a minimum version of TLS 1.2. The scope of this is to protected client information from eavesdropping. Any stored data should be kept safe and used only for fulfilling the advertised actions. Data should be compartmentalized per tenant. Signature Validation The blueprints will provide mechanisms to simplify signature validation. Headers that are required for signature validation: X-LC-Transmission-Time - the transmission time in ISO-8601 format X-LC-Tenant - the account ID X-LC-Signature-Algo - the algorithm for signature generation. Currently the only valid value is SHA256withRSA . X-LC-Signature - the signature that needs to be validated Steps for signature validation: Get the previously stored public key for the given account ID (X-LC-Tenant). Generate a CRC32 checksum of the message body. part is composed of the request URL minus basePath, as defined in the descriptor. must begin with a slash \"/\". (All paths in Descriptor must start with a slash). Generate the concatenation | | | , where the - represents the value from the header, or calculated. | - is an actual character used for separating the values, and should be included in the final string. Validating the signature is done by verifying the signature using the public key and generated concatenation using the algorithm from X-LC-Signature-Algo. Health Checks The health endpoint will be invoked regularly to ensure the health of the Add-On Service. The only expected response is a HTTP code 200, any other code will be considered as a service failure. Any content will be ignored. Versioning Add-Ons should be designed with versioning in mind. Versioning is applied to the descriptor, allowing changing features in the Add-On without impacting users that might be using an older version of the Add-On. Things to consider: Multiple versions of the Add-On can point to the same endpoints only if the changes are compatible. If there are breaking changes in a new version of the Add-On (changes in the endpoint, changes in the models, changes in behaviour), new endpoints should be created for the new version. Version number is set in the descriptor field \"version\". It should follow * * Semantic Versioning principles, and should consist of no more then 4 numeric groups separated by dots, ex.: \"1.0\", \"1.3.5\". In order for new changes in the descriptor to be detected, the descriptor must have it's version incremented. Changes in the descriptor will not be automatically detected if the version is the same as the last one. Retiring older versions When an older version of the Add-On needs to be retired the following steps need to be taken: While deploying a new version with a new version number in the descriptor, the \"minimumVersion\" field should also be set to the minimum version that is still supported. It can also be set to the version that is being deployed - meaning that only this version will be supported. After deploying and getting the new version Published, a grace period of 30 days will be given to the users to update to the new version. In that period the older versions MUST be supported (the endpoints should be up, the functionality unchanged, etc.) After 30 days the old functionality can be decommissioned."
  },
  "articles/LCPublicAPI/docs/Export-quote-report.html": {
    "href": "articles/LCPublicAPI/docs/Export-quote-report.html",
    "title": "Export quote report",
    "summary": "Export quote report The export quote mechanism has been updated and it is now composed of three relevant endpoints. The old export quote endpoint is deprecated, you can read about it in this section What's new. The next endpoints would need to be executed in this specific order: To trigger a quote report generation for a given project, make a POST request to the /projects/{projectId}/quote-report/export endpoint. If successful, the response will contain an \"Accepted\" status, and you can proceed to the next step. To verify the status of the quote report generation, make a GET request to the /projects/{projectId}/quote-report/export endpoint. As soon as the response body contains a \"completed\" status, then you can proceed to the next step. To download the generated project quote, make a GET request to the /projects/{projectId}/quote-report/download endpoint. Report format There are two available file formats for exporting the quote: PDF Excel By default, the quote report is exported as a PDF file. The format of the file can be changed by specifying the format query parameter. Report language The report can be localized in one of the following languages, by specifying the languageId query parameter: English - en German - de French - fr French (Canada) - fr-CA Japanese - ja Spanish - es Simplified Chinese - zh-CN Dutch - nl Italian - it The next screenshot illustrates a sample of an exported PDF quote. Update project quote To update a quote, make a PUT request to the /projects/{projectId} endpoint, and specify the quote field. Cost types Two types of translation costs can be updated using the Trados Cloud Platform API: Language Costs - Costs that are applied at language level: volume, percentage, hourly, per page, conditional Project Costs - Costs that are applied at project level as additional cost: volume, percentage, hourly, per page, conditional, per file, per target language Cost types available at project and language level Note Both language costs and project costs have identical request/response bodies, but for languageCosts, the targetLanguage field is required. The examples below use the following translation costs: ... { \"translationCosts\": [{ \"total\": 85.4, \"targetLanguage\": { \"languageCode\": \"fr-FR\", \"englishName\": \"French (France)\" }, \"new\": { \"count\": 854.0, \"rate\": 0.1, \"total\": 85.4, \"runningTotal\": 85.4 } } ] } ... Volume This is a fixed per word/character cost. Request: ... { \"name\": \"Volume Cost\", \"costOrder\": 0, \"cost\": 0.5, \"volumeUnitType\": \"Words\", \"costType\": \"volume\" ... } ... The total cost is calculated as number of words/characters * cost of a unit: total = count * cost Response: ... { \"name\": \"Volume Cost\", \"count\": 854.0, \"total\": 427.0, \"cost\": 0.5, \"costType\": \"volume\", \"volumeUnitType\": \"words\", \"costOrder\": 0, \"runningTotal\": 512.4 ... } ... The running total up until this point is equal to total cost of the current additional cost + translation costs. Using the data above, we can get the following running total: 85.4 + 427 = 512.4 Percentage This is a percentage cost calculated against the current cost (current language-level cost or current project-level cost). Request: ... { \"name\": \"Percentage Cost\", \"costOrder\": 1, \"count\": -10, \"costType\": \"percentage\" ... } ... The total cost of the current additional cost is calculated using the value from the count field as a percentage from the previous running total. total = count% * previousRunningTotal Response: ... { \"name\": \"Percentage Cost\", \"count\": -10.0, \"total\": -51.24, \"cost\": 0.0, \"costType\": \"percentage\", \"costOrder\": 1, \"runningTotal\": 461.16 ... } ... Since the previous running total is 512.4, the total cost of the current additional cost is calculated as follows: total = -10% * 512.4 = -51.24 As a result, the new running total becomes: runningTotal = 512.4 - 51.24 = 461.16 Hourly This is a fixed cost per hour. Request: ... { \"name\": \"Hourly Cost\", \"costOrder\": 2, \"count\": 5, \"cost\": 1.5, \"costType\": \"hourly\" ... } ... The total cost is calculated as number of hours * cost of an hour: total = count * cost Response: ... { \"name\": \"Hourly Cost\", \"count\": 5.0, \"total\": 7.5, \"cost\": 1.5, \"costType\": \"hourly\", \"costOrder\": 2, \"runningTotal\": 468.66 ... } ... total = 5 * 1.5 = 7.5 runningTotal = 461.16 + 7.5 = 468.66 Per Page This is a fixed cost per page. Request: ... { \"name\": \"Per Page Cost\", \"costOrder\": 3, \"count\": 10, \"cost\": 0.2, \"costType\": \"perPage\" ... } ... The total cost is calculated as number of pages * cost of a page: total = count * cost Response: ... { \"name\": \"Per Page Cost\", \"count\": 10.0, \"total\": 2.0, \"cost\": 0.2, \"costType\": \"perPage\", \"costOrder\": 3, \"runningTotal\": 470.66 ... } ... total = 10 * 0.2 = 2 runningTotal = 468.66 + 2 = 470.66 Conditional This is a cost that is applied conditionally, for example: Request: ... { \"name\": \"Conditional Cost\", \"costOrder\": 4, \"conditionalCostVariable\": \"wordCount\", \"conditionalCostOperator\": \"less\", \"conditionalCostThreshold\": 1000, \"cost\": 100, \"conditionalCostType\": \"relative\", \"costType\": \"conditional\" ... } ... If [conditionalCostVariable] [conditionalCostOperator] [conditionalCostThreshold], then add/set [cost] [conditionalCostType]. This formula translates to the following: If wordCount < 1000, then add 100 relative. Response: ... { \"name\": \"Conditional Cost\", \"count\": 854.0, \"total\": 100.0, \"cost\": 100.0, \"costType\": \"conditional\", \"costOrder\": 4, \"conditionalCostType\": \"relative\", \"conditionalCostOperator\": \"less\", \"conditionalCostVariable\": \"wordCount\", \"conditionalCostThreshold\": 1000.0, \"runningTotal\": 570.66 ... } ... Since the word count (count) is 854 (in the example above), the condition becomes: If 854 < 1000 then add 100 relative. => true total = cost = 100 runningTotal = 470.66 + 100 = 570.66 The total cost depends on the conditionalCostType field and on whether the condition evaluates to true or false. When the condition evaluates to false, the total will be 0, and the running total will not change. If 854 > 1000, then add 100 relative. => false total = cost = 0 runningTotal = 470.66 For the same values as above, and the conditionalCostType set to percentage, the total and runningTotal values will change to: total = 100% * 470.66 = 470.66 runningTotal = 470.66 + 470.66 = 941.32 When the conditionalCostType is set to absolute, the total will be equal to the difference between the cost and the runningtotal: total = 100 - 470.66 = -370.66 runningTotal = 100 Note Setting conditionalCostType to absolute will cancel all the previous costs for the project or the target language. Cost types available ONLY at project level Per Target Language This is an additional cost that is calculated based on the number of target languages in the project. Request: ... { \"name\": \"Per Target Language\", \"costOrder\": 5, \"cost\": 5, \"costType\": \"perTargetLanguage\" } ... The total cost is calculated as number of target languages * cost of a target language: Response: ... { \"name\": \"Per Target Language\", \"count\": 1.0, \"total\": 5.0, \"cost\": 5.0, \"costType\": \"perTargetLanguage\", \"costOrder\": 5, \"runningTotal\": 575.66 } ... Since there is only one target language in the example above, the total cost becomes: total = 1 * 5 = 5 runningTotal = 570.66 + 5 = 575.66 Per File This is an additional cost that is calculated based on the number of files in the project. Request: ... { \"name\": \"Per File\", \"costOrder\": 6, \"cost\": 3, \"costType\": \"perFile\" } ... The total cost is calculated as number of files * cost of a file: Response: ... { \"name\": \"Per File\", \"count\": 2.0, \"total\": 6.0, \"cost\": 3.0, \"costType\": \"perFile\", \"costOrder\": 6, \"runningTotal\": 581.66 } ... total = 2 * 3 = 6 runningTotal = 575.66 + 6 = 581.66 Cost order The costOrder field defines the order in which costs are calculated. For example, if there are two additional costs defined in the quote (see below), the percentage cost is calculated based on the running total from the volume cost. ... { \"name\": \"Volume Cost\", \"total\": 427.0, \"costType\": \"volume\", \"costOrder\": 0, \"runningTotal\": 512.4 ... }, { \"name\": \"Percentage Cost\", \"total\": -51.24, \"count\": -10.0, \"costType\": \"percentage\", \"costOrder\": 1, \"runningTotal\": 461.16 ... } ... When the costOrder field is switched, the total percentage cost value will be calculated based on the previous running total, which in this case is the translation cost (85.4): ... { \"name\": \"Percentage Cost\", \"count\": -10.0, \"total\": -8.54, \"costType\": \"percentage\", \"costOrder\": 0, \"runningTotal\": 76.86 ... }, { \"name\": \"Volume Cost\", \"total\": 427.0, \"costType\": \"volume\", \"costOrder\": 1, \"runningTotal\": 503.86 ... } ..."
  },
  "articles/LCPublicAPI/docs/File-formats.html": {
    "href": "articles/LCPublicAPI/docs/File-formats.html",
    "title": "File formats",
    "summary": "File formats A file used in the Trados Cloud Platform API can have one of the three supported formats: native, SDLXLIFF or BCM: Native represents the format of the file that is attached to a project by the user. The project's associated File Type Configuration specifies if the native file extensions can be attached to that project. To download files for translation or review in offline mode, the *.sdlxliff format can be used. SDLXLIFF files have XML format. BCM (Bilingual Content Model) documents are files used for handling content internally. BCM files have JSON content and are stored in .json format. File formats in a workflow In a workflow, each task has a supported input file type that describes which input file types are allowed for that task. A new file version can be added only if the format of this new version respects the input file type supported by the task. You can check what the supported input file types are for tasks on the Rules for sequencing tasks correctly page. A few input file types and examples of tasks that support them are listed below: nativeSource: the task handles source file versions in their uploaded native format (e.g.: FileTypeDetection, Engineering, FileFormatConversion) bcmSource: the task can process source files in their BCM format (e.g.: DocumentContentAnalysis, CopySourceToTarget) bcmTarget: the task accepts target files in their BCM format (e.g.: Translation, Linguistic Review, MachineTranslation, TranslationMemoryMatching, TranslationMemoryUpdate, TargetFileGeneration) nativeTarget: the task handles target files in their native \"generated\" form (e.g.: DTP, FinalCheck) sdlxliffTarget: the task processes target files in their SDLXLIFF form. Specifically for Import tasks. none: the task does not read or modify the content of a file. Using the Trados Cloud Platform API, the source and target files in different formats can be viewed, downloaded and added (via import operations), based on the task and its status in the project's workflow. Handling Source Files Upload Source Files Source files can be added to a project using the Add Source File endpoint or the Attach Source Files endpoint (for multiple files). If the file's extension is supported by the File Type Configuration, the project will follow the workflow and a new version of the source file in BCM format will be automatically created in the File Format Conversion task. Upload Source File Versions New source file versions can be added in native or BCM format using the Add Source File Version endpoint. You can add source file versions: in the Engineering task in custom tasks created by users having the task type set to Engineering in extension tasks that handle source files. If a project having attached a native source file with an unsupported extension is started, an error task will be generated in the File Type Detection task and the workflow is interrupted. Note For adding a source file version using an extension task, the configuration of the task type must declare the scope's value as \"file\". Download Source File Versions Any of the source file versions (in native or BCM format) can be downloaded using the Download Source File Version endpoint. The Engineering task, for instance, is an example of a task where download can be performed. Handling Target Files The Copy source to target task converts the native file to a new target file version in BCM format. Upload Target File Versions Adding a new version for a target file in native or BCM format can be executed with the Add Target File Version endpoint. Note For adding a target file version using an extension task, the configuration of the task type must declare the scope's value as \"file\". Download Target File Versions The BCM and native target file versions can be downloaded by using Download Target File Version endpoint, while the project is, for example, in the Translation task. Export Target File Versions The BCM target file versions can be exported in native or SDLXLIFF format by calling the Export Target File Version endpoint. This operation triggers a conversion of the BCM target file version in a native or SDLXLIFF format based on the value of the format query parameter used. The endpoint starts an export operation which can be monitored using the polling endpoint. After the export is done, the files can be downloaded using the Download Exported Target File Version endpoint. Note The export endpoint is dedicated to file versions of BCM format and cannot be used on files in native or SDLXLIFF format. The export operation can only be executed on tasks where the supported output file is a bilingual target file. You can consult the output file types for tasks on the Rules for sequencing tasks correctly page from the official RWS Documentation Center. In order to download file versions of BCM or native type, please use the Download Target File Version endpoint. Import Target File Versions Target file versions downloaded in SDLXLIFF format can be processed and afterwards replaced by using Import Target File Version endpoint. The import operation triggers internally the update of the BCM file associated with the imported SDLXLIFF file. This endpoint should mostly be used for offline work."
  },
  "articles/LCPublicAPI/docs/Headers-considerations.html": {
    "href": "articles/LCPublicAPI/docs/Headers-considerations.html",
    "title": "Headers considerations",
    "summary": "Headers considerations The purpose of this page is to showcase the header types that could capture your interest. Note Headers must be treated as case-insensitive. The Trados Cloud Platform API response headers can be classified as follows: Header type Example Standard Content-Type Custom X-LC-TraceId Endpoint specific Content-Disposition Content-Type header The application/octet-stream content type is used to indicate that a body contains arbitrary binary data. The recommended action for a consumer that receives an application/octet-stream entity is to simply offer to put the data in a file, read more in the RFC2046 space. Content-Disposition header For operations expected to return content that can be handled as a file, the Content-Disposition header can be sent in the response headers to provide more information about the response payload. The Trados Cloud Platform API will provide this header in certain situations, and its primary goal is to supply a file name for the content being downloaded or exported. You can read more about the Content-Disposition header on the MDN Web Docs website or in the RFC6266 space. The Content-Disposition response header can be usually found on various download API endpoints like Download Source File Version, Download Target File Version, Download Exported Quote Report and others. Note Please note that both Content-Type and Content-Disposition are not required and APIs might not include them in the response. There are no guarantees that an endpoint that used to return a Content-Type or Content-Disposition header will still do so, under any circumstance. Please treat these headers as optional for all APIs. Retrieving the file name Here's an example of how the Content-Type and the Content-Disposition headers look like: Content-Type: application/octet-stream Content-Disposition: attachment; filename=\"Public API Download.pdf\"; filename*=UTF-8''Public%20API%20Download.pdf The parameters filename and filename*, to be matched case- insensitively, provide information on how to construct a filename for storing the message payload. The parameters filename and filename* differ only in that filename* uses the encoding defined in RFC5987, allowing the use of characters not present in the ISO-8859-1 character set. Note When both filename and filename* are present in a single header field value, you must pick filename* and ignore filename. If the Content-Disposition header is missing or you simply want to have a different file name, you need to provide a name and the file extension. The extension can be usually inferred from the required Content-Type header and also from the operation that is invoked. Deprecation and sunset headers These types of headers are used in our endpoint retirement process and are covered broadly in the Public API Management Process page."
  },
  "articles/LCPublicAPI/docs/How-to-multipart.html": {
    "href": "articles/LCPublicAPI/docs/How-to-multipart.html",
    "title": "Multipart considerations",
    "summary": "Multipart considerations This page goes into deeper details for uploading files. Generally you might be interested in this subject when not using the provided SDKs and are implementing your own SDK. This page should help you debug potential problems you might encounter. Note Our APIs follows standard HTTP/1.1 protocol as described in RFC2616 and subsequent RFCs. This page does not describe any custom HTTP behavior. How to perform POST requests with multipart Whenever you make use of endpoints that do file uploads using multipart/form-data, some additional details may be required to be sent alongside the file, for example a properties part. Let's take as an example the Add Source File Version endpoint. The API specifies that the request content is multipart/form-data and has a properties part that should be serialized as a JSON (this might not be mentioned explicitly in the documentation, but any structures in multiparts should be serialized as JSON). The second property is file and though it is of type string, that means that the raw content of the file should be sent in that part. Note The order of parts is important! Please send the parts in the order these are specified in the API contract. To confirm that you are sending the correct content, you can intercept the request and view the raw request (this can be done in many ways, with either built in tools if available in your IDE/tooling or even free software). A simplified raw HTTP request is presented bellow: POST /tasks/<taskId>/source-files/<sourceFileId>/versions HTTP/1.1 HOST: host.example.com Content-Type: multipart/form-data; boundary=--------------------------818668410602542750275539 ----------------------------818668410602542750275539 Content-Disposition: form-data; name=\"properties\" Content-Type: application/json { \"type\":\"native\", \"fileTypeSettingsId\": \"<FILE_TYPE_SETTINGS_ID>\" } ----------------------------818668410602542750275539 Content-Disposition: form-data; name=\"file\"; filename=\"<FILENAME.EXTENSION>\" Content-Type: <MATCHING CONTENT TYPE FOR YOUR FILE TYPE> <FILE CONTENT GOES HERE> ----------------------------818668410602542750275539-- For the file, there is usually the filename that needs to be sent, along with file Content-type and finally the content."
  },
  "articles/LCPublicAPI/docs/How-to-report-an-issue.html": {
    "href": "articles/LCPublicAPI/docs/How-to-report-an-issue.html",
    "title": "How to report an issue",
    "summary": "How to report an issue When reporting an issue it is important to include as much information as you can. Use this template Here below is a template that we recommend using when raising a new ticket: - Endpoint: - X-LC-Tenant: - X-LC-TraceId: - Request URL: - Request body: - Response status code: - Response body: - Expected result: - Actual result: - Description: You don't have to fill in all the fields, but the more details you provide, the easier it will be to investigate and get to a solution faster. Besides these details you can also add anything that you consider helpful for the investigation. Obtaining the details Endpoint - identify the endpoint where the issue was observed from the Trados Cloud Platform API and paste the link to it. X-LC-Tenant - is the tenant identifier as sent in the request headers. This is required on all endpoints. X-LC-TraceId - is a unique identifier for the request and it can be found in the response headers. It is very useful when investigating the issue, thus it should always be provided, if possible. Request URL - the URL in the request as sent from your application (including the domain, endpoint path and any query parameters). If that is not available, at least include the query parameters used to perform the request. Some of the most relevant ones are: fields, top, skip, location, locationStrategy and others, depending on the case. Request body - the json content sent. Response status code - the HTTP status code returned. Response body - the response received. Error responses are also relevant. Expected result - what was the expected outcome. Actual result - what was the actual outcome. Description - a short description about what you are trying to achieve and possible answers to questions like \"How did you end up in the current situation?\" or \"Did you find a workaround?\" Example You can simply copy the format from above and fill in the details. For example: Endpoint: https://eu.cloud.trados.com/lc/api-docs/025707d21ecc0-create-project X-LC-Tenant: <YOUR_TENANT_ID> X-LC-TraceId: 90d9147c-6afd-4d19-b0ac-99cac9ece970 Request URL: https://api.eu.cloud.trados.com/public-api/v1/projects?fields=dueBy,status,customer.name Request body: { \"name\": \"Invalid projectTemplate\", \"description\": \"How to report an issue\", \"projectTemplate\": { \"id\": \"invalid_project_template_id\" } } Response status code: 404 Response body: { \"errorCode\": \"notFound\", \"message\": \"Invalid input on create project.\", \"details\": [ { \"name\": \"project.template.id\", \"code\": \"notFound\", \"value\": \"invalid_project_template_id\" } ] } Expected result: The project is created. Actual result: The project is not created due to projectTemplate.id not being found. Description: When attempting to create a new project I get the error mentioned above. Note Check the Multi-Region page for regional API details."
  },
  "articles/LCPublicAPI/docs/How-to-use-location-and-folders.html": {
    "href": "articles/LCPublicAPI/docs/How-to-use-location-and-folders.html",
    "title": "How to use location and folders",
    "summary": "How to use location and folders The Trados Cloud Platform API supports folder-based access management to all resources. The users have access to resources based on the permissions associated with the group (role) they belong to. For information about creating a user you can check the Service credentials page. Concepts we use Detailed information about specific concepts used in inheritance context can be found on the Concepts we use page from the official Trados Cloud Platform Documentation Center. Setting a location for a user The folders structure in Trados Cloud Platform API is hierarchical. For more information on how to organize folders and set up a location for a user, visit the Customers page. User rights in folders Depending on how the account was provisioned, configured and on the groups which the user belongs to, the rights for a user can be more restrictive or permissive. Users can learn where they were created, the exact folder, and what groups they belong to, by executing a Get My User call with the fields query parameters set to \"location.name,location.path,groups\". For example, let's assume that an account has the following hierarchy of folders (with associated unique identifiers simplified for readability): Root (60b...fb0) Customers (fea...a0b) Customer1 (ed7...623) Customer3 (4f0...206) Customer4 (e73...4a8) Customer2 (48b...5d0) Customer5 (bbc...c21) Vendors (a16...29f) Vendor1 (b02...281) Vendor2 (d46...839) If a user is created in Customer5 and is assigned to the \"Project Managers Customer5\" group, performing the above request will receive the following response: { \"id\": \"62b...d56\", \"location\": { \"id\": \"bbc...c21\", \"name\": \"Customer5\", \"path\": [ { \"id\": \"48b...5d0\", \"location\": \"fea...a0b\", \"name\": \"Customer2\", \"hasParent\": true }, { \"id\": \"fea...a0b\", \"location\": \"60b...fb0\", \"name\": \"Customers\", \"hasParent\": true }, { \"id\": \"60b...fb0\", \"name\": \"Root\", \"hasParent\": false } ] }, \"groups\": [ { \"id\": \"60b...2be\", \"name\": \"Project Managers Customer5\" } ] } In the above example location.id describes the exact folder where the resource is situated. The array under location.path presents a bottom-up hierarchical arrangement of all the parent folders leading up to Root, where the array ends, this being signaled by the \"hasParent\": false field. Creating resources in folders The users' access to resources depends on the folder where they were created and on the groups they belong to. Detailed information about what actions can be executed with specific roles can be checked here. When creating a resource, it is strongly recommended to send in the request the location field. When location is not set, the system will try to create the resource in the higher folder in the hierarchy, the Root folder. It might not have access to that folder and the request will fail with forbidden error. For example: If Customer2 tries to create a project with location values set to \"48b...5d0\": Where will the project be created? in Customer2 folder If Customer2 tries to create a project with no value set for location: Where will the project be created? In Root folder, if the user has access in Root If the user does not have access in Root, the request will fail with forbidden error If Customer4 tries to create a project with location value set to \"e73...4a8\": Where will the project be created? in Customer4 folder If Customer4 tries to create a project with no value set for location: Where will the project be created? In Root folder, if the user has access in Root If the user does not have access in Root, the request will fail with forbidden error More examples of accessing resources based on their location are listed on the Inheritance within the account page. Retrieve resources using location strategy List endpoints can have a 'location' query parameter that is used to filter items by location. Location is the value of the folder id. Some endpoints accept an array rather than a single location. Additionally, this parameter can be used together with 'locationStrategy' which can have the following values: location: all resources located strictly in the folders from the folder parameter (default value for locationStrategy) are returned lineage: resources located in the folder specified by the folder parameter, as well as any of its subfolders, are returned bloodline: resources located in the folder specified by the folder parameter, as well as any of its ancestor folders, are returned genealogy: resources located in the folder specified by the folder parameter together with its subfolders and its ancestor folders The location field can be an array of folder identifiers containing multiple identifiers separated by commas. In this case, the locationStrategy applies for all of them and the result will contain all resources that fulfill the strategy, but, if a resource is duplicated in response for two, or more location identifiers, it will be returned only once. For example, let's see how location and locationStrategy query parameters work on an account that has the hierarchy defined in the earlier example: Root (60b...fb0) - Project1 Customers (fea...a0b) - Project2 Customer1 (ed7...623) Customer3 (4f0...206) - Project3 Customer4 (e73...4a8) Customer2 (48b...5d0) Customer5 (bbc...c21) - Project4 Vendors (a16...29f) Vendor1 (b02...281) Vendor2 (d46...839) If the list project endpoint is used with: location = \"fea...a0b\" (Customers folder identifier) Project2 is listed because the default value for locationStrategy is \"location\". locationStrategy = \"lineage\" All projects are listed because sending the locationStrategy without location does not filter anything. location = \"fea...a0b\" (Customers folder identifier) AND locationStrategy = \"location\" Project2 is listed because it is similar with the first case. location = \"fea...a0b\" (Customers folder identifier) AND locationStrategy = \"lineage\" Project2, Project3 and Project4 are returned. location = \"4f0...206\" (Customer3 folder identifier) AND locationStrategy = \"bloodline\" Project1, Project2 and Project3 are returned. location = \"fea...a0b\" (Customers folder identifier) AND locationStrategy = \"genealogy\" Project1, Project2, Project3 and Project4 are returned. location = \"fea...a0b,fea...0a0\" (Customers and Customer3 folder identifiers) AND locationStrategy = \"lineage\" Project2, Project3 (only once) and Project4 are returned."
  },
  "articles/LCPublicAPI/docs/Interact-with-tasks.html": {
    "href": "articles/LCPublicAPI/docs/Interact-with-tasks.html",
    "title": "Interact with tasks",
    "summary": "Interact with tasks Once the project is started, you can interact with tasks in several ways: Find the task identifier Make a GET request to the /tasks/assigned endpoint and identify the id of the task you want to interact with. Reclaim tasks If you make a PUT request to the /tasks/{taskId}/reclaim endpoint, the owner of task is removed and another user from the assignee's list can accept it. The task is not reassigned automatically. Complete tasks To complete a task, make a PUT request to the /tasks/{taskId}/complete endpoint. Assign tasks If the tasks is rejected by all its assignees, you can update the list of assignees. Make a GET request to the /users or /groups endpoints and remember their identifiers. Then, make a PUT request to the /tasks/{taskId}/assign endpoint and provide the identifiers. List all the tasks in a project Make a GET call to the /projects/{projectId}/tasks endpoint to list all the tasks in a project by projectId. The response returns a total count of the tasks, and several details for each task: taskId, the input and outcome per task, the owner and assignees, the creation and due dates. Upload/Import a target file version Make a POST call to the /projects/{projectId/target-files/{targetFileId}/versions/imports endpoint to upload (import) a new file version that can be used as part of a task. The response returns the importId which you can further use to check the import result by making a GET call to the /projects/{projectId}/target-files/{targetFileId}/versions/imports/{importId} endpoint. The projectId can be retrieved by making a POST call to the /projects endpoint, while the targetFileId can be retrieved by making a GET call to the /projects/{projectId}/target-files endpoint."
  },
  "articles/LCPublicAPI/docs/Introduction.html": {
    "href": "articles/LCPublicAPI/docs/Introduction.html",
    "title": "Trados Cloud Platform API",
    "summary": "Trados Cloud Platform API The Trados Cloud Platform API enables external applications to interact with Trados Cloud Platform. Product Configurations This applies to all products that are based on Trados Cloud Platform. Note that, depending on the product and its configuration, certain features may not be available or the rate might be limited through the API. In general, when a certain feature is available in your specific product configuration, the corresponding endpoints will also be available in the API. Features Overview At present, the API contains mainly capabilities that enable the creation, management and tracking of cloud translation projects. Resources like termbases and translation memories can also be created using the Trados Cloud Platform API. Any other resources, such as pricing models need to be set up beforehand, using the user interface. Types of Integrations At the moment the Trados Cloud Platform API can be called by custom (integration) applications on behalf of service users (non-human users). The ability to call the API on behalf of real end users will be supported at a later date. Creating Your First Project Follow these steps to create your first project using the API: 1. Create a service user, an application and authenticate Follow the instructions under the Service users and custom applications and the Service Credentials pages to create a service user and an application, and then authenticate, following the Authentication page, by using the application's client_id and client_secret. 2. Create your first project See Create projects and Basic project creation flow for a walk-through of the required steps to create a project."
  },
  "articles/LCPublicAPI/docs/Known-Issues.html": {
    "href": "articles/LCPublicAPI/docs/Known-Issues.html",
    "title": "Known issues",
    "summary": "Known issues This page lists the known bugs and issues for Trados Cloud Platform API. Note 5xx status codes might be returned on any endpoint. This means that the server has encountered an unexpected error. If the error persists, use the How to report an issue guideline to gather the needed information for reporting the issue. Download Exported Quote Report The Download Exported Quote Report endpoint is designed to be a one-time operation. After a download attempt, the file is deleted and it's no longer available for download. If the file needs to be downloaded again, the user needs to request a new export of the quote report by using the Export Quote Report and Poll Quote Report Export endpoints. Export Quote report When the export is not using a Quote Template, the response for this call will be empty."
  },
  "articles/LCPublicAPI/docs/Language-Cloud-APIs-for-Postman.html": {
    "href": "articles/LCPublicAPI/docs/Language-Cloud-APIs-for-Postman.html",
    "title": "Trados Cloud Platform APIs for Postman",
    "summary": "Trados Cloud Platform APIs for Postman We provide a Postman collection for quick and easy usage of our RESTful APIs. Installation You can download the Postman collection from here. If you make use of multi-region, we also provide the EU and CA Postman Environments. There are 3 setup options: Copy the collection URL from above and import it into Postman using Import > Link. Copy the entire file content and import it into Postman using Import > Raw Text. Save it as a JSON file on your computer and import it into Postman using Import > File. Configuration The imported collection is already set up for you to get started as fast as possible. We make use of collection level variables and an inherited authentication mechanism. For example, authentication is already set up to use the Bearer Token scheme and will use the token value provided by {{lc-access-token}} variable. This token is populated with the correct value, each time you Obtain a client credentials access token, via the Tests tab. One thing you need to do before proceeding is to fill in the {{lc_tenant}} variable with your own tenant ID. Prepend the ID with LC- so the final value looks like this LC-00000000000000000. Don't forget to save the collection! Multi-region environments If you have imported the regional Postman Environments, please note that any environment-level variables (e.g., baseUrl) will overwrite collection variables. This means that when you have an environment selected in Postman, the value of baseUrl will be the one defined in the environment, not the value defined at the collection level. Authentication To start working with the Trados Cloud Platform API, you first need to authenticate. You can find the authentication call under the Authentication (Start Here) folder. Fill in your client_id and client_secret and perform the request. If the authentication is successful, the token will be extracted automatically from the response and saved to the {{lc-access-token}} variable. Usage After you have authenticated successfully, you can start interacting with the Trados Cloud Platform API. For example, we can get information about a project by using the GetProject request from the Project folder. Simply fill in your projectId and click SEND. Optionally, you can supply values to the fields parameter to receive only data that is of interest. Warning Make sure you are not sending any query parameters with default Postman values. If you are sending any parameters, make sure you are sending valid data or else you will get an API Error."
  },
  "articles/LCPublicAPI/docs/Language-codes.html": {
    "href": "articles/LCPublicAPI/docs/Language-codes.html",
    "title": "Language Codes",
    "summary": "Language Codes When getting a response that contains language codes, the case of the language code is not guaranteed and should be treated as case insensitive. For example the Trados Cloud Platform API can return the same language code but with different casing on different endpoints: en-US en-us EN-US All 3 variants are equivalent. When making a request to the Trados Cloud Platform API, you should still ensure the correct casing of language codes, to avoid any unexpected situations."
  },
  "articles/LCPublicAPI/docs/Multi-region.html": {
    "href": "articles/LCPublicAPI/docs/Multi-region.html",
    "title": "Multi-region",
    "summary": "Multi-region Trados Cloud Platform operates in multiple regions, and it's essential to know how to use the Public API correctly for each region. Each region has a unique Public API host, and all requests must be specific to that region. If you try to access accounts or data not available in a region, you will encounter errors. Legacy integrations The domains for the Trados Cloud Platform API have been updated. If you are using the old domain lc-api.sdl.com in a legacy integration, please consider the following options: Use the new endpoints to discover the correct Public API host for your desired region. If you are only integrating with the EU region (legacy), update the host to: api.eu.cloud.trados.com Supporting multi-region This information is especially relevant if you are building multi-tenant integrations. The provided .NET and Java SDKs already support multiple regions. For details on using these SDKs, refer to their documentation. Note If you're building your own client, avoid hard-coding Trados Cloud Platform API hosts, as new regions may be added in the future, requiring updates to hard-coded hosts. You can discover all available regions and their corresponding Public API hosts using the List Regions endpoint from the new Global Public API, which is accessible on a new global host api.cloud.trados.com."
  },
  "articles/LCPublicAPI/docs/Public-API-Management-Process.html": {
    "href": "articles/LCPublicAPI/docs/Public-API-Management-Process.html",
    "title": "Trados Cloud Platform API Management Process",
    "summary": "Trados Cloud Platform API Management Process Overview By using continuous delivery, our team regularly updates the Trados Cloud Platform API with new functionality, bug fixes and performance improvements. Find below the defined process (lifecycle policy) we use that enables us to maintain a set of stable APIs. Every release is announced on the What's new page in our API Docs. What is a breaking change? Changing the type of a field Modifying a field name Marking an existing field as required with no default value Introducing a new validation Enforcing validations Removing or renaming enum values Removing fields from response What isn't a breaking change? Adding new endpoints Adding optional request fields Adding new fields in responses Adding new field as required with default value Changing of error messages description Adding enum values Endpoint retirement process Retirement of an endpoint will happen in two phases: deprecation and sunset. Deprecation will be marked accordingly with IETF's deprecation http-response-header-field with: a date in the future: representing the date, when the endpoint will be marked as deprecated a date in the past: representing the date, when the endpoint was marked as deprecated true: simply signal to the clients, that the endpoint is deprecated The deprecation period is six months. Sunset marks the point in time where the endpoint will not return the expected response. The endpoint will still be functional until sunset. Together with the deprecation header, a new sunset-header will be introduced to mark the date of the sunset. How will we communicate an eventual breaking change or endpoint retirement? An eventual breaking change or an endpoint retirement will be announced: on the What's new page in our API Docs on the What's deprecated page in our API Docs on the developers GitHub page on a new blog post in the Language Developers Blog and Trados Blog Any breaking change will be announced six months in advance. Note We may introduce breaking changes for critical bugs or security vulnerabilities. What is our process for testing changes before releasing them to the Trados Cloud Platform API? All changes undergo comprehensive testing and validation, following our deployment chronology in both non-customer and customer facing environments. As part of development, unit and contract tests are built as appropriate and undergo in-depth code review before being merged into master. As part of testing, once the changes are merged, they are tested according to our testing strategy, where testing scope and test coverage are identified. A test plan for the changes is created and quality assurance engineers decide upon manual and automation testing percentage to ensure the feature is implemented according to the specifications. On top of this we make sure regressions are not introduced by running the automated tests we have in place, as part of the release pipeline. Before new code is deployed to an environment (either customer or non-customer facing), all smoke tests must pass."
  },
  "articles/LCPublicAPI/docs/Service-credentials.html": {
    "href": "articles/LCPublicAPI/docs/Service-credentials.html",
    "title": "Service Credentials",
    "summary": "Service Credentials Before service users can authenticate with the Trados Cloud Platform API, they need to get their client credentials from a Trados Cloud Platform administrator. Service users can then use their client credentials to authenticate with the API via an Auth0 access token. Step 1: Trados Cloud Platform administrators add service users to the Trados Cloud Platform account. Log in to the Trados UI as a human Administrator user type or contact the administrator to perform the operations in this section. Go to the Users view and select the Service Users sub-tab. Select New Service User and enter the following information: Name  Enter a unique name for your service user. Location  Select a location (the Root folder or any of its children) for your service user. A location is a folder in your account hierarchy where resources are stored and managed. Groups  Select one or more groups (from the same Location as the one selected above) where you want to include your service user. Each group corresponds to a predefined role, and each predefined role has a set of permissions. Resource access is influenced by the role you choose. (Optional) Description  Enter any other relevant details. Select Create. Step 2: Trados Cloud Platform administrators add additional notification options for service users Log in to the Trados UI as a human Administrator user type or contact the administrator to perform the operations in this section. Go to the Users view and select the Service Users sub-tab. Select the service user to be edited Additional users to notify - Add existing users to be notified of actions via email. Select Save. Step 3: Trados Cloud Platform administrators create a custom application, assign the service user to it, and retrieve the client credentials from within this application. Log in to the Trados UI as a human Administrator user type or contact the administrator to perform the operations in this section. Expand the account menu on the top right-hand corner and select Integrations. Select the Applications sub-tab. Select New Application and enter the following information: Name  Enter a unique name for your custom application. (Optional) URL  Enter your custom application URL. (Optional) Description  Enter any other relevant details. Service User  Select a service user from the dropdown menu. Select Add. Back in the Applications sub-tab, select the check box corresponding to your application. Select Edit. On the Overall Information page you can change any of the following, if necessary: name, URL, description. On the Webhooks page you can: Enter a default callback URL for your application Webhooks (all Webhooks defined in Trados Cloud Platform). Enter a value for Webhook URL (this is your Webhook endpoint URL which you expose and which Trados Cloud Platform calls), select one or more event types, and hit Enter. You can create a separate webhook for every event you are interested in or combine notifications for multiple event types to one webhook. If you delete your application, all its associated webhooks are also deleted. Finally, from the API Access page you can retrieve your Client ID and Client Secret. Note Although you have the option to change the Service User later on, it is not recommended. Due to the caching layers, changes from one Service User to another can take between 10 to 20 minutes to fully take effect. During this period, calls made with this Application's credentials may randomly use either the new or the old Service User. If you can't stop your services to wait for the cache to expire, it's recommended to create a new Application with the new Service User and delete the old one."
  },
  "articles/LCPublicAPI/docs/Service-users-and-custom-applications.html": {
    "href": "articles/LCPublicAPI/docs/Service-users-and-custom-applications.html",
    "title": "Service users and custom applications",
    "summary": "Service users and custom applications Service users are special users created when developing custom applications that integrate with the Trados Cloud Platform API. Service users: Are non-human users Dont have login credentials Can only access Trados Cloud Platform via the Trados Cloud Platform API Who can create service users? Service users are managed by administrators within a Trados Cloud Platform account. Administrators add service users to one or more groups. Once service users become part of a group, they automatically get a role, namely the group role which is associated with a predefined set of permissions. Service users access resources based on the permissions associated with the group (role) they belong to. How are service users assigned to custom applications? When Trados Cloud Platform administrators create a custom application from the Trados UI, they assign one service user per application. How does the authentication process of service users work? Whenever a third-party client authenticates with the application credentials, calls against the Trados Cloud Platform API will assume the identity of the service user within the platform for the purpose of authorizing access to data."
  },
  "articles/LCPublicAPI/docs/Track-projects.html": {
    "href": "articles/LCPublicAPI/docs/Track-projects.html",
    "title": "Track projects",
    "summary": "Track projects After you create a project, you can track it by making a GET request to the /projects/{projectId} endpoint to obtain information such as: creation date, due date, status, and resources used. When requesting a list of projects, you can filter out projects that have a file download restriction by sending the excludeOnline query parameter."
  },
  "articles/LCPublicAPI/docs/Update-project-quote.html": {
    "href": "articles/LCPublicAPI/docs/Update-project-quote.html",
    "title": "Update project quote",
    "summary": "Update project quote To update a quote, make a PUT request to the /projects/{projectId} end point, and specify the quote field. Cost types There are two types of translation costs that can be updated using the Trados Cloud Platform API: Language Costs - Costs that are applied at language level: volume, percentage, hourly, per page, conditional Project Costs - Costs that are applied at project level as additional cost: volume, percentage, hourly, per page, conditional, per file, per target language Cost types available at project and language level Note: Both language costs and project costs have identical request/response bodies, but for languageCosts, the targetLanguage field is required. The examples below use the following translation costs: ... { \"translationCosts\": [{ \"total\": 85.4, \"targetLanguage\": { \"languageCode\": \"fr-FR\", \"englishName\": \"French (France)\" }, \"new\": { \"count\": 854.0, \"rate\": 0.1, \"total\": 85.4, \"runningTotal\": 85.4 } } ] } ... Volume This is a fixed per word/character cost. Request: ... { \"name\": \"Volume Cost\", \"costOrder\": 0, \"cost\": 0.5, \"volumeUnitType\": \"Words\", \"costType\": \"volume\" ... } ... The total cost is calculated as number of words/characters * cost of a unit: total = count * cost Response: ... { \"name\": \"Volume Cost\", \"count\": 854.0, \"total\": 427.0, \"cost\": 0.5, \"costType\": \"volume\", \"volumeUnitType\": \"words\", \"costOrder\": 0, \"runningTotal\": 512.4 ... } ... The running total up until this point is equal to total cost of the current additional cost + translation costs. Using the data above, we can get the following running total: 85.4 + 427 = 512.4 Percentage This is a percentage cost calculated against the current cost (current language-level cost or current project-level cost). Request: ... { \"name\": \"Percentage Cost\", \"costOrder\": 1, \"count\": -10, \"costType\": \"percentage\" ... } ... The total cost of the current additional cost is calculated using the value from the count field as a percentage from the previous running total. total = count% * previousRunningTotal Response: ... { \"name\": \"Percentage Cost\", \"count\": -10.0, \"total\": -51.24, \"cost\": 0.0, \"costType\": \"percentage\", \"costOrder\": 1, \"runningTotal\": 461.16 ... } ... Since the previous running total is 512.4, the total cost of the current additional cost is calculated as follows: total = -10% * 512.4 = -51.24 As a result, the new running total becomes: runningTotal = 512.4 - 51.24 = 461.16 Hourly This is a fixed cost per hour. Request: ... { \"name\": \"Hourly Cost\", \"costOrder\": 2, \"count\": 5, \"cost\": 1.5, \"costType\": \"hourly\" ... } ... The total cost is calculated as number of hours * cost of an hour: total = count * cost Response: ... { \"name\": \"Hourly Cost\", \"count\": 5.0, \"total\": 7.5, \"cost\": 1.5, \"costType\": \"hourly\", \"costOrder\": 2, \"runningTotal\": 468.66 ... } ... total = 5 * 1.5 = 7.5 runningTotal = 461.16 + 7.5 = 468.66 Per Page This is a fixed cost per page. Request: ... { \"name\": \"Per Page Cost\", \"costOrder\": 3, \"count\": 10, \"cost\": 0.2, \"costType\": \"perPage\" ... } ... The total cost is calculated as number of pages * cost of a page: total = count * cost Response: ... { \"name\": \"Per Page Cost\", \"count\": 10.0, \"total\": 2.0, \"cost\": 0.2, \"costType\": \"perPage\", \"costOrder\": 3, \"runningTotal\": 470.66 ... } ... total = 10 * 0.2 = 2 runningTotal = 468.66 + 2 = 470.66 Conditional This is a cost that is applied conditionally, for example: Request: ... { \"name\": \"Conditional Cost\", \"costOrder\": 4, \"conditionalCostVariable\": \"wordCount\", \"conditionalCostOperator\": \"less\", \"conditionalCostThreshold\": 1000, \"cost\": 100, \"conditionalCostType\": \"relative\", \"costType\": \"conditional\" ... } ... If [conditionalCostVariable] [conditionalCostOperator] [conditionalCostThreshold], then add/set [cost] [conditionalCostType]. This formula translates to the following: If wordCount < 1000, then add 100 relative. Response: ... { \"name\": \"Conditional Cost\", \"count\": 854.0, \"total\": 100.0, \"cost\": 100.0, \"costType\": \"conditional\", \"costOrder\": 4, \"conditionalCostType\": \"relative\", \"conditionalCostOperator\": \"less\", \"conditionalCostVariable\": \"wordCount\", \"conditionalCostThreshold\": 1000.0, \"runningTotal\": 570.66 ... } ... Since the word count (count) is 854 (in the example above), the condition becomes: If 854 < 1000 then add 100 relative. => true total = cost = 100 runningTotal = 470.66 + 100 = 570.66 The total cost depends on the conditionalCostType field and on whether the condition evaluates to true or false. When the condition evaluates to false, the total will be 0, and the running total will not change. If 854 > 1000, then add 100 relative. => false total = cost = 0 runningTotal = 470.66 For the same values as above, and the conditionalCostType set to percentage, the total and runningTotal values will change to: total = 100% * 470.66 = 470.66 runningTotal = 470.66 + 470.66 = 941.32 When the conditionalCostType is set to absolute, the total will be equal to the difference between the cost and the runningtotal: total = 100 - 470.66 = -370.66 runningTotal = 100 Note: Setting conditionalCostType to absolute will cancel all the previous costs for the project or target language. Cost types available ONLY at project level Per Target Language This is an additional cost that is calculated based on the number of target languages in the project. Request: ... { \"name\": \"Per Target Language\", \"costOrder\": 5, \"cost\": 5, \"costType\": \"perTargetLanguage\" } ... The total cost is calculated as number of target languages * cost of a target language: Response: ... { \"name\": \"Per Target Language\", \"count\": 1.0, \"total\": 5.0, \"cost\": 5.0, \"costType\": \"perTargetLanguage\", \"costOrder\": 5, \"runningTotal\": 575.66 } ... Since there is only one target language in the example above, the total cost becomes: total = 1 * 5 = 5 runningTotal = 570.66 + 5 = 575.66 Per File This is an additional cost that is calculated based on the number of files in the project. Request: ... { \"name\": \"Per File\", \"costOrder\": 6, \"cost\": 3, \"costType\": \"perFile\" } ... The total cost is calculated as number of files * cost of a file: Response: ... { \"name\": \"Per File\", \"count\": 2.0, \"total\": 6.0, \"cost\": 3.0, \"costType\": \"perFile\", \"costOrder\": 6, \"runningTotal\": 581.66 } ... total = 2 * 3 = 6 runningTotal = 575.66 + 6 = 581.66 Cost order The costOrder field defines the order in which costs are calculated. For example, if there are two additional costs defined in the quote (see below), the percentage cost is calculated based on the running total from the volume cost. ... { \"name\": \"Volume Cost\", \"total\": 427.0, \"costType\": \"volume\", \"costOrder\": 0, \"runningTotal\": 512.4 ... }, { \"name\": \"Percentage Cost\", \"total\": -51.24, \"count\": -10.0, \"costType\": \"percentage\", \"costOrder\": 1, \"runningTotal\": 461.16 ... } ... When the costOrder field is switched, the total percentage cost value will be calculated based on the previous running total, which in this case is the translation cost (85.4): ... { \"name\": \"Percentage Cost\", \"count\": -10.0, \"total\": -8.54, \"costType\": \"percentage\", \"costOrder\": 0, \"runningTotal\": 76.86 ... }, { \"name\": \"Volume Cost\", \"total\": 427.0, \"costType\": \"volume\", \"costOrder\": 1, \"runningTotal\": 503.86 ... } ..."
  },
  "articles/LCPublicAPI/docs/Updating-data-with-PUT.html": {
    "href": "articles/LCPublicAPI/docs/Updating-data-with-PUT.html",
    "title": "Updating data with PUT",
    "summary": "Updating data with PUT All update endpoints follow the rules listed in JSON Merge Patch Semantics. Pay special attention when updating array fields The update overrides the entire array, not just the elements that are sent. See the following example: ORIGINAL PATCH RESULT {\"a\" :[{\"b\": \"c\"}]} {\"a\" :[1]} {\"a\" :[1]} If you don't send the \"b\" element from array \"a\", the element \"b\" will be removed from result after the update operation. If you send a new array element [1], this element will be added into the result. Updating an existing array element requires that you send the original array with a new value for the desired element."
  },
  "articles/LCPublicAPI/docs/Use-fields-in-your-requests.html": {
    "href": "articles/LCPublicAPI/docs/Use-fields-in-your-requests.html",
    "title": "Use fields in your requests",
    "summary": "Use fields in your requests All the endpoints that return a resource representation allow the fields query parameter. Fields are used to specify the property values you want returned for your entities. When you make a call using the fields query parameter, make sure that you: Separate the fields by commas. Query by properties and/or subproperties. Write subproperties in the following format: propertyname.subpropertyname. Familiarize yourself with the elements that get returned: The fields marked as required are always returned. If fields are not customized for a given level and the requested field is non null then the default fields will be returned. If fields are customized for a given level and the requested field is non null, the fields you requested will be returned. The rules above are applied at nested level as well. Let's look at an example to understand how the fields parameter can be used. We will perform a GET request to the /projects/projectId endpoint and we will consider that in our example the projectId= 101. 1. Fields consist of properties and subproperties. Here are some examples: Properties: id; name; customer; createdBy and so on Subproperties: customer.name; customer.keyContact; customer.location; createdBy.email and so on 2. You can make calls in several ways: No field customization Request: GET/projects/101 Response: the project identifier, the project name, the project language directions Field customization (no nesting) Request: GET/projects/101?fields=customer Response: the project identifier; the customer identifier; the customer name; the customer's key contact; the customer location Field customization (nesting) Request: GET/projects/101?fields=customer.keyContact,customer.name Response: the project identifier; the customer name; the customer's key contact"
  },
  "articles/LCPublicAPI/docs/Use-paging-and-sorting-for-lists.html": {
    "href": "articles/LCPublicAPI/docs/Use-paging-and-sorting-for-lists.html",
    "title": "Use paging and sorting for lists",
    "summary": "Use paging and sorting for lists When the outcome of a GET call is a list of items (item properties and total count), you can control the number of results displayed on a page as well as sort the results. To control the number of results displayed on a page, do the following: To retrieve the full size of an entity, make a GET call to its corresponding endpoint. For example, make a GET call to the /projects endpoint. The result consists in a list of all the projects (and their details) as well as a project count. The project count field returns the same value even if you further apply the top or skip query parameters. To display only the first 10, 20, 30 (and so on) results in your list, use the top query parameter. For example, for the /projects endpoint, your query may look like this if you are interested in the first 10 projects: /projects?top=10 To get to a particular set of retrieved results in your list, use the skip query parameter. For example, for the /projects endpoint, if you want to skip the first 100 results, your query will look like this: /projects?skip=100. To sort your list by certain properties, use the sort query parameter. The default sorting strategy is ascending. Add unary operators for ascending (+) and descending (-) sorting. If you do not add any operator, the default ascending strategy kicks in. For example, if you want to sort results by due date (-) and name (+), your query will look like this: /projects?sort=-dueBy,name. Note that sorting can be performed only on first-level fields (not nested fields), for naturally comparable types like strings, numbers, and dates."
  },
  "articles/LCPublicAPI/docs/Whats-New.html": {
    "href": "articles/LCPublicAPI/docs/Whats-New.html",
    "title": "What's new",
    "summary": "What's new 8 December 2025 With this release we deliver full management capabilities for both users and applications. The new user endpoints enable Create, Update, and Delete operations, while application management now supports all CRUD operations: Get, List, Create, Update, and Delete. As announced in November 2024, the language and targetLanguages fields in Add Source File Request now use the Language Request model. The Get Task endpoint now includes apiInternalId in the task type details response. Added a new section on token management. In early 2026, we will discontinue publishing API documentation at Trados Cloud Platform API Documentation. Our API documentation is currently available in two locations: Trados Cloud Platform API Documentation - Will be discontinued in early 2026 Trados Cloud Platform API - This will remain as the official documentation site. We will communicate the exact discontinuation date once finalized. We fixed various bugs. 29 October 2025 We've added support for advanced settings for Translation Memory operations, including powerful filter expressions and field update options. See Translation Memory Advanced Configuration for more details. We've introduced a new endpoint to reschedule workflow task deadlines, allowing you to adjust task due dates programmatically in Trados Cloud. The analysisStatistics model now includes information about locked segments. We fixed various bugs. 30 September 2025 We introduced Trados Data Bridge APIs providing secure, read-only access to Trados Cloud data. The API allows you to query project, task, cost, and quality metric data using the OData v4 protocol, and connect directly to business intelligence tools such as Power BI. As part of our multi-region support, we have added the global List My Accounts endpoint. We fixed various bugs. 10 September 2025 With this release we deliver Lookup, Concordance, Add and Update translation units to a translation memory. See this page for more details. You can now obtain and update the resources sequence information for a Translation Engine. A new project event PROJECT.STARTED has been added. See this page for more details. 18 August 2025 The new, modernized Trados Cloud Platform SDK for Java is now available. See the upgrade guide here. 12 August 2025 You can now get word count and cost estimation analysis of files without the need to create a project. The functionality is accessible via the Request File Analysis and Poll File Analysis endpoints. As previously announced, the languageProcessingRuleId parameter is now mandatory for Update Translation Engine endpoint. We fixed various bugs. 15 July 2025 You can now add the systemStatus property on termbase entries. See Update Termbase Entry. We've improved the documentation around zip files on Add Source File and Attach Source File endpoints. As a reminder, we want to let our users know that the field languageProcessingRuleId under Update Translation Engine endpoint will be mandatory. Import Termbase and Poll Termbase Import endpoints will return pending instead of queued for the status. This change is scheduled to take effect no sooner than six months from now. 8 May 2025 You can now download the target files associated with a project in a ZIP format. This functionality is accessible through three endpoints: Export, Poll, and Download. With this release we deliver the Create, Update and Delete pricing model endpoints. Together with these, several changes were required to correct the pricing model response: name : changed from required to default. additionalCosts.volumeUnitType changed from required to non required. additionalCosts.conditionalCostType changed from required to non required. additionalCosts.costOperator changed from required to non required. additionalCosts.costVariable changed from required to non required. additionalCosts.operand changed from required to non required. perTargetLanguage and perFile cost types have been removed from languageCosts to clean up the structure. We have expanded the cost types by introducing two new values: adhoc and adhoc volume. Import and Export TM endpoints are now subject to API limits. For more details, please refer to this page. We updated the Java Client samples to reflect the usage of the latest version. We fixed various bugs. 1 April 2025 As part of the Connected AI feature, we have added the following updates and new endpoints: We have introduced a new endpoint for listing Large Language Models (LLMs). We have added the functionality to update your translation engines with the new LLM resource type. We have added the source word count to the List Source Files endpoint. We fixed various bugs. 10 March 2025 We've introduced the concept of Batched Webhooks. We've updated the models for Import Translation Memory, Export Translation Memory and Get Translation Memory Import History. As part of this, the existing status field is now marked as deprecated in the response model of Import Translation Memory and Export Translation Memory. Additionally, the fields importAsPlainText and triggerRecomputeStatistics are marked as deprecated in the request model of Import Translation Memory and in the response model of Get Translation Memory Import History, alongside the traceId field. Their decommissioning is scheduled at a minimum of six months from now. 10 December 2024 You can now associate existing users with a service user to notify them of actions via email, using Trados UI. More details here. We have officially rebranded from RWS Language Cloud API to Trados Cloud Platform API. All references to our previous brand name will now reflect our new identity, Trados. Provided Postman Environments for multi-region. 18 November 2024 As part of our multi-region support, we have added global endpoints to facilitate the discovery of available regions and hosts. For more details, see the Multi-region page. We have updated the documentation on how to use the new SDK with multi-region features. Additionally, we made various minor contract corrections. As a reminder, we want to let our users know that the field languageProcessingRuleId under Update Translation Engine endpoint will become mandatory. 6 November 2024 We are planning to transition the hosting of our API from lc-api.sdl.com to api.eu.cloud.trados.com on November 9th: lc-api.sdl.com for API and integrations will remain active. Existing integrations will continue to work as before. We do recommend planning to change the URL when possible. For new integrations, we recommend using the new URL to avoid additional work in the future. You now have the ability to add notes to customer quotes. We have updated the deprecated types for the language and targetLanguages fields in the Add Source File Request model, which now reference Language Request model. In the updated API contract, these fields have been changed from simple strings to structured objects containing a languageCode property, enhancing clarity and consistency in language handling. We fixed various bugs. Note We will provide backwards compatibility until May 2025. However, starting with this release, SDKs will be updated to use the new types. Please ensure your integration is updated to use the new Language Request model. 11 September 2024 With this release we deliver the PerfectMatch functionality. You can apply PerfectMatch either at the start of a project or midway through the translation process. These capabilities are accessible via the PerfectMatch Mapping menu. We've improved filtering for projects lists. See the List Projects endpoint. A recent update has been made to the Webhooks Setup page, informing the customers that the order of webhook event deliveries cannot be guaranteed. Please take this into consideration using the timestamp field to determine the event generation time. You can now set due dates for tasks during project creation. We fixed various bugs. 28 August 2024 We have introduced a new option which allows users to switch to a different pricing model at the Customer Quote Review task using the dedicated endpoint Update Project Pricing Model. You now have the ability to view the locking color options for MTQE segments by utilizing the Get Project Template endpoint. The parameter termbaseStructure.fields.type in the Get Termbase endpoint is no longer marked as mandatory. We fixed various bugs. 1 July 2024 We updated the folder/resource locations to the new format, which now includes the path. We fixed various bugs. 9 May 2024 You can configure the number of days after which projects are given the Completed or Archived status automatically using the completionConfiguration option under the following endpoints: Create and Update Project, Create and Update Project Template. The field languageProcessingRuleId under Update Translation Engine endpoint will become mandatory. The enforcement is scheduled at a minimum of six months from now. As a reminder, we want to let our users know that we updated the folder/resource locations to the new format, which now includes the path. The old fields are marked as deprecated and their decommissioning is planned for near future. Please ensure you update the implementation if you are using fields that are marked as deprecated. We fixed various bugs. 8 April 2024 We extended the information available on the webhooks setup page, Circuit Breaker section. We removed the languageId allowed values for the Export Quote Report endpoint. As a reminder, we want to let our users know that we updated the folder/resource locations to the new format, which now includes the path. The old fields are marked as deprecated and their decommissioning is planned for near future. Please ensure you update the implementation if you are using fields that are marked as deprecated. We fixed various bugs. 27 February 2024 With this release we deliver the Update and Delete Project Template endpoints. Subsequent iterations with new implementations will follow, ensuring continuous enhancement for project template update. We published a new page about multipart considerations We fixed various bugs. 13 December 2023 With this release we deliver the Create Project Template endpoint. Subsequent iterations with new implementations will follow, ensuring continuous enhancement for project template creation. We enhanced the response model for the Get Project Template endpoint, which now includes settings for verification and batch tasks. The existing forceOnline and quoteTemplate fields from root level are now marked as deprecated, as they have been moved to the settings section. Their decommissioning is scheduled at a minimum of six months from now. Webhooks will stop trying to send on urls that cause timeouts, retrying later. Read more here. We fixed various bugs. 16 November 2023 We introduced the applicableOutcomes field under the get task endpoint to be used when completing the tasks. You can now change the folder visibility when updating a customer. We fixed various bugs. 17 October 2023 This release delivers more integrations for the customer resource type. You can now create, update and delete customers. We enhanced the response model for pricing endpoints. As previously announced, we made the dueBy, the location and the languageDirections fields mandatory for creating a project. We added deliveredBy as a new field for the update project capabilities. We extended the information available on the webhooks setup page. We fixed various bugs. 06 September 2023 With this release we deliver the create, read, update and delete endpoints of the new schedule template resource. You will find the endpoints under the schedule templates menu. You can also retrieve the schedule template attached to a project or to a project template using the relevant fields. Additionally, the create project now supports the schedule template resource, either individually or from the project template. We added the apiInternalId to task type and workflow task template to easily identify custom tasks. We fixed various bugs. 17 August 2023 We updated the folder/resource locations to the new format, which now includes the path. The old fields are marked as deprecated and their decommissioning is scheduled at a minimum of six months from now. Please ensure you update the implementation if you are using fields that are marked as deprecated. Enhanced project configuration now includes new choices for updating translation memory settings. We fixed various bugs. As a reminder, we want to let our users know that validations related to the following fields used at project creation: dueBy, location and languageDirections will become required in near future. 02 August 2023 With this release we provide a new endpoint to allow integrators to update only one custom field of a project We extended the information available on the webhooks page You can now update a translation engine as a stand alone resource or one that is linked to a live project. Read this page for more details. We fixed various bugs. 15 June 2023 We extended the information provided for both source and target files in a task with the name, the version and originatingTaskId details We made available a new rate-limits endpoint and a new header which includes the relevant policy name, namely, the X-RateLimit-Policy header. Read the API-rate-limits page for more details. We improved descriptions for the default and required fields here. We updated the JAVA samples to reflect changes in the SDK. We fixed various bugs. 19 May 2023 We replaced the friendlyId on all Project Group endpoints with shortId and we've exposed it on all Project endpoints too. As a security enhancement, we will restrict some characters in naming projects and project files. The unsupported characters are: <, >, :, \", /, \\, |, ?, *. In 6 months we will introduce the following breaking change: on the Export Quote Report endpoint, if the quote is not generated using a Quote Template, the response will be an empty object. We will enforce validations related to the following fields at project creation: dueBy, location and languageDirections. These fields will become required in 3 months. As a reminder, we want to let our users know that for security issues or bugs we may introduce breaking changes at any time. 20 April 2023 With this release we enforce validations listed in the documentation for the Create and Update Project endpoints. This impacts the SDKs, so please update your integration accordingly. We extended the webhooks functionality to support error tasks We introduced the customFields field for project webhooks, and the dueBy field for task webhooks We added the name of the customFields under the response for the Get Project endpoint We fixed various bugs. 21 March 2023 We extended the list of webhooks available for tasks, projects, project files, project templates and enabled the first webhook for project group We fixed several bugs. 03 March 2023 We introduced fields displaying the project status history and the completedAt date for a task. We exposed the project creator as a sorting option on list projects. We fixed several bugs We want to remind our users we will enforce validations listed in the documentation for the Create and Update Project endpoints. 15 February 2023 We enabled support for the Trados Enterprise Quote Template functionality We introduced the projectManagers field to enable the selection of individuals or of users groups at project creation. We removed unnecessary outcome values for the Task Completed Request model on the Complete Task operation. This impacts the SDKs, so update your integration accordingly. You can now specify the projectCreator as an assignee type for a task when updating a project. We will enforce validations related to the following fields at project creation: dueBy, location and languageDirections. These fields will become required in 6 months. 11 January 2023 You can now create, read, update and delete Project Groups We've improved filtering for projects lists, namely by status and by creation date We've introduced fields displaying more details for error tasks We fixed various bugs 22 November 2022 To enable support for the Trados Enterprise multi-source resources functionality, we're introducing an important breaking change: when creating workflows with multi-source languages from the TE UI, please use the new languageDirection scope value. As the new feature may limit previously working functionality, inconsistencies within applications or certain products may appear. For integrations that are impacted, please contact their developers to update the integrations. We've made 3 new endpoints available for TM export We removed the old 10 MB size limitations for files, termbases and translation memories. We now support these values for files and these values for importing translation memory content. Users can now retrieve task comments. We've added the TM Import history endpoint. We are postponing the breaking change in the LanguageDirectionRequest model, previously announced for November, and consequently the model can be used until the end of 2022. 4 new endpoints are subject to API limits We fixed various bugs. 28 October 2022 You can import translation memories using the import and poll endpoints. Note that the maximum size for an imported translation memory is 10 MB. We added traceability fields for terminology entries: createdAt, createdBy, lastModifiedAt, lastModifiedBy We added recommendations for HTTP headers We updated the recommendations for Authentication and the API rate limits with token values and other details We fixed various bugs 15 September 2022 We introduced a new Export Quote Report mechanism and deprecated the older endpoint We updated the constrains for the 'name' and 'description' fields for the Create Project and Update Project endpoints that will be enforced starting December 2022 We introduced a new page for the currently Known issues We fixed various bugs 22 August 2022 You can now read language processing rules and translation memory field templates You can now create, read, update, delete and copy translation memories 12 August 2022 Retiring of the Export Quote endpoint will happen in 6 months. You can read more about it here. We now support the Export Quote Report functionality with 3 new endpoints: Poll Quote Export Report, Export Quote and Download Exported Quote. You can now upload source and target file versions We published a new page about File formats We fixed various bugs 28 July 2022 We published a new page about How to use location and folders We published a new page about How to report an API issue We fixed various bugs 19 July 2022 You can now update source and target file names We fixed various bugs 28 June 2022 You can now read and update translation memory settings for a project's configuration We updated the user guide page for using fields with new animated gifs We fixed various bugs 07 June 2022 We have increased the API limits, you can find the new limits on this page. Deprecation of the language direction code will happen in 6 months. You can read more about it here. Enforce validations related to the length of the name and description fields and the accepted input values for the Create and Update Project endpoints will be delivered in 6 months. 24 May 2022 To address potentially infected files, we've updated our API contracts to support In-Product Antivirus scanning 04 May 2022 You can now upload a .zip archive using this endpoint and then poll for the extracted files. After extraction, you can upload multiple source files to a project using a single call. The maximum size for an imported .zip file is 10 MB. Our Java SDK client is now available in public beta. Here are more details on how to start integrating it into your solution We published the API limits here We updated the Custom fields page with useful gifs We fixed various bugs We update the .NET and Java client versions with each API release. 11 March 2022 You can now export a termbase and a termbase template in Trados Enterprise using the Trados Cloud Platform API We fixed various bugs 22 February 2022 You can now convert an xdt file into a termbase structure using this dedicated endpoint When updating a termbase entry you will have to provide either the name or the identifier for the termbaseFieldValues We fixed various bugs 2 February 2022 You can now import a termbase in Trados Enterprise using the Trados Cloud Platform API. The supported extensions are xml and tbx. The maximum size for an imported termbase is 10 MB. Our .NET SDK client is now available in public beta. Here are more details on how to start integrating it into your solution. We updated the basic project creation page with useful gifs and added a small Postman collection to help you get started quickly We fixed various bugs 15 December 2021 You can now create, read, update and delete terminology termbases, termbase templates and termbase entries We fixed various bugs 18 November 2021 You can now update the configurations of future tasks using the projectPlan field, in the update project endpoint Fixed various bugs 20 October 2021 Basic project creation flow added Fixed various bugs 04 October 2021 Added multiple date formats Added pagination for List File Processing Configurations endpoint Fixed various bugs 08 September 2021 Added support for downloading quote files Enum values updated to follow camelCase convention Updated documentation for projectTemplate in create project request Renamed customProperty to customFields in error responses Improved documentation for Reclaim Task Updated documentation for Quotes 26 August 2021 Added support to restrict file downloads When creating/updating projects using a project template which has mandatory custom fields, you must supply those custom fields Fixed various bugs We will remove deprecated fields from the ErrorResponse model in an upcoming release. Please ensure you are not using fields marked as deprecated! 29 July 2021 Added endpoints for custom field definitions. Added support for custom fields on projects and project templates. The translationEngine, fileProcessingConfiguration, workflow fields are now required on the /projects endpoint. The isSkipped field is now marked as required on the /workflow/updateworkflow endpoint. Added new assignee type projectCreator when retrieving workflows. Improved contract documentation on TQA endpoints. Fixed various bugs. 08 June 2021 For endpoints that return multiple items, the top query parameter has a default value of 100 and a maximum value of 100; skip has a default value of 0. The Authorization and X-LC-Tenant headers are now required for all endpoints. Improved the returned error structure. Fixed various issues with incorrect contract. Added new conditional cost fields (costOrder, conditionalCostType, conditionalCostOperator, conditionalCostVariable, conditionalCostThreshold) when working with project quotes. Added currency types for quote model. 17 May 2021 A Postman Collection is now available for integrators. Check out this page for details. 10 February 2021 Target File > Download File Version endpoint When you make a GET request to the /projects/{projectId}/target-files/{targetFileId}/versions/{fileVersionId}/download endpoint, you can now perform a direct download of the native file as well as of the BCM file version. Target File > Export Target File Version endpoint When you make a POST request to the /projects/{projectId}/target-files/{targetFileId}/versions/{fileVersionId}/exports endpoint, you now have a query parameter where you can specify whether the file version export should be a native file or an sdlxliff file. The default value is native. 28 January 2021 Project > List Project's Tasks endpoint When you make a GET request to the /projects/{projectId}/tasks endpoint, you can now retrieve the available project tasks and their details. Retrieving tasks Retrieving tasks provides the following new additional details: the Vendor Order Quote information the translation status for each task: the type of matches, the number of segments, the number of words/characters. Specifying target languages for source files When adding source files to a project, you can specify their target languages via the targetLanguages and path elements. ^. .^"
  },
  "articles/LCPublicAPI/docs/Whats-deprecated.html": {
    "href": "articles/LCPublicAPI/docs/Whats-deprecated.html",
    "title": "What's Deprecated",
    "summary": "What's Deprecated 1 July 2024 We have removed the old fields in the folder/resource structure and are no longer available. Use the path field going forward. 13 December 2023 The Export Quote endpoint has been removed. In the Get Project Template model we deprecated: forceOnline field from root level and we added forceOnline to the settings  general quoteTemplate field from root level and we added quoteTemplate to the settings  general They will only be available for use until July 2024. 17 August 2023 We updated the folder/resource locations to the new format, which now includes the path. The old fields are marked as deprecated and their decommissioning is scheduled at a minimum of six months from now. 12 August 2022 In the Quote code, we deprecated the Export Quote endpoint. It will only be available for use until December 2022. 7 June 2022 In the LanguageDirectionRequest model we deprecated: the sourceLanguageCode field and introduced sourceLanguage as an object containing the languageCode field; the targetLanguageCode field and introduced targetLanguage as an object containing the languageCode field. They will no longer be available to use starting with November 2022. 8 September 2021 We removed deprecated fields from the ErrorResponse model."
  },
  "articles/LCPublicAPI/docs/api-clients/java/Java-Client-Upgrade-Guide.html": {
    "href": "articles/LCPublicAPI/docs/api-clients/java/Java-Client-Upgrade-Guide.html",
    "title": "Trados Cloud Platform SDK - Migration Guide v25.x.x",
    "summary": "Trados Cloud Platform SDK - Migration Guide v25.x.x Executive Summary The Trados Cloud Platform API SDK has transitioned from a \"fat JAR\" to a \"light JAR\" architecture, delivering faster downloads, improved dependency management, and better build performance. For most users, migration requires only a version update in your build configuration. What Changed: Modernized Dependencies: JUnit 4  5, Apache HttpClient 4  5, Commons Lang 23 OpenAPI Generator: Version 6.5.0  7.14.0 with enhanced nullability annotations Enhanced Features: New LCContext.executeInScope() methods for improved tenant/trace context management Updated Tooling: Latest versions of Jackson, Feign, and other core libraries Step-by-Step Migration Guide For Standard API Usage (Most Users): If you're using the generated SDK classes like ProjectApi, SourceFileApi, etc., migration is straightforward: Update SDK version to 25.x.x in your build configuration. Run your build command to verify everything works. Review and update your code for compatibility with the new OpenAPI Generator output (see the section OpenAPI Generator & Generated Code Changes below for details). Your API calls should work as before, but review and resolve any compilation issues related to the above changes. // Your existing code continues to work ProjectApi projectApi = languageCloudClientProvider.getProjectClient(); Project project = projectApi.createProject(projectCreateRequest, queryParams); Troubleshooting Most Common Issue: Build fails after version update Solution: Run mvn dependency:tree to check for dependency conflicts Issue: ClassNotFoundException: feign.Client Solution: Verify Feign dependencies: mvn dependency:tree | grep feign Issue: NoClassDefFoundError for HTTP client classes Solution: Update imports from org.apache.http to org.apache.hc.core5.http Issue: Commons Lang methods not found Solution: Update imports from org.apache.commons.lang to org.apache.commons.lang3 Success Validation For Standard Users: Clean build: mvn clean install succeeds API functionality works as before Faster builds and smaller downloads For Advanced Users: Run mvn dependency:tree - no conflicts shown Test application startup and core functionality Advanced Scenarios Click here if you use direct dependency imports or custom configurations Direct Dependency Usage: Update HttpClient imports: org.apache.http  org.apache.hc.core5.http Update Commons Lang imports: org.apache.commons.lang  org.apache.commons.lang3 Use dependency exclusions if you encounter version conflicts Custom Classpath Management: Review current JAR collection and identify SDK dependencies Ensure all transitive dependencies are included in classpath Test application startup and core functionality Consider migrating to Maven/Gradle for simplified dependency management Test Framework Updates: JUnit Migration: JUnit 4  JUnit 5 (Jupiter) Update test annotations: @Test imports change from org.junit.Test  org.junit.jupiter.api.Test Replace @Before/@After with @BeforeEach/@AfterEach Update assertion imports: org.junit.Assert  org.junit.jupiter.api.Assertions Mockito Updates: Version 3.x  5.x Update imports if using mockito-junit-jupiter directly Verify mock behavior with newer Mockito features OpenAPI Generator & Generated Code Changes: OpenAPI Generator: Version 6.5.0  7.14.0 (major version upgrade) Generated Code Improvements: Enhanced code generation with: New Nullability Annotations: @javax.annotation.Nullable and @javax.annotation.Nonnull annotations for better null safety Bean Validation Support: Enhanced validation annotations for API parameters Improved Code Quality: Updated Mustache templates producing cleaner, more maintainable generated code Better Method Naming: Collection helper methods use improved naming conventions for better readability Enhanced Enum Handling: Improved enum comparison and naming with configurable case sensitivity support Modernized Templates: Generated classes follow current Java best practices Benefits: Generated classes are easier to use and understand Better IDE support with improved nullability annotations More consistent naming conventions across generated code Enhanced type safety and validation Validation & Success Criteria For Standard Users: Clean Build: Your project builds successfully API Functionality: SDK operations work as before - no code changes needed Performance: Faster builds and smaller downloads Advanced Validation: Dependency Check: mvn dependency:tree shows no conflicts Custom Configurations: Test application startup and functionality Reference: Key Dependencies High-Impact Dependencies (Most Likely to Affect You) Library Previous New Notes Feign (HTTP Client) 10.11 13.6 Core SDK communication Jackson (JSON) 2.10.3 2.19.1 API serialization Apache HttpClient 4.5.8 5.5 HTTP transport JUnit (Tests) 4.13 5.13.2 Test framework modernization View Complete Dependency List All Updated Dependencies: GroupId ArtifactId Previous Version New Version Impact io.github.openfeign feign-core 10.11 13.6 High io.github.openfeign feign-jackson 10.11 13.6 High io.github.openfeign feign-slf4j 10.11 13.6 High io.github.openfeign feign-form 3.8.0 13.6 High io.github.openfeign feign-okhttp 10.11 13.6 High com.fasterxml.jackson.core jackson-core 2.10.3 2.19.1 Medium com.fasterxml.jackson.core jackson-annotations 2.10.3 2.19.1 Medium com.fasterxml.jackson.core jackson-databind 2.10.3 2.19.1 Medium org.apache.httpcomponents.client5 httpclient5 4.5.8* 5.5 Medium com.fasterxml.jackson.datatype jackson-datatype-jsr310 2.10.3 2.19.1 Low com.fasterxml.jackson.datatype jackson-datatype-joda 2.0.4 2.19.1 Low org.openapitools jackson-databind-nullable 0.2.1 0.2.6 Low org.apache.commons commons-lang3 2.6* 3.18.0 Low com.github.spotbugs spotbugs-annotations 3.0.2* 4.9.3 Low javax.annotation javax.annotation-api 1.0* 1.3.2 Low org.projectlombok lombok RELEASE 1.18.38 Low org.slf4j slf4j-simple - 2.0.13 Low *Different groupId or artifactId in previous version Test Dependencies GroupId ArtifactId Previous Version New Version Impact org.junit.jupiter junit-jupiter-engine 4.13* 5.13.2 High org.mockito mockito-junit-jupiter 3.12.1* 5.18.0 High *Different groupId or artifactId in previous version Most Important Changes Critical: Maven Shade Plugin removed (enables fatlight JAR transition) Modernization: All dependencies updated to current versions Code Quality: OpenAPI Generator 6.5.0  7.14.0 with better nullability support"
  },
  "articles/LCPublicAPI/docs/api-clients/java/Java-Client.html": {
    "href": "articles/LCPublicAPI/docs/api-clients/java/Java-Client.html",
    "title": "Java Client",
    "summary": "Java Client This client library targets Java 11 and above. It provides API clients organized by API documentation sections. The generated Java clients are based on OpenFeign. Note The Java Client library is auto-generated from the current API contracts, so any updates to the contract will reflect as changes in the SDK client. Minor version increases do not guarantee backwards compatibility. Installation You can add this library to your project as a Maven dependency. Include the client library in the pom.xml: <dependency> <groupId>com.rws.lt.lc.public-api</groupId> <artifactId>lc-public-api-sdk</artifactId> <version>24.0.9</version> </dependency> Note Make sure to always reference the latest available version. Check the Maven Central Repository for more info. Usage We will use the project creation flow as an example to show how the API clients can be used. API clients can be initialized individually based on the endpoints you need to target. If authorization was provided when instantiating the client, it's not required again when calling its methods. Trados Cloud Platform operates in multiple regions; ensure you select the correct region for your integration. See the Multi Region page for more details. The default region for LanguageCloudClientProvider is eu, but you can override it. For example, to use Project features, instantiate a Project client like this: // define credentials ServiceCredentials serviceCredentials = new ServiceCredentials(\"YOUR_CLIENT_ID\", \"YOUR_CLIENT_SECRET\", \"YOUR_TENANT_ID\"); // instantiate the LanguageCloudClientProvider LanguageCloudClientProvider languageCloudClientProvider = LanguageCloudClientProvider.builder() .withRegionCode(\"ca\") // default is \"eu\" .withServiceCredentials(serviceCredentials) .build(); // instantiate the client ProjectApi projectApi = languageCloudClientProvider.getProjectClient(); Token management The LanguageCloudClientProvider handles token management automatically. Here are the key points: Automatic token handling: You do not need to fetch or manage auth tokens directly. The LanguageCloudClientProvider obtains a valid token based on the provided service credentials automatically. Token caching: Tokens are cached until expiration minus 1 minute, ensuring that tokens do not expire mid-call even if the API call takes longer. After that, the token is cleaned up from the cache, and a new one is generated automatically. Singleton cache pattern: The token cache is implemented with a singleton pattern, so it does not make a difference if a single LanguageCloudClientProvider is instantiated or multiple onesthere is always a single cache per application. No need to recreate instances: You do not need to destroy and recreate LanguageCloudClientProvider or any of the underlying API clients (e.g., ProjectApi via languageCloudClientProvider.getProjectClient()). One instance per application is sufficient. Note The 16 requests per day limit mentioned in the Authentication documentation refers to Auth0 token requests, not API calls. Since the Java Client SDK caches tokens automatically, your application typically only makes one Auth0 token request per day (unless the application is restarted). Warning While the SDK handles token management, you still need to handle API rate limits and implement proper handling for HTTP 429 (Too Many Requests) responses. See the Implementation recommendations for guidance. 1. Create a new project: ProjectCreateRequest projectCreateRequest = new ProjectCreateRequest(); projectCreateRequest.setName(\"YOUR_PROJECT_NAME\"); projectCreateRequest.setDueBy(DateTime.parse(\"2025-01-01T00:00:00.000Z\")); projectCreateRequest.setProjectTemplate(new ObjectIdRequest().id(\"YOUR_PROJECT_TEMPLATE_ID\")); // Set the `fields` query parameter so the response is populated with `projectPlan.taskConfigurations` ProjectApi.CreateProjectQueryParams queryParams = new ProjectApi.CreateProjectQueryParams(); queryParams.fields(\"projectPlan.taskConfigurations\"); Project projectCreateResponse = projectApi.createProject(projectCreateRequest, queryParams); 2. Attach a source file to the project: Projects that do not contain source files cannot be started. SourceFileApi sourceFileApi = languageCloudClientProvider.getSourceFileClient(); SourceFileRequest properties = new SourceFileRequest(); properties.setLanguage(new LanguageRequest(\"en-US\")); properties.setName(\"YOUR_TEXT_SOURCE_FILE\"); properties.setRole(SourceFileRequest.RoleEnum.TRANSLATABLE); properties.setType(SourceFileRequest.TypeEnum.NATIVE); File file = new File(\"YOUR_TEXT_SOURCE_FILE_PATH\"); SourceFile sourceFile = sourceFileApi.addSourceFile(\"YOUR_PROJECT_ID\", properties, file); 3. Start the project: projectApi.startProject(\"YOUR_PROJECT_ID\"); 4. Get the project details: Project project = projectApi.getProject(\"YOUR_PROJECT_ID\", \"status,quote.totalAmount\");"
  },
  "articles/LCPublicAPI/docs/api-clients/java/Java-Samples.html": {
    "href": "articles/LCPublicAPI/docs/api-clients/java/Java-Samples.html",
    "title": "Trados Cloud Platform SDK Samples for Java",
    "summary": "Trados Cloud Platform SDK Samples for Java Console Application Sample The console application sample is available for download on GitHub. The sample contains three examples of how to instantiate and work with an API client provided by the Trados Cloud Platform SDK. You can either use the supplied provider or handle the authentication yourself: 1. Instantiating a client using service credentials You can instantiate a client using the provided LanguageCloudClientProvider.builder() pattern. This method requires you to provide a ServiceCredentials object containing your clientID, clientSecret, and tenant. See the Authentication page for more details. import com.rws.lt.lc.publicapi.sdk.api.GroupApi; import com.rws.lt.lc.publicapi.sdk.auth.ServiceCredentials; import com.rws.lt.lc.publicapi.sdk.client.LanguageCloudClientProvider; import com.rws.lt.lc.publicapi.sdk.model.Group; import com.rws.lt.lc.publicapi.sdk.model.ListGroupsResponse; import java.util.stream.Collectors; ... //instantiate the credentials ServiceCredentials serviceCredentials = new ServiceCredentials(\"YOUR_CLIENT_ID\", \"YOUR_CLIENT_SECRET\", \"YOUR_TENANT_ID\"); // instantiate the LanguageCloudClientProvider LanguageCloudClientProvider languageCloudClientProvider = LanguageCloudClientProvider .builder() .withRegion(\"eu\") // optional (default is \"eu\") .withServiceCredentials(serviceCredentials) .build(); // instantiate the client GroupApi groupApi = languageCloudClientProvider.getGroupClient(); // use the client ListGroupsResponse groupsResponse = groupApi.listGroups(new GroupApi.ListGroupsQueryParams()); System.out.println(\"Groups:\"); System.out.println( groupsResponse.getItems().stream() .map(Group::getName) .collect(Collectors.joining(\"\\n\"))); *Using this method, a unique TraceID will be generated for each request. Note Make sure you always keep your credentials safe. 2. Instantiating a client using context scoping This method allows you to make API calls with multiple different service credentials using the same client instance. We provide an LCContext which exposes scoping options. You can use this to scope your API calls in different contexts. The sample contains an example with two different service credentials: import com.rws.lt.lc.publicapi.sdk.api.UserApi; import com.rws.lt.lc.publicapi.sdk.auth.ServiceCredentials; import com.rws.lt.lc.publicapi.sdk.client.LanguageCloudClientProvider; import com.rws.lt.lc.publicapi.sdk.context.ContextKeys; import com.rws.lt.lc.publicapi.sdk.context.LCContext; import com.rws.lt.lc.publicapi.sdk.model.ListUsersResponse; import com.rws.lt.lc.publicapi.sdk.model.User; import java.util.stream.Collectors; ... // define credentials for your first user ServiceCredentials credentials_1 = new ServiceCredentials(\"YOUR_CLIENT_ID_1\", \"YOUR_CLIENT_SECRET_1\", \"YOUR_TENANT_ID_1\"); // define credentials for your second user ServiceCredentials credentials_2 = new ServiceCredentials(\"YOUR_CLIENT_ID_2\", \"YOUR_CLIENT_SECRET_2\", \"YOUR_TENANT_ID_2\"); // instantiate the LanguageCloudClientProvider LanguageCloudClientProvider languageCloudClientProvider_contextAuth = LanguageCloudClientProvider .builder() .withRegion(\"eu\") // optional (default is \"eu\") .build(); // instantiate the client without credentials UserApi userApi = languageCloudClientProvider_contextAuth.getUserClient(); Runnable listUsersExecutable = () -> { ListUsersResponse usersResponse = userApi.listUsers(new UserApi.ListUsersQueryParams()); System.out.println(LCContext.getFromLCContext(ContextKeys.TRACE_ID_KEY) + \" >> Users for tenant \" + LCContext.getFromLCContext(ContextKeys.TENANT_ID_KEY) + \" are:\"); System.out.println(usersResponse.getItems().stream().map(User::getId).collect(Collectors.joining(\"\\n\"))); }; // create a context scope and execute inside with tenant 1 LCContext.executeInScope(listUsersExecutable, serviceCredentials1, \"trace-id-1\"); System.out.println(\"--------------------------------------------------\"); // create a context scope and execute inside with tenant 2 LCContext.executeInScope(listUsersExecutable, serviceCredentials2, \"trace-id-2\"); 3. Instantiating a client with App service credentials This method allows you to make an API call from an App for different tenants using the same client instance. See more at Extensibility Docs. We provide an LCContext which exposes scoping options. You can use this to scope your API calls in different contexts. The sample contains an example with an App installed in multiple tenants: import com.rws.lt.lc.publicapi.sdk.api.UserApi; import com.rws.lt.lc.publicapi.sdk.auth.ServiceCredentials; import com.rws.lt.lc.publicapi.sdk.client.LanguageCloudClientProvider; import com.rws.lt.lc.publicapi.sdk.context.ContextKeys; import com.rws.lt.lc.publicapi.sdk.context.LCContext; import com.rws.lt.lc.publicapi.sdk.model.ListUsersResponse; import com.rws.lt.lc.publicapi.sdk.model.User; import java.util.stream.Collectors; ... //instantiate the credentials ServiceCredentials serviceCredentials = new ServiceCredentials(\"YOUR_CLIENT_ID_1\", \"YOUR_CLIENT_SECRET_1\"); // instantiate the LanguageCloudClientProvider LanguageCloudClientProvider languageCloudClientProvider_contextAuth = LanguageCloudClientProvider .builder() .withRegion(\"eu\") // optional (default is \"eu\") .withServiceCredentials(serviceCredentials) .build(); // instantiate the client without credentials UserApi userApi = languageCloudClientProvider_contextAuth.getUserClient(); Runnable listUsersExecutable = () -> { ListUsersResponse usersResponse = userApi.listUsers(new UserApi.ListUsersQueryParams()); System.out.println(LCContext.getFromLCContext(ContextKeys.TRACE_ID_KEY) + \" >> Users for tenant \" + LCContext.getFromLCContext(ContextKeys.TENANT_ID_KEY) + \" are:\"); System.out.println(usersResponse.getItems().stream().map(User::getId).collect(Collectors.joining(\"\\n\"))); }; // create a context scope and execute inside with tenant 1 LCContext.executeInScope(listUsersExecutable, TENANT_VALUE_1, \"trace-id-1\"); System.out.println(\"--------------------------------------------------\"); // create a context scope and execute inside with tenant 2 LCContext.executeInScope(listUsersExecutable, TENANT_VALUE_2, \"trace-id-2\"); 4. Instantiating a client using custom authentication If you want complete control over client authentication, you can provide a CustomServiceAuthenticationHandler: import com.rws.lt.lc.publicapi.sdk.api.ProjectApi; import com.rws.lt.lc.publicapi.sdk.auth.AuthenticationService; import com.rws.lt.lc.publicapi.sdk.auth.CustomServiceAuthenticationHandler; import com.rws.lt.lc.publicapi.sdk.auth.ServiceCredentials; import com.rws.lt.lc.publicapi.sdk.client.LanguageCloudClientProvider; import com.rws.lt.lc.publicapi.sdk.model.ListProjectsResponse; import java.util.List; import java.util.UUID; ... AuthenticationService authenticationService = AuthenticationService.getInstance(); CustomServiceAuthenticationHandler customServiceAuthenticationHandler = new CustomServiceAuthenticationHandler(authenticationService) { @Override public ServiceCredentials getServiceCredentials() { return new ServiceCredentials(CLIENT_ID, CLIENT_SECRET); } @Override public String getTraceId() { return UUID.randomUUID().toString(); } @Override public String getTenantId() { return TENANT_VALUE; } }; LanguageCloudClientProvider languageCloudCustomClientProvider = LanguageCloudClientProvider .builder() .withRegion(\"eu\") // optional (default is \"eu\") .withRequestInterceptors(List.of(customServiceAuthenticationHandler)) .build(); // instantiate the client ProjectApi projectApi = languageCloudCustomClientProvider.getProjectClient(); // use the client ListProjectsResponse projectsResponse = projectApi.listProjects(new ProjectApi.ListProjectsQueryParams()); System.out.println(\"Projects:\"); System.out.println(projectsResponse.getItems()); Web API Sample The web API sample is available for download on GitHub. The sample contains two examples of how to instantiate and work with an API client provided by the Trados Cloud Platform SDK for Java: If you want to use the provided authentication mechanism, create a custom handler that inherits from CustomServiceAuthenticationHandler. In our example, we created the CustomAuthenticationHandler class, which inherits from CustomServiceAuthenticationHandler. The CustomServiceAuthenticationHandler class already provides an authentication mechanism. We have overridden the getServiceCredentials, getTraceId, and getTenantId methods and provided our implementations, as these will be called by CustomAuthenticationHandler: // Provide your implementation. A possible example can be: @Override public ServiceCredentials getServiceCredentials() { return repository.getServiceCredentialsById(getCurrentUser().getUserId()); } // serviceCredentials may or may not be bound to a tenant @Override public String getTenantId() { return repository.getServiceCredentialsById(getCurrentUser().getUserId()).getTenantId(); // or // return repository.getTenantForUserId(getCurrentUser().getUserId()); } @Override public String getTraceId() { return UUID.randomUUID().toString(); } private User getCurrentUser() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); return (User) authentication.getPrincipal(); } We registered an instance of LanguageCloudClientProvider as a bean in the ConfigClass class and created beans for all exposed API clients: // the LanguageCloudClientProvider instance @Bean public LanguageCloudClientProvider getPublicApiClient(CustomAuthenticationHandler customAuthenticationHandler) { return LanguageCloudClientProvider.builder() .withRegion(\"eu\") // optional (default is \"eu\") .withRequestInterceptors(List.of(customAuthenticationHandler)).build(); } //the AccountApi bean @Bean public AccountApi getAccountApi(LanguageCloudClientProvider languageCloudClientProvider) { return languageCloudClientProvider.getAccountClient(); } We can then use the registered client in the controller (or any other class resolved through Dependency Injection): @RestController public class AccountController extends ResponseEntityExceptionHandler { @Autowired private AccountApi accountApi; @GetMapping(\"/getAccounts/{userId}\") public List<Account> listAccounts(@PathVariable(\"userId\") int userId) { User user = new User(userId); Authentication authentication = new UsernamePasswordAuthenticationToken(user, null); SecurityContext sc = SecurityContextHolder.getContext(); sc.setAuthentication(authentication); ListMyAccountsResponse listMyAccountsResponse = accountApi.listMyAccounts(); return listMyAccountsResponse.getItems(); } }"
  },
  "articles/LCPublicAPI/docs/api-clients/net/NET-Client.html": {
    "href": "articles/LCPublicAPI/docs/api-clients/net/NET-Client.html",
    "title": ".NET Client",
    "summary": ".NET Client .NET Client is a collection of API clients structured in accordance with the API documentation, meaning each section will have its own client. It is built on .NET Standard 2.0. For compatibility information, see the Microsoft implementation support page. Note The .NET Client library is auto-generated from the current API contracts, so any updates to the contract will reflect as changes in the SDK client. Minor version increases do not guarantee backwards compatibility. Installation You can add the .NET Client library to your project from Rws.LanguageCloud.Sdk NuGet. Usage We will take the project creation flow as an example to show how the API clients can be used. 1. Add the using statement: using Rws.LanguageCloud.Sdk; 2. Get a new Project client: First step is to get an instance of LanguageCloudClientProvider. The constructor has 2 optional parameters region and baseUrl. When using the constructor with no parameters, the provider will be instantiated for the eu region. Any clients created by this instance will be calling on the EU region. If you need to specify a different region, instantiate it with the region specified. Region is specified by it's code, ex: eu, ca, etc, The second optional parameter baseUrl is used if you want to test the client with a mock server. You can request a new API client from the LanguageCloudClientProvider instance. There are 3 methods exposed for each client: GetProjectClient (ServiceCredentials credentials, params DelegatingHandler[] handlers) This method accepts a ServiceCredentials object which will be used to perform authentication using an implicit authentication handler. Custom handlers are also accepted. GetProjectClientNoAuth (params DelegatingHandler[] handlers) This method accepts custom handlers and does not perform any authentication implicitly. You must handle authentication in a custom handler when using this method. GetProjectClient (params DelegatingHandler[] handlers)` This method accepts custom handlers and can be used to authenticate using scoping/context. Warning On each call to GetProjectClient or GetProjectClientNoAuth a new instance is created. That means a new HttpClient for each one. You should avoid having more than one instance - and should share that using Dependency Injection or other mechanisms. In this example we will use the credentials options to get a new Project Client and we won't supply any additional handlers: // define credentials ServiceCredentials credentials = new ServiceCredentials(\"YOUR_CLIENT_ID\", \"YOUR_CLIENT_SECRET\", \"YOUR_TENANT_ID\"); // instantiate the provider var clientProvider = new LanguageCloudClientProvider(\"eu\"); // instantiate the client var projectClient = clientProvider.GetProjectClient(credentials); Since each client exposes its available operations according to the API documentation, you can find the GetProject operation in the Project client. 3. Create a new project: var projectCreateRequest = new ProjectCreateRequest { Name = \"YOUR_PROJECT_NAME\", DueBy = DateTime.Now.AddDays(7), ProjectTemplate = new ObjectIdRequest { Id = \"YOUR_PROJECT_TEMPLATE_ID\" } }; var projectCreateResponse = await projectClient.CreateProjectAsync(projectCreateRequest); 4. Attach a source file to the project via the SourceFiles client: Projects that do not contain source files cannot be started. First, GET the SourceFiles client: // define credentials ServiceCredentials credentials = new ServiceCredentials(\"YOUR_CLIENT_ID\", \"YOUR_CLIENT_SECRET\", \"YOUR_TENANT_ID\"); // instantiate the provider var clientProvider = new LanguageCloudClientProvider(\"eu\"); // instantiate the client var sourceFileClient = clientProvider.GetSourceFileClient(credentials); Then, attach a source file to the project: using (FileStream SourceStream = File.Open(\"YOUR_TEXT_SOURCE_FILE\", FileMode.Open)) { FileParameter file = new FileParameter(SourceStream, \"YOUR_TEXT_SOURCE_FILE\", \"text/plain\"); SourceFileRequest properties = new SourceFileRequest { Name = \"YOUR_TEXT_SOURCE_FILE\", Role = SourceFileRequestRole.Translatable, Type = SourceFileRequestType.Native, Language = \"en-US\", }; await sourceFileClient.AddSourceFileAsync(\"YOUR_PROJECT_ID\", properties ,file); } 5. Start the project: await projectClient.StartProjectAsync(\"YOUR_PROJECT_ID\"); 6. GET the project details using the Project client: var myProject = await projectClient.GetProjectAsync(\"YOUR_PROJECT_ID\"); 7. (Optional) Supply the fields parameter and retrieve specific data about the project: var myProject = await projectClient.GetProjectAsync(\"YOUR_PROJECT_ID\", \"status,quote.totalAmount\"); Token management When using GetProjectClient with ServiceCredentials, the client handles token management automatically: Automatic token handling: You do not need to fetch or manage auth tokens directly. The implicit authentication handler obtains a valid token based on the provided service credentials automatically. Token caching: Tokens are cached until expiration, ensuring efficient reuse without unnecessary Auth0 requests. Single instance pattern: To avoid creating multiple HttpClient instances (and thus multiple token caches), reuse the same client instance via Dependency Injection or similar mechanisms. Note The 16 requests per day limit mentioned in the Authentication documentation refers to Auth0 token requests, not API calls. Since the .NET Client SDK caches tokens automatically, your application typically only makes one Auth0 token request per day (unless the application is restarted or multiple instances are running). See Token caching behavior for more details. Warning While the SDK handles token management, you still need to handle API rate limits and implement proper handling for HTTP 429 (Too Many Requests) responses. See the Implementation recommendations for guidance. Error handling The SDK may throw the following exceptions: Exception Type Exception description ModelDeserializationException Response could not be deserialized ApiUnauthorizedException The user could not be identified ApiPermissionException The user does not have permission to access this resource ApiForbiddenException The user does not have access to the resource ApiErrorException Something went wrong when performing the action ApiConnectionException Something went wrong when connecting to the server TaskCanceledException A timeout occurred. This exception is provided by Microsoft in System.Threading.Tasks namespace. All these exceptions inherit from ApiClientException and provide an ApiErrorResponse object which contains details about the error that occurred. You may use this object in combination with the ErrorCode class to perform exception handling: try { // your API Client interaction code } catch (ApiForbiddenException e) { // handle exception... } catch (ApiUnauthorizedException e) { // handle exception... } // we can limit what specific API Errors we want to handle: catch (ApiErrorException e) where (e.ApiError.ErrorCode == ErrorCodes.MaxSize) { // One of the fields in your call, has value higher then allowed // We get the summary message: string summary = e.ApiError.Message; // Next we can get the list of fields that failed validation: foreach (var detail in e.ApiError.Details) { // TODO } } Additionally, the ApiErrorResponse.Details object contains specific error data that may be useful. Error Codes The ErrorCodes static class provides a series of constant strings suitable to be used for error code validation. Please check the Rest API documentation for specific codes any endpoint may return and what that value means in the specific context."
  },
  "articles/LCPublicAPI/docs/api-clients/net/Net-Samples.html": {
    "href": "articles/LCPublicAPI/docs/api-clients/net/Net-Samples.html",
    "title": "Trados Cloud Platform SDK Samples for .NET",
    "summary": "Trados Cloud Platform SDK Samples for .NET Console Application Sample The console application sample is available for download on GitHub. It contains 3 examples of how to instantiate and work with an API client provided by the Trados Cloud Platform SDK. You can either use the supplied provider, or handle the client instantiation on you own: Instantiating a client using credentials You can instantiate a client using the supplied LanguageCloudClientProvider class. This method requires you provide a ServiceCredentials object, which contains your clientID, clientSecret and the tenant. See the Authentication page for more details. using Rws.LanguageCloud.Sdk; ... // define credentials ServiceCredentials credentials = new ServiceCredentials(\"client-id\", \"client-secret\", \"tenant\"); // instantiate the provider var clientProvider = new LanguageCloudClientProvider(\"eu\"); // Instantiate the client var projectClient = clientProvider.GetProjectClient(credentials); // use the client var projectsResponse = await projectClient.ListProjectsAsync(); *Using this method, a unique TraceId will be generated on each request. Note Make sure you always keep your credentials safe. Instantiating a client using context scoping This method allows you to make an API call with 2 different users, using the same client instance. We provide an ApiClientContext which exposes some scoping options. You can use this to scope your API calls in different contexts. The sample contains an example with 2 different users: using Rws.LanguageCloud.Sdk; using Sdl.ApiClientSdk.Core; ... // define credentials for your first user ServiceCredentials credentials_1 = new ServiceCredentials(\"client-id-1\", \"client-secret-1\", \"tenant-1\"); // define credentials for your second user ServiceCredentials credentials_2 = new ServiceCredentials(\"client-id-2\", \"client-secret-2\", \"tenant-2\"); // instantiate the provider var clientProvider = new LanguageCloudClientProvider(\"eu\"); // instantiate the client without credentials var client = clientProvider.GetProjectClient(); // create a context scope and use the client. You can also provide your own traceId using (ApiClientContext.BeginScope(new LCContext(credentials_1, \"trace-id-1\"))) { // the client will use the credentials_1 and \"trace-id-1\" defined in the scope var projectsResponse = await projectClient.ListProjectsAsync(); } // create a context scope and use the client. You can also provide your own traceId using (ApiClientContext.BeginScope(new LCContext(credentials_2, \"trace-id-2\"))) { // the client will use the credentials_2 and \"trace-id-2\" defined in the scope var projectsResponse = await projectClient.ListProjectsAsync(); } Instantiating a client using a custom handler If you would like to control the authentication process, you should use the method which does not perform any authentication implicitly. You can provide your own authentication implementation via a custom handler: // define credentials ServiceCredentials credentials = new ServiceCredentials(\"client-id\", \"client-secret\", \"tenant\"); // get an authentication handler ServiceAuthenticationHandler handler = new ServiceAuthenticationHandler(credentials); // instantiate the provider var clientProvider = new LanguageCloudClientProvider(\"eu\"); // get a client with the custom handler var client = clientProvider.GetProjectClientNoAuth(handler); // use the client var projectsResponse = await projectClient.ListProjectsAsync(); Web API Dependency Injection Sample The web API sample is available for download on GitHub. It contains an example of how to instantiate and work with an API client provided by the Trados Cloud Platform SDK for ASP .Net. Note If you want to use the provided authentication mechanism, a custom handler can be created, which must inherit from LCCustomAuthenticationHandler. Note If you want to handle authentication and tracing on you own, you could implement your own DelegatingHandler. In our example, we've created the LcHandler class, which inherits from LCCustomAuthenticationHandler. The LCCustomAuthenticationHandler class already provides us with an authentication mechanism. We've overwritten the GetServiceCredentials and GetTraceId methods and provided our own implementations, as these will be called by LCCustomAuthenticationHandler: // Provide you own implementation. A possible example can be: protected override ServiceCredentials GetServiceCredentials() { int accountId = int.Parse(context.HttpContext.User.Claims.Single(x => x.Type.Equals(\"aid\")).Value); ServiceCredentials credentials = repository.GetServiceCredentialsById(accountId); return credentials; } ... // Provide you own implementation. A possible example can be: protected override string GetTraceId() { return DateTimeOffset.UtcNow.ToString(); } We'll need a bit of custom magic to make sure dependency injection works correctly for multi-region. We'll create a custom Factory to provide our clients. An example implementation would be a factory class to provide a per region factory. We'll make sure to have all instances initialized only once, to avoid problems: class RegionClientContainerFactory { LanguageCloudClientProvider _languageCloudClientProvider; IServiceProvider _serviceProvider; private IAccountClient _accountClient; public RegionClientContainerFactory(string region, IServiceProvider serviceProvider) { _languageCloudClientProvider = new LanguageCloudClientProvider(region); _serviceProvider = serviceProvider; } public IAccountClient AccountClient { get { // get custom authentication handler LcHandler handler = _serviceProvider.GetRequiredService<LcHandler>(); // ensure account client is instantiated only once return _accountClient ??= _languageCloudClientProvider.GetAccountClient(handler); } } } class LanguageCloudClientFactory { private object _lock = new object(); private IServiceProvider _serviceProvider; ConcurrentDictionary<string, RegionClientContainerFactory> _regionClientContainerFactories = new ConcurrentDictionary<string, RegionClientContainerFactory>(); LanguageCloudClientFactory(IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; } public RegionClientContainerFactory Region(string region) { if (!_regionClientContainerFactories.TryGetValue(region, out RegionClientContainerFactory regionClientContainerFactory)) { lock (_lock) { if (!_regionClientContainerFactories.TryGetValue(region, out regionClientContainerFactory)) { regionClientContainerFactory = new RegionClientContainerFactory(region, _serviceProvider); _regionClientContainerFactories.TryAdd(region, regionClientContainerFactory); } } } return regionClientContainerFactory; } } We register our handler LcHandler as a transient service and a Factory class with factory, in the Startup class: // handlers must always be transient services.AddTransient<LcHandler>(); // register a client services.AddSingleton(provider => new LanguageCloudClientFactory(provider.GetService<LcHandler>()); We can then use the registered client in the controller (or any other class resolved through Dependency Injection): public class LanguageCloudApiSampleController : ControllerBase { LanguageCloudClientFactory _factory; // inject the client via constructor public LanguageCloudApiSampleController(LanguageCloudClientFactory clientFactory) { this._factory = clientFactory; } ... // make an API call using a client and the user identity from HttpContext var accountClient = _factory.Region(\"eu\").AccountClient; var accounts = await accountClient.ListMyAccountsAsync(); ... }"
  },
  "articles/LCPublicAPI/docs/data-bridge/Data-Bridge-Introduction.html": {
    "href": "articles/LCPublicAPI/docs/data-bridge/Data-Bridge-Introduction.html",
    "title": "Trados Data Bridge",
    "summary": "Trados Data Bridge Trados Data Bridge - technically known as the Data API - gives you secure, read-only access to your Trados Cloud data. Its designed for reporting, analytics, and business intelligence applications, allowing external tools to connect directly without manual exports or custom connectors. Overview The Data API provides structured, near real-time access to analytical data about your translation projects, tasks, costs, leverage, and evaluation metrics. Use Data Bridge to: Power dashboards in your existing analytics environment Combine localization metrics with data from financial systems, CRMs, or web analytics Uncover trends and measure the business impact of your localization strategy By connecting directly to Trados data, teams can stop relying on static reports or siloed dashboards and instead build a single, holistic view of performance across the enterprise. Key Features Read-only access to analytical data to safely explore data without risking changes OData v4 query capabilities for flexible data filtering and sorting Multiple data sets including projects, tasks, costs, leverage, and evaluation metrics Fast integration no custom connectors required, works with most BI and analytics platforms out of the box Data Sets Available See the consolidated overview of all datasets: Data Sets. Base API URL Trados Cloud Platform operates in multiple regions, and it's essential to know in which region your Trados is located to use the Data API. To see the host on different regions, check the API base URL in the contract. Authentication & Authorization To start working with the Trados Data Bridge API, you first need to authenticate. The Data Bridge API uses the same authentication mechanism as the Public API. Follow the instructions under the Service users and custom applications and the Service Credentials pages to create a service user and an application, and then authenticate, following the Authentication page, by using the application's client_id and client_secret. Before running requests, set {{lc_tenant}} to your account ID (for example, LC-00000000000000000). Rate Limits and Daily Quotas Data Bridge API is governed by the same rate limits as Public API API rate limits In addition, Data Bridge enforces a daily data transfer quota: Quota is measured by data volume retrieved (not request count) Europe region: quota resets at midnight UTC Canada region: quota resets at midnight EST Requests that exceed the quota return HTTP 429 (Too Many Requests) until the reset time Postman Collection Use the provided Postman collection to quickly explore and test the Trados Data Bridge API endpoints. Data Availability Data availability varies by data set: Most data becomes available after the Analysis workflow task completes Revenue data requires Quote Generation task completion Some metrics are updated in real-time as workflow tasks complete Advanced Query Options For comprehensive OData query syntax reference and additional examples, see the OData Query Guide and Microsoft OData Query Options Overview. API Reference For detailed endpoint documentation, parameters, and response schemas, see the Trados Data Bridge API Reference."
  },
  "articles/LCPublicAPI/docs/data-bridge/Data-Sets.html": {
    "href": "articles/LCPublicAPI/docs/data-bridge/Data-Sets.html",
    "title": "Data Sets",
    "summary": "Data Sets File Translation Status This data source shows an entry for each target file in the system, as well as tabular data about the human workflow. The data about translation and review workflow steps is displayed on one line. If the workflow does not contain all the steps, the columns reserved for them show null placeholders. The metrics included in this data source are: Total number of source words Total number of words translated in the pre-translated task (and their distribution) Total number of human-translated words Total number of human-reviewed words Total workflow duration (from project creation to finalization) The data for the File Translation Status data source becomes available after the Analysis workflow task has been completed. You have the possibility to expand the File Translation Status Data Set with the following dimensions: project customer languagePair sourceFile projectCreationDate translationDate translator reviewDate reviewer customerReviewDate customerReviewer finalizationDate Language Revenue Details This data source shows the costs of each project per language direction. The metrics included in the data source are: Total revenue Total number of units that generated revenue The data for the Language Revenue Details data source becomes available after the Customer Quote Generation task has been completed. You have the possibility to expand the Language Revenue Details Data Set with the following dimensions: quoteDate customer project languagePair revenueType currency projectCreationDate Language Revenue This data source shows the costs of each language direction. The metrics included in this data source are: Translation cost per target language Additional cost per target languages Additional cost per project Total cost Total number of source words per source language Total number of files per source language Discounts The data for the Language Revenues data source becomes available after the Customer Quote Generation task has been completed. You have the possibility to expand the Language Revenue Data Set with the following dimensions: customer project languagePair approveDate currency quoteApprover quoteDate Task Status This data source shows metrics for each task executed in the system. The metrics included in this data source are: Actual duration Estimated duration Delivery duration Word count The data for the Task Status data source becomes available after the Analysis workflow task has been completed and is updated every time a workflow task is completed. You have the possibility to expand the Task Status Data Set with the following dimensions: project customer taskType taskState languagePair sourceFile taskOwner Translation Leverage This data source shows information about the translation leverage metrics obtained as a result of automated translation. The data source exposes file-level metrics detailing the number of words for each leverage bucket. The data for the Translation Leverage data source becomes available after the Analysis workflow task has been completed. You have the possibility to expand the Translation Leverage Data Set with the following dimensions: translationDate customer project languagePair sourceFile leverageBand Translation Quality Evaluation This data source shows details about the evaluation done with Smart Review and MTQE (Evolve) in a project. This data source takes into account all project segments, and does not currently provide information for individual segments. You have the possibility to expand the Translation Quality Evaluation Data Set with the following dimensions: project customer linguist originalTranslationOrigin finalTranslationOrigin taskType languagePair sourceFile translationQualityEvaluationCategory Vendor Cost This data source shows metrics about the costs associated with each vendor for each project and language direction. The data for the Vendor Cost data source becomes available after the Vendor Quote Generation task has been completed. You have the possibility to expand the Vendor Cost Data Set with the following dimensions: project customer languagePair vendorOrderTemplate serviceType currency"
  },
  "articles/LCPublicAPI/docs/data-bridge/OData-Query-Guide.html": {
    "href": "articles/LCPublicAPI/docs/data-bridge/OData-Query-Guide.html",
    "title": "OData Query Guide for Data Bridge APIs",
    "summary": "OData Query Guide for Data Bridge APIs The Trados Data Bridge API supports OData v4 query capabilities that allow you to filter, select, expand, and sort data efficiently. For comprehensive OData query syntax reference and additional examples, see the Microsoft OData Query Options Overview Query Parameters Overview Parameter Description Example $filter Filter results based on conditions $filter=revenue gt 1000 $select Choose specific fields to return $select=projectId,projectStatus,revenue $expand Include related entity data $expand=project,customer $orderby Sort results $orderby=projectCreationDate desc $top Limit number of results $top=50 $skip Skip a number of results $skip=100 Filtering with $filter Comparison Operators Operator Description Example eq Equal to $filter=projectStatus eq 'completed' ne Not equal to $filter=revenue ne 0 gt Greater than $filter=wordCount gt 1000 ge Greater than or equal $filter=revenue ge 500 lt Less than $filter=actualDuration lt 24 le Less than or equal $filter=wordCount le 5000 Logical Operators Operator Description Example and Logical AND $filter=revenue gt 1000 and projectStatus eq 'completed' or Logical OR $filter=projectStatus eq 'completed' or projectStatus eq 'in_progress' not Logical NOT $filter=not (projectStatus eq 'in_progress') String Functions Function Description Example contains Contains substring $filter=contains(projectName,'Marketing') startswith Starts with substring $filter=startswith(customerName,'ABC') endswith Ends with substring $filter=endswith(fileName,'.docx') Date Functions Function Description Example year Extract year $filter=year(projectCreationDate) eq 2024 month Extract month $filter=month(approveDate) eq 3 day Extract day $filter=day(completionDate) eq 15 Pagination Result Limits The Data API has the following result limits: Default page size: 500 records Maximum page size: 5,000 records Use $top parameter to specify the number of records to return (up to 5,000) Use $skip parameter to implement pagination for large result sets Basic Pagination $top=50&$skip=100 Pagination with Filters $filter=revenue gt 1000&$top=25&$skip=0&$orderby=revenue desc Maximum Results Example $top=5000&$skip=0 Best Practices Use Specific Filters Always filter data to reduce response size Use date ranges for time-based queries Filter by status or other categorical fields Select Only Required Fields Use $select to minimize response payload Only expand related entities when necessary Implement Pagination Use $top and $skip for large result sets Default page size: 500 records (when no $top is specified) Maximum page size: 5,000 records Typical page sizes: 25, 50, 100, 500, or 1000 records Optimize Performance Combine filters to reduce server processing Use indexes fields (like IDs and dates) in filters Avoid complex string operations on large datasets"
  },
  "articles/LCPublicAPI/docs/data-bridge/Trados-Data-Bridge-APIs-for-Postman.html": {
    "href": "articles/LCPublicAPI/docs/data-bridge/Trados-Data-Bridge-APIs-for-Postman.html",
    "title": "Trados Data Bridge APIs for Postman",
    "summary": "Trados Data Bridge APIs for Postman We provide a Postman collection for quick and easy usage of our RESTful APIs. Installation You can download the Postman collection from here. You have 3 setup options: Copy the collection URL from above and import it into Postman using Import > Link. Copy the entire file content and import it into Postman using Import > Raw Text. Save it as a JSON file on your computer and import it into Postman using Import > File. Configuration The imported collection is already set up for you to get started as fast as possible. We make use of collection level variables and an inherited authentication mechanism. For example, authentication is already set up to use the Bearer Token scheme and will use the token value provided by {{lc-access-token}} variable. This token is populated with the correct value, each time you Obtain a client credentials access token, via the Tests tab. One thing you need to do before proceeding is to fill in the {{lc_tenant}} variable with your own tenant ID. Prepend the ID with LC- so the final value looks like this LC-00000000000000000. Don't forget to save the collection! Authentication To start working with the Trados Data Bridge API, you first need to authenticate. You can find the authentication call under the Authentication (Start Here) folder. Fill in your client_id and client_secret and perform the request. If the authentication is successful, the token will be extracted automatically from the response and saved to the {{lc-access-token}} variable. Usage After you have authenticated successfully, you can start interacting with the RWS Language Cloud Data API. For example, we can get information about a project by using the List Task Status Project Dimension request from the Task Status folder. Simply fill in your value projectId eq 'stringValue' from your $filter parameter section and click SEND. Optionally, you can specify additional OData querys like projectTemplateName eq 'stringValue' and projectShortId eq numericValue. For more options see below table | Operators| Description| Example | |----------|------------|---------| | Comparison operators| Use the eq, ne, gt, ge, lt, le operators to compare a property and a value. |$filter=revenue eq 100000| | Logical operators|Use and, or to create more complex expressions.|$filter=revenue lt 100000 and revenue gt 2000| | Grouping operators|Use parentheses: (), to specify the precedence to evaluate a complex expression.|$filter=(projectShortId lt 16867 and projectShortId gt 16800) and projectStatus eq 'completed'| | Expand operator|The expand system query option specifies the related resources to be included. Each expandItem is evaluated relative to the entity containing the navigation or stream property being expanded.|$expand=project| Warning Make sure you are not sending any query parameters with default Postman values. If you are sending any parameters, make sure you are sending valid data or else you will get an API Error."
  },
  "articles/LCPublicAPI/docs/termbase/Termbase-entries.html": {
    "href": "articles/LCPublicAPI/docs/termbase/Termbase-entries.html",
    "title": "Termbase entries",
    "summary": "Termbase entries Creating a termbase entry A termbase entry can be created by making a POST request to the /termbases/{termbaseId}/entries endpoint. Request example for an entry using language code en: POST /termbases/61b70c0775ed5f14d8190fab/entries { \"humanReadableId\": \"LC000000000000000000000001\", \"languages\": [ { \"language\": { \"languageCode\": \"en\" }, \"terms\": [ { \"text\": \"Simple Entry\" } ] } ] } The humanReadableId is optional and can be any value. If it's not specified it will be autogenerated. The autogenerated value is not guaranteed to adhere to any specific format. Creating a termbase entry with cross-references A termbase entry can contain cross-references. These references can have the following types: entry, term or external, representing the associated element type. For the external type you can use as value external URLs. For the entry type, the entryId needed can be retrieved by pressing the Copy Entry ID button on the user interface for the entry that should be referred. See below an example of how to add a cross-reference of 'entry' type in the user interface: Equivalent cross-references can be created via API by using fieldValueLinks objects. In the next example, value is an HTML snippet, where the identifier provided in the value LC61b7264d877e04258abc7da8 (note that it appears twice in the snippet) is the value from the humanReadableId field. This is the same for the UI example, as the \"Copy Entry ID\" button copies the humanReadableId, for the entry, into clipboard. Request example: POST /termbases/61b70c0775ed5f14d8190fab/entries { \"humanReadableId\": \"LC000000000000000000000001\", \"languages\": [ { \"language\": { \"languageCode\": \"en\" }, \"terms\": [ { \"text\": \"New Simple entry\", \"termbaseFieldValues\": [ { \"termbaseFieldId\": \"61b71de9877e04258abc7d9f\", \"value\": \"This is an new&nbsp;<a data-value=\\\"LC61b7264d877e04258abc7da8\\\" data-type=\\\"concept\\\" href=\\\"#conceptId=LC61b7264d877e04258abc7da8\\\">entry reference<\\/a>\", \"fieldValueLinks\": [ { \"type\": \"entry\", \"value\": \"This is a new entry reference\" } ] } ] } ] } ] } Note The termbaseFieldId should match the field id from the termbase. Response example: { \"id\": \"61b73e4475ed5f14d81ae5e7\", \"languages\": [ { \"id\": \"61b73e4475ed5f14d81ae5e8\", \"language\": { \"languageCode\": \"en\", \"englishName\": \"English\" } } ] } Postman example: Updating a termbase entry A termbase entry can be updated by making a PUT request to the /termbases/{termbaseId}/entries/{entryId} endpoint. The update action changes the entire structure of an entry, it doesn't only update the terms specified in the request body. The terms that are not specified, are deleted. If some terms should not be updated, their structure must be send in the request as it currently is. The cross-references between terms can be updated using fieldValueLinks objects. Postman example: Request example: PUT /termbases/61b70c0775ed5f14d8190fab/entries/61b73e4475ed5f14d81ae5e7 { \"humanReadableId\": \"LC000000000000000000000002\", \"languages\": [ { \"id\": \"61b73e4475ed5f14d81ae5e8\", \"language\": { \"languageCode\": \"en\" }, \"terms\": [ { \"id\": \"61b73e4475ed5f14d81ae5e9\", \"text\": \"Simple Entry Updated\", \"termbaseFieldValues\": [ { \"id\": \"61b73e4475ed5f14d81ae5ea\", \"termbaseFieldId\": \"61b71de9877e04258abc7d9f\", \"value\": \"This is an updated&nbsp;<a data-value=\\\"LC61b7264d877e04258abc7da8\\\" data-type=\\\"concept\\\" href=\\\"#conceptId=LC61b7264d877e04258abc7da8\\\">entry reference<\\/a>\", \"fieldValueLinks\": [ { \"type\": \"entry\", \"value\": \"This is an updated entry reference\" } ] } ] } ] } ] } Retrieving a termbase entry A termbase entry can be retrieved by making a GET request to the /termbases/{termbaseId}/entries/{entryId} endpoint. Postman example: Request example: GET /termbases/61b70c0775ed5f14d8190fab/entries/61b73e4475ed5f14d81ae5e7?fields=humanReadableId,languages.terms,languages.terms.termbaseFieldValues Response example: { \"id\": \"61b73e4475ed5f14d81ae5e7\", \"humanReadableId\": \"LC000000000000000000000002\", \"languages\": [ { \"id\": \"61b73e4475ed5f14d81ae5e8\", \"language\": { \"languageCode\": \"en\", \"englishName\": \"English\" }, \"terms\": [ { \"id\": \"61b73e4475ed5f14d81ae5e9\", \"text\": \"Simple Entry Updated\", \"termbaseFieldValues\": [ { \"id\": \"61b73e4475ed5f14d81ae5ea\", \"name\": \"Term level field\", \"termbaseFieldId\": \"61b71de9877e04258abc7d9f\", \"value\": \"This is an updated&nbsp;<a data-value=\\\"LC61b7264d877e04258abc7da8\\\" data-type=\\\"concept\\\" href=\\\"#conceptId=LC61b7264d877e04258abc7da8\\\">entry reference</a>\" } ] } ] } ] } Retrieving the list of termbase entries You can retrieve the list of termbase entries by making a GET request to the /termbases/{termbaseId}/entries endpoint. Request example: GET /termbases/61b70c0775ed5f14d8190fab/entries?fields=humanReadableId,languages.terms,languages.terms.termbaseFieldValues Response example: { \"items\": [ { \"id\": \"61b725aa75ed5f14d8190fea\", \"humanReadableId\": \"LC61b725aa75ed5f14d8190fee\", \"languages\": [ { \"id\": \"61b725aa75ed5f14d8190feb\", \"language\": { \"languageCode\": \"en\", \"englishName\": \"English\" }, \"terms\": [ { \"id\": \"61b725aa75ed5f14d8190fed\", \"text\": \"Simple entry\", \"termbaseFieldValues\": [ { \"id\": \"61b733ee75ed5f14d81a8602\", \"name\": \"Term level field\", \"termbaseFieldId\": \"61b71de9877e04258abc7d9f\", \"value\": \"This is an&nbsp;<a data-value=\\\"LC61b7264d877e04258abc7da8\\\" data-type=\\\"concept\\\" href=\\\"#conceptId=LC61b7264d877e04258abc7da8\\\">entry reference</a>\" } ] } ] } ] }, { \"id\": \"61b7264d877e04258abc7da5\", \"humanReadableId\": \"LC61b7264d877e04258abc7da8\", \"languages\": [ { \"id\": \"61b7264d877e04258abc7da6\", \"language\": { \"languageCode\": \"en\", \"englishName\": \"English\" }, \"terms\": [ { \"id\": \"61b7264d877e04258abc7da7\", \"text\": \"Entry reference\", \"termbaseFieldValues\": [] } ] } ] }, { \"id\": \"61b73e4475ed5f14d81ae5e7\", \"humanReadableId\": \"LC000000000000000000000002\", \"languages\": [ { \"id\": \"61b73e4475ed5f14d81ae5e8\", \"language\": { \"languageCode\": \"en\", \"englishName\": \"English\" }, \"terms\": [ { \"id\": \"61b73e4475ed5f14d81ae5e9\", \"text\": \"Simple Entry Updated\", \"termbaseFieldValues\": [ { \"id\": \"61b73e4475ed5f14d81ae5ea\", \"name\": \"Term level field\", \"termbaseFieldId\": \"61b71de9877e04258abc7d9f\", \"value\": \"This is an updated&nbsp;<a data-value=\\\"LC61b7264d877e04258abc7da8\\\" data-type=\\\"concept\\\" href=\\\"#conceptId=LC61b7264d877e04258abc7da8\\\">entry reference</a>\" } ] } ] } ] } ], \"itemCount\": 3 } Deleting a termbase entry A termbase entry can be deleted by making a DELETE request to the /termbases/{termbaseId}/entries/{entryId} endpoint. Request example: DELETE /termbases/61b70c0775ed5f14d8190fab/entries/61b73e4475ed5f14d81ae5e7 Deleting all termbase entries All termbase entries can be deleted by making a DELETE request to the /termbases/{termbaseId}/entries endpoint. Request example: DELETE /termbases/61b70c0775ed5f14d8190fab/entries"
  },
  "articles/LCPublicAPI/docs/termbase/Termbase-import-export.html": {
    "href": "articles/LCPublicAPI/docs/termbase/Termbase-import-export.html",
    "title": "Termbase import and export",
    "summary": "Termbase import and export Importing a termbase The following termbase formats are supported: tbx and xml. Note Before importing a termbase, make sure you already created one using the Create Termbase endpoint. To import a tbx or an xml termbase, perform a POST request to the Import Termbase endpoint and provide the termbaseId and the termbase file. Optionally, you can specify two import settings via query parameters: duplicateEntriesStrategy - It determines how the duplicate entries will be handled and it can have one of the following values: ignore The content of the current entry with the same identifier will be kept and the new entry will be ignored. merge The content of the current entry with the same identifier will be merged into the imported entry. If the identifier is not provided, the content will be merged by text. override The content of the current entry with the same identifier will be replaced by the imported entry. Note If duplicateEntriesStrategy is not sent, the default behavior will be override. strictImport - It specifies if the entries are imported only into the exact language that matches your imported file and it can have one of the following values: true The import will only occur if the language in your import file matches exactly a language in your termbase. false The import will occur even if there are non-matching languages, by trying to match them to a relevant main language or language variant, if available. Note If strictImport is not sent, the default behavior will be true. If the import is successful, you will get back an importId and the import status. Polling a termbase import Some imports may take longer, depending on the size of the termbase. To check if the import finished, you can perform a GET request to the Poll Termbase Import endpoint and supply the importId and the termbaseId. The import is complete when the status is done. Exporting a termbase The following termbase formats are supported: tbx and xml. To export a tbx or an xml termbase, perform a POST request to the Export Termbase endpoint and provide the termbaseId. Optionally, you can specify in body, one of the two allowed formats. If none is specified, the default format will be tbx. Also, in the body, it can be specified if the download should be compressed (zipped) or not. By default, this property is set to false. If the export is successful, you will get back an exportId, the export status and the downloadUrl for this. If the export did not succeed, the response will contain an errorMessage. Polling a termbase export Some exports may take longer, depending on the size of the termbase. To check if the export finished, you can perform a GET request to the Poll Termbase Export endpoint and supply the exportId and the termbaseId. The export is complete when the status is done. Downloading a termbase export If an export is completed (the status received at the polling is done), it can be downloaded by performing a GET request to the Download Exported Termbase endpoint. Supply as path parameters the exportId and the termbaseId and the response will contain the exported termbase file."
  },
  "articles/LCPublicAPI/docs/termbase/Termbase-templates.html": {
    "href": "articles/LCPublicAPI/docs/termbase/Termbase-templates.html",
    "title": "Termbase templates",
    "summary": "Termbase templates Creating a termbase template A termbase template can be created by making a POST request to the /termbase-templates endpoint. Note If the location is not specified, the template will be created in the root folder. Note When dataType is picklist, the pickListValues array must be filled in or the allowCustomValues must be set to true. Postman example: Request example: POST /termbase-templates { \"name\": \"Simple Termbase template\", \"description\": \"A simple termbase template.\", \"location\": \"5ebcd778b3d9411141eeff7a\", \"copyright\": \"RWS\", \"languages\": [{ \"languageCode\": \"en-US\" } ], \"fields\": [{ \"name\": \"Entry level field\", \"description\": \"A simple entry level field description.\", \"level\": \"entry\", \"dataType\": \"text\", \"allowMultiple\": true, \"isMandatory\": false }, { \"name\": \"Language level field\", \"description\": \"A simple language level field description.\", \"level\": \"language\", \"dataType\": \"boolean\", \"allowMultiple\": false, \"isMandatory\": true }, { \"name\": \"Term level field\", \"description\": \"A simple term level field description.\", \"level\": \"term\", \"dataType\": \"picklist\", \"pickListValues\": [ \"Option 1\", \"Option 2\", \"Option 3\" ], \"allowCustomValues\": false, \"allowMultiple\": false, \"isMandatory\": false } ] } Response example: { \"id\": \"6156bbc7a638696c7686db7f\", \"name\": \"Simple Termbase template\", \"location\": { \"id\": \"5ebcd778b3d9411141eeff7a\", \"name\": \"RWS\" }, \"type\": \"userDefined\" } Updating a termbase template A termbase template can be updated by making a PUT request to the /termbase-templates/{termbaseTemplateId} endpoint. Postman example: Request example: PUT /termbase-templates/6156bbc7a638696c7686db7f { \"name\": \"[UPDATED] Simple Termbase template\", \"description\": \"A simple termbase template.\", \"copyright\": \"RWS\", \"languages\": [{ \"languageCode\": \"en-US\" } ], \"fields\": [{ \"name\": \"[UPDATED] Entry level field\", \"description\": \"A simple entry level field description.\", \"level\": \"entry\", \"dataType\": \"double\", \"allowMultiple\": true, \"isMandatory\": false } ] } Retrieving a termbase template A termbase template can be retrieved by making a GET request to the /termbase-templates/{termbaseTemplateId} endpoint. Request example: GET /termbase-templates/6156bbc7a638696c7686db7f?fields=name,location,description,languages,fields Response example: { \"id\": \"615ae37ac736b8373d19a717\", \"name\": \"[UPDATED] Simple Termbase template\", \"description\": \"A simple termbase template.\", \"location\": { \"id\": \"5ebcd778b3d9411141eeff7a\", \"name\": \"RWS\" }, \"type\": \"userDefined\", \"languages\": [{ \"languageCode\": \"en-US\", \"englishName\": \"English (United States)\" } ], \"fields\": [{ \"id\": \"615af63ca638696c7687d7fa\", \"name\": \"[UPDATED] Entry level field\", \"type\": \"userDefined\", \"level\": \"entry\", \"dataType\": \"double\" } ] } Retrieving termbase templates You can retrieve the list of termbase templates by making a GET request to the /termbase-templates endpoint. Request example: GET /termbase-templates?fields=name,description Response example: { \"items\": [{ \"id\": \"541823689b976a6a9de11dfe\", \"name\": \"Basic\", \"description\": \"description\", \"type\": \"system\" }, { \"id\": \"541823689b976a6a9de11dff\", \"name\": \"Advanced\", \"description\": \"description\", \"type\": \"system\" }, { \"id\": \"615ae37ac736b8373d19a717\", \"name\": \"[UPDATED] Simple Termbase template\", \"description\": \"A simple termbase template.\", \"type\": \"userDefined\" } ], \"itemCount\": 3 } Deleting termbase templates A termbase template can be deleted by making a DELETE request to the /termbase-templates/{termbaseTemplateId} endpoint. Note You can only delete the userDefined termbases. Request example: DELETE /termbase-templates/6156bbc7a638696c7686db7f"
  },
  "articles/LCPublicAPI/docs/termbase/Termbase.html": {
    "href": "articles/LCPublicAPI/docs/termbase/Termbase.html",
    "title": "Termbases",
    "summary": "Termbases Creating a termbase A termbase can be created by making a POST request to the /termbases endpoint. You can create a termbase based on an existing termbase template by providing the termbaseTemplateId. This will create the termbase using the structure described by the template. For details about termbase templates, see Termbase Template. Postman example: Request example: POST /termbases { \"name\": \"Simple Termbase\", \"description\": \"A simple termbase\", \"copyright\": \"RWS\", \"location\" : \"60b0a03152a974047fd46fb0\" \"termbaseTemplateId\": \"your-termbase-template-id\" } If, however, you wish to provide your own custom termbase structure, you can do so by supplying it via the termbaseStructure object in the request body. Postman example: Request example: POST /termbases { \"name\": \"Simple Termbase\", \"description\": \"A simple termbase\", \"copyright\": \"RWS\", \"location\" : \"60b0a03152a974047fd46fb0\" \"termbaseStructure\": { \"languages\": [ { \"languageCode\": \"en-US\" } ], \"fields\": [ { \"name\": \"Entry level field\", \"description\": \"A simple entry level field description.\", \"level\": \"entry\", \"allowCustomValues\": true, \"allowMultiple\": true, \"isMandatory\": false \"dataType\": \"picklist\", \"pickListValues\": [ \"picklist-value-1\", \"picklist-value-2\", \"picklist-value-3\" ] } ] } } Response example: { \"id\": \"6171694efb696c53e5ad726e\", \"name\": \"Simple Termbase\", \"location\": { \"id\": \"60b0a03152a974047fd46fb0\", \"name\": \"RWS\" } } Note If both the termbaseTemplateId and the termbaseStructure are added in the request, the termbaseStructure takes precedence. In other words, the termbaseTemplateId is ignored. Updating a termbase Note You can update the fields for a termbase only if the termbase you want to update was not created using a termbase template or if it does not already have fields defined. A termbase can be updated by making a PUT request to the /termbases/{termbaseId} endpoint and providing the termbaseTemplateId. Request example: PUT /termbases/616d0efa7a11677d6085b0be { \"name\": \"[UPDATED] Simple Termbase\", \"description\": \"A simple termbase\", \"copyright\": \"[UPDATED] RWS\", \"termbaseTemplateId\" : \"your-termbase-template-id\" } If, however, you wish to provide your own custom termbase structure, you can do so by supplying it via the termbaseStructure object in the request body. Postman example: Request example: PUT /termbases/616d0efa7a11677d6085b0be { \"name\": \"[UPDATED] Simple Termbase\", \"description\": \"A simple termbase\", \"copyright\": \"[UPDATED] RWS\", \"termbaseStructure\": { \"languages\": [ { \"languageCode\": \"en-US\" } ], \"fields\": [ { \"id\": \"616d0efa7a12676d603b71ad\", \"name\": \"[UPDATED] Entry level field\", \"description\": \"A simple entry level field description.\", \"level\": \"entry\", \"dataType\": \"text\", \"allowMultiple\": true, \"isMandatory\": false } ] } } Note If both the termbaseTemplateId and the termbaseStructure are added in the request, the termbaseStructure takes precedence. In other words, the termbaseTemplateId is ignored. Note If you perform an update using a termbase field without an id, the field will be added to the termbase. Retrieving a termbase A termbase can be retrieved by making a GET request to the /termbases/{termbaseId} endpoint. Request example: GET /termbases/616d0efa7a11677d6085b0be Response example: { \"id\": \"616d28597a11677d60862233\", \"name\": \"[UPDATED] Simple Termbase\", \"copyright\": \"[UPDATED] RWS\", \"location\": { \"id\": \"60b0a03152a974047fd46fb0\", \"name\": \"RWS\" } } Retrieving the list of termbases You can retrieve the list of termbases by making a GET request to the /termbases endpoint. Request example: GET /termbases Response example: { \"items\": [ { \"id\": \"616d28597a11677d60862233\", \"name\": \"[UPDATED] Simple Termbase\", \"location\": { \"id\": \"60b0a03152a974047fd46fb0\", \"name\": \"RWS\" } }, { \"id\": \"616d0efa7a11677d6085b0be\", \"name\": \"New Termbase\", \"location\": { \"id\": \"60b0a03152a974047fd46fb0\", \"name\": \"RWS\" } } ], \"itemCount\": 2 } Note Some properties are not available for this endpoint: numberOfEntries, status, createdAt and lastModifiedAt. Deleting termbases A termbase can be deleted by making a DELETE request to the /termbases/{termbaseId} endpoint. Request example: DELETE /termbases/616d0efa7a11677d6085b0be"
  },
  "articles/LCPublicAPI/docs/translation-memory/Translation-memory-advanced-configuration.html": {
    "href": "articles/LCPublicAPI/docs/translation-memory/Translation-memory-advanced-configuration.html",
    "title": "Translation Memory advanced configuration",
    "summary": "Translation Memory advanced configuration The Trados Cloud Platform API provides advanced settings for Translation Memory (TM) operations, including powerful filter expressions and field update options. These features give you fine-grained control over which translation units match and how Translation Memory fields are updated. See also: Configuring advanced project settings and Configuring advanced project template settings. Applicable API endpoints The TM advanced configuration options in this document apply to the following API endpoints. Project endpoints: Get Project - Retrieve project details, including Translation Memory settings Update Project - Update project configuration, including Translation Memory settings Project template endpoints: Get Project Template - Retrieve project template details, including Translation Memory settings Update Project Template - Update project template configuration, including Translation Memory settings Translation Memory filters Translation Memory filters let you apply complex criteria during TM operations. Filters can reference system and custom fields, and support multiple data types and operators. Hard filter configuration Hard filters enforce strict criteria that Translation Units (TUs) must meet to be considered matches. See the official documentation. A filter configuration contains: expression: A logical expression describing the criteria fields: An array of field definitions referenced by the expression Filter expression syntax Filter expressions are built from comparison expressions combined with logical operators. Logical operators: AND - both conditions must be true OR - at least one condition must be true NOT - negates the following condition Example: (NOT \"TU confirmation level\" = \"Not Translated\" OR \"Last modified on\" > 2024-02-29T10:00:00.000Z) AND \"Source segment length\" >= 10 This expression selects TUs that are either not marked as \"Not Translated\" or that were modified after 2024-02-29T10:00:00Z, and that have a source segment length of at least 10 characters. Filter expression grammar Filter expressions are parsed with ANTLR4 (ANother Tool for Language Recognition). The grammar below specifies the formal syntax and operator precedence. Understanding the grammar helps you: Construct complex expressions correctly Reason about operator precedence Validate expressions before sending them to the API Build tooling to generate or validate expressions ANTLR4 grammar definition: /** * ANTLR4 Grammar for Filter Expressions * * This grammar defines the syntax for filtering translation units in the Trados Cloud Platform API. * * Supported operators: =, !=, <, <=, >, >=, CONTAINS, DOES NOT CONTAIN, MATCHES, DOES NOT MATCH * * Field names must be quoted strings. * Values can be quoted strings or unquoted numeric values. */ grammar FilterExpression; // Root rule - top level expression that can contain logical operators expression : orExpression EOF ; // OR has lowest precedence - allows chaining: expr OR expr OR expr orExpression : andExpression (OR andExpression)* ; // AND has higher precedence than OR - allows chaining: expr AND expr AND expr andExpression : notExpression (AND notExpression)* ; // NOT has highest precedence among logical operators - optional negation notExpression : NOT? primaryExpression ; // Primary expressions include comparisons and parenthesized expressions primaryExpression : comparison | LPAREN orExpression RPAREN ; // Comparison expressions: MUST have all three components: field operator value // This enforces the Field-Operator-Value triplet structure comparison : field operator value ; // Field names - must be quoted strings field : QUOTED_STRING ; // Operators - only the specific operators defined in the specification operator : COMPARISON_OPERATOR ; // Values can be quoted strings or unquoted numeric values value : QUOTED_STRING | NUMERIC_VALUE ; // Lexer rules // Keywords and logical operators AND : 'AND' ; OR : 'OR' ; NOT : 'NOT' ; // Parentheses LPAREN : '(' ; RPAREN : ')' ; // Field names - quoted strings that represent field names QUOTED_STRING : '\"' (~[\"\\\\\\r\\n] | '\\\\\\\\' | '\\\\\"')* '\"' ; // Numeric field values (integers only) NUMERIC_VALUE : '-'? [0-9]+ ; // Comparison operators - all supported operators COMPARISON_OPERATOR : 'DOES NOT CONTAIN' | 'DOES NOT MATCH' | 'CONTAINS' | 'MATCHES' | '<=' | '>=' | '!=' | '<' | '>' | '=' ; // Catch invalid identifiers to prevent ANTLR from accepting them INVALID_IDENTIFIER : [a-zA-Z][a-zA-Z0-9_]* // Invalid words like ORR, NOTT ; // Whitespace (ignored) - MUST come before catch-all rule WS : [ \\t\\r\\n]+ -> skip ; // Catch-all rule for any invalid character (including Unicode) // This MUST be the last lexer rule to catch anything not matched above INVALID_CHARACTER : . // Any single character not matched by rules above ; System fields The following system fields are available for filter expressions: Field name Field type Description Last modified on dateTime When the TU was last modified Last modified by singleString User who last modified the TU Last used on dateTime When the TU was last used Last used by singleString User who last used the TU Usage count integer Number of times the TU has been used Created on dateTime When the TU was created Created by singleString User who created the TU TU confirmation level singlePicklist Confirmation status of the TU Source segment singleString Source text content Target segment singleString Target text content Source segment length integer Length of source text Target segment length integer Length of target text Number of tags in source segment integer Count of tags in source Number of tags in target segment integer Count of tags in target TU confirmation level values See the official documentation for background information on translation statuses. The Trados Cloud Platform API accepts the following exact values for TU confirmation level: Not Translated Draft Translated Translation Rejected Translation Approved Sign-off Rejected Signed Off Filter operators Supported operators depend on the field type: Operator singleString multipleString singlePicklist multiplePicklist dateTime integer =       <       <=       >       >=       !=       CONTAINS       DOES NOT CONTAIN       MATCHES       DOES NOT MATCH       Filter field definition Filter fields are represented differently in responses and requests. Filter fields in API responses (GET endpoints) When you retrieve TM settings using the GET endpoints (see Applicable API endpoints), the response includes full metadata for each referenced field: fieldId: Field identifier (system field name or custom field ID) fieldTemplateId: system for system fields, or the custom field template ID fieldTemplateName: Field template name name: Field name (for system fields this equals fieldId) type: Data type allowedValues (optional): Present for singlePicklist and multiplePicklist fields Filter fields in API requests (PUT endpoints) When you update filter configuration via PUT (see Applicable API endpoints), you do not need to include the fields array. The system resolves field metadata automatically from the field names used in the expression. Supported field types: singleString - single text value multipleString - multiple unique text values singlePicklist - single selection from predefined options multiplePicklist - multiple unique selections from predefined options dateTime - date and time value integer - integer value Translation Memory field updates See the official documentation for details on fields and field templates. Note: Custom field definitions and values appear in GET responses under settings.translationMemorySettings.updateTranslationMemoryFields. The response includes both field metadata and configured values. Field update configuration Field update payloads and responses differ by endpoint. Field updates in API requests (PUT endpoints) When updating TM settings via PUT (see Applicable API endpoints), use a simple structure: fieldId: Field identifier (system field name or custom field ID) values: Array of values to apply (format depends on field type) Field updates in API responses (GET endpoints) When you retrieve TM settings via GET, the response includes full field metadata (see Filter field definition), plus: values: Array of currently assigned values. Types singleString, singlePicklist, integer, and dateTime contain exactly one value; multipleString and multiplePicklist may contain multiple values. Example configurations Updating TM settings (PUT request) When updating a project or project template's TM settings via PUT (see Applicable API endpoints), provide only fieldId and values where applicable - the system will resolve metadata automatically. { \"settings\": { \"translationMemorySettings\": { \"filters\": { \"hardFilter\": { \"expression\": \"(\\\"Created by\\\" CONTAINS \\\"API Integration\\\" OR \\\"TU confirmation level\\\" != \\\"Not Translated\\\") AND NOT (\\\"Text\\\" MATCHES \\\"exampleText\\\" AND \\\"Usage count\\\" >= 10)\" } }, \"updateTranslationMemoryFields\": [ { \"fieldId\": \"1e5b54da-9048-45f7-a5d8-c3878ac4c5b7\", \"values\": [ \"11\" ] }, { \"fieldId\": \"25c0dce2-11d0-44c0-837e-1f5030e2204d\", \"values\": [ \"multiText1\", \" multiText2 \" ] }, { \"fieldId\": \"55eb47bb-20bc-43e0-b1e1-9b373e5ca157\", \"values\": [ \"1List\" ] }, { \"fieldId\": \"bf6e413d-e617-4fcd-be13-e389af7ce7d4\", \"values\": [ \"1Multi List\", \"2Multi List\" ] }, { \"fieldId\": \"3e71fc28-a128-4c69-befd-eee38ce998e4\", \"values\": [ \"singleText1\" ] }, { \"fieldId\": \"6c6d9004-3a9e-4bde-97b4-62a6d2ec1a7f\", \"values\": [ \"2025-10-29T12:00:00.000Z\" ] } ] } } } Note In PUT requests you only specify fieldId and values; metadata is resolved automatically. Retrieving TM settings (GET response) When you retrieve project or project template settings via GET and include the query parameter fields=settings.translationMemorySettings.filters.hardFilter.fields,settings.translationMemorySettings.updateTranslationMemoryFields, the response will include full field metadata. For details about the fields query parameter, see Use fields in your requests. Example response: { \"id\": \"6895b4bf6b83b41210883f09\", \"settings\": { \"translationMemorySettings\": { \"filters\": { \"hardFilter\": { \"expression\": \"(\\\"Created by\\\" CONTAINS \\\"API Integration\\\" OR \\\"TU confirmation level\\\" != \\\"Not Translated\\\") AND NOT (\\\"Text\\\" MATCHES \\\"exampleText\\\" AND \\\"Usage count\\\" >= 10)\", \"fields\": [ { \"fieldId\": \"Created by\", \"fieldTemplateId\": \"system\", \"name\": \"Created by\", \"type\": \"singleString\" }, { \"fieldId\": \"TU confirmation level\", \"fieldTemplateId\": \"system\", \"name\": \"TU confirmation level\", \"type\": \"singlePicklist\", \"allowedValues\": [ { \"id\": \"translated\", \"name\": \"Translated\" }, { \"id\": \"approvedTranslation\", \"name\": \"Translation Approved\" }, { \"id\": \"approvedSignOff\", \"name\": \"Signed Off\" }, { \"id\": \"draft\", \"name\": \"Draft\" }, { \"id\": \"rejectedTranslation\", \"name\": \"Translation Rejected\" }, { \"id\": \"rejectedSignOff\", \"name\": \"Sign-off Rejected\" }, { \"id\": \"notTranslated\", \"name\": \"Not Translated\" } ] }, { \"fieldId\": \"3e71fc28-a128-4c69-befd-eee38ce998e4\", \"fieldTemplateId\": \"976cc1d2-c422-461d-a2d6-71bb52a4eba8\", \"fieldTemplateName\": \"Custom Field Template with Field Definitions\", \"name\": \"Text\", \"type\": \"singleString\" }, { \"fieldId\": \"Usage count\", \"fieldTemplateId\": \"system\", \"name\": \"Usage count\", \"type\": \"integer\" } ] } }, \"updateTranslationMemoryFields\": [ { \"fieldId\": \"1e5b54da-9048-45f7-a5d8-c3878ac4c5b7\", \"fieldTemplateId\": \"976cc1d2-c422-461d-a2d6-71bb52a4eba8\", \"fieldTemplateName\": \"Custom Field Template with Field Definitions\", \"name\": \"Number\", \"values\": [ \"11\" ], \"type\": \"integer\" }, { \"fieldId\": \"25c0dce2-11d0-44c0-837e-1f5030e2204d\", \"fieldTemplateId\": \"976cc1d2-c422-461d-a2d6-71bb52a4eba8\", \"fieldTemplateName\": \"Custom Field Template with Field Definitions\", \"name\": \"MultiText\", \"values\": [ \"multiText1\", \" multiText2 \" ], \"type\": \"multipleString\" }, { \"fieldId\": \"55eb47bb-20bc-43e0-b1e1-9b373e5ca157\", \"fieldTemplateId\": \"976cc1d2-c422-461d-a2d6-71bb52a4eba8\", \"fieldTemplateName\": \"Custom Field Template with Field Definitions\", \"name\": \"List\", \"values\": [ \"1List\" ], \"allowedValues\": [ { \"id\": \"ab074228-0f8c-4ef3-8039-ad4d6442cade\", \"name\": \"1List\" }, { \"id\": \"29f4b861-5d58-4921-b47c-19146f6d7431\", \"name\": \"2List\" }, { \"id\": \"0f2d0324-0f11-46db-bb66-ad9cad21f176\", \"name\": \"3List\" } ], \"type\": \"singlePicklist\" }, { \"fieldId\": \"bf6e413d-e617-4fcd-be13-e389af7ce7d4\", \"fieldTemplateId\": \"976cc1d2-c422-461d-a2d6-71bb52a4eba8\", \"fieldTemplateName\": \"Custom Field Template with Field Definitions\", \"name\": \"MultiList\", \"values\": [ \"1Multi List\", \"2Multi List\" ], \"allowedValues\": [ { \"id\": \"907a34ca-b072-4687-8af1-8ab41ac881c8\", \"name\": \"1Multi List\" }, { \"id\": \"304e1ee1-3a71-4c7c-b123-e5811a812dfd\", \"name\": \"2Multi List\" }, { \"id\": \"8225e4b7-a954-4503-88de-fe9f7ced77cb\", \"name\": \"3Multi List\" } ], \"type\": \"multiplePicklist\" }, { \"fieldId\": \"3e71fc28-a128-4c69-befd-eee38ce998e4\", \"fieldTemplateId\": \"976cc1d2-c422-461d-a2d6-71bb52a4eba8\", \"fieldTemplateName\": \"Custom Field Template with Field Definitions\", \"name\": \"Text\", \"values\": [ \"singleText1\" ], \"type\": \"singleString\" }, { \"fieldId\": \"6c6d9004-3a9e-4bde-97b4-62a6d2ec1a7f\", \"fieldTemplateId\": \"976cc1d2-c422-461d-a2d6-71bb52a4eba8\", \"fieldTemplateName\": \"Custom Field Template with Field Definitions\", \"name\": \"DateTime\", \"values\": [ \"2025-10-29T12:00:00.000Z\" ], \"type\": \"dateTime\" } ] } } } Note In GET responses, the fields array is automatically populated by the system based on the field names used in the filter expression, including both system fields and custom fields. The response provides complete field metadata including fieldTemplateId, fieldTemplateName, name, type, and allowedValues (for picklist fields)."
  },
  "articles/LCPublicAPI/docs/translation-memory/Translation-memory-import-export.html": {
    "href": "articles/LCPublicAPI/docs/translation-memory/Translation-memory-import-export.html",
    "title": "Translation Memory import and export",
    "summary": "Translation Memory import and export Concepts Concept Explanation Translation Unit A pair made of source and target segments Fields The fields contain metadata about the translation unit. Importing a translation memory The translation memory that you want to import must have one of the following formats: tmx, sdltm, zip, tmx.gz or sdlxliff. Note Before the import action, make sure you have already created a translation memory using the Create Translation Memory endpoint. To import a translation memory, perform a POST request to the Import Translation Memory endpoint and provide these details: translationMemoryId, the translation memory file and a couple of properties. Warning Pay special attention to the order of properties and file. It must be exactly as described in the contract (properties first). If you are not sure what properties to include, here's a short description for each of them: sourceLanguageCode and targetLanguageCode - These fields represent the language direction of your import. Make sure to provide both of them as they are required fields. importAsPlainText - When true, the translation units will be imported as plain text, excluding any text markup. exportInvalidTranslationUnits - When true, all the translation units that failed to import are saved in a tmx file. triggerRecomputeStatistics - When true, will recompute the fuzzy index statistics once the import is done. targetSegmentsDifferOption - Option to specify how to handle translation units in the Translation Memory, if the target segments differ. addNew - Add a new translation unit and leave the original translation unit with the same source untouched. overwrite - Overwrite all the existing translation units where the source segment matches with the new content. leaveUnchanged - Do not change the existing translation units with the same source segment and ignore the new translation unit. keepMostRecent - Delete all the existing translation units with matching source segments and retain only the most recent translation unit unknownFieldsOption - Option to specify how to handle translation units and unknown fields in the Translation Memory. addToTranslationMemory - The translation unit is processed and the unknown user-defined fields are automatically added to the setup. skipTranslationUnit - The translation units containing unknown user-defined fields are skipped. ignore - The translation unit is processed and the unknown user-defined fields are ignored (not added to the setup). failTranslationUnitImport - If any translation unit contains an unknown user-defined field an error is thrown. onlyImportSegmentsWithConfirmationLevels - Only segments with the specified confirmation levels will be imported. translated - The segment has been fully translated, but not yet reviewed. approvedTranslation - The translation has been reviewed and approved, but not signed-off. approvedSignOff - The translation has been approved and signed-off. draft - The target segment may have been changed, but it's not yet considered fully translated. rejectedTranslation - The translation has been reviewed and rejected. rejectedSignOff - The translation was rejected in the sign-off process. Note that only the sourceLanguageCode and targetLanguageCode fields are required, the others already have default values, so you don't have to set them. If the import is successful, you will get back the import id and the status(normally queued). For more details about translation memory imports you can also check out the Importing TM content page. Polling a translation memory import Some imports may take longer, depending on the size of the Translation Memory. To check if the import finished, you can perform a GET request to the Poll Translation Memory Import endpoint and supply the importId and the translationMemoryId. The import is complete when the status is done. Exporting a translation memory To export a translation memory, perform a POST request to the Export Translation Memory endpoint and provide the translationMemoryId and a valid languageDirection of your translation memory. If the export is successful, you will get back an exportId and the export status. If the export did not succeed, the response will contain an error message. Polling a translation memory export Some exports may take longer, depending on the size of the Translation Memory. To check if the export finished, you can perform a GET request to the Poll Translation Memory Export endpoint and supply the exportId. The export is complete when the status is done. Downloading a translation memory export If an export is completed successfully (the status received at the polling is done), it can be downloaded by performing a GET request to the Download Exported Translation Memory endpoint. Just supply as path parameter the exportId and the response will contain the exported translation memory file in tmx.gz format."
  },
  "articles/LCPublicAPI/docs/translations/Translations.html": {
    "href": "articles/LCPublicAPI/docs/translations/Translations.html",
    "title": "Translation API",
    "summary": "Translation API The Translation API provides endpoints for performing translation operations using translation engines. These endpoints allow you to lookup translations, perform concordance searches, and manage translation units within your translation memories. Overview The Translation API enables you to: Lookup translations for text or BCM fragments using translation memories and machine translation Perform concordance searches to find similar segments within translation memories Add new translation units to translation memories Update existing translation units in translation memories All translation operations require a translation engine that defines which translation memories, machine translation engines, and termbases to use for the translation process. Note The BCM fragment format is used for input and output as JSON string, meaning that you will need to serialize and deserialize the BCM fragments when sending requests or processing responses. For .NET you can use the Sdl.Core.Bcm.API nuget package. Endpoints Translation Lookup POST /translations/lookup Translates a phrase in plain text or a BCM fragment containing a single segment. The translated content will be returned as a BCM fragment or term. Use cases: Get translation suggestions for a source segment Retrieve matches from translation memories Get machine translation proposals Access termbase entries for specific terms Key features: Supports both plain text and BCM fragment input Returns translations from multiple resource types (TM, MT, TB) Configurable match thresholds and penalties Request body example: { \"input\": { \"content\": \"Hello world\", \"contentType\": \"text\" }, \"languageDirection\": { \"sourceLanguage\": { \"languageCode\": \"en-US\" }, \"targetLanguage\": { \"languageCode\": \"fr-FR\" } }, \"definition\": { \"translationEngineId\": \"your-translation-engine-id\" }, \"settings\": { \"translationMemory\": { \"minimumMatchValue\": 70, \"penalties\": { \"standardPenalties\": { \"missingFormatting\": 1, \"differentFormatting\": 1 } } } } } Note The translationProposal field in the response can be either a BCM fragment or a term. You can rely on the responseType field to determine the content type and deserialize it accordingly. Concordance Search POST /translations/concordance Performs a concordance search for a given text within the translation memories linked to the specified translation engine. This helps you find segments that contain specific words or phrases. Use cases: Research how certain phrases have been translated previously Quality assurance and consistency checking Translation memory analysis Key features: Search within source or target segments Support for exact and fuzzy matching Configurable search parameters and penalties Returns matching segments with context Note The Translation Memory penalty defined in the Translation Engine will be automatically included in the translation score. Request body example: { \"input\": { \"content\": \"user interface\" }, \"languageDirection\": { \"sourceLanguage\": { \"languageCode\": \"en-US\" }, \"targetLanguage\": { \"languageCode\": \"fr-FR\" } }, \"definition\": { \"translationEngineId\": \"your-translation-engine-id\" }, \"targetOnly\": false, \"settings\": { \"translationMemory\": { \"minimumMatchValue\": 80 } } } Translation Unit Management Update Translation Unit PUT /translations/translation-unit Updates an existing translation unit in the translation memories. The system identifies matching translation units based on the originalTranslationHash provided in the BCM fragment. Note After each update the targetContent.translationOrigin.originalTranslationHash is updated. The new values are returned in the response on the translationHash field. Subsequent updates can be performed by updating the targetContent.translationOrigin.originalTranslationHash in the BCM fragment with the new translationHash, otherwise the system will add a new translation unit instead of updating the existing one. Warning Changing any fields in the sourceContent of a BCM fragment will result in a new translation unit being added instead of updating the existing one. Use cases: Correct existing translations Update translation metadata Modify translation unit fields Maintain translation memory quality Key features: Smart matching of existing translation units Preserve or update translation metadata Configurable update behavior Support for custom fields Request body example for both add and update: { \"input\": { \"content\": \"BCM fragment\" }, \"definition\": { \"translationEngineId\": \"your-translation-engine-id\" }, \"settings\": { \"fields\": [ { \"name\": \"field-name\", \"values\": [ \"field-value\" ] } ] } } Add Translation Unit POST /translations/translation-unit Adds a new translation unit to the translation memories. Use cases: Add new translations units whose existence in the translation memory is unknown If, however, the translation unit with the same source already exists, it will be updated based on the ifTargetSegmentsDiffer field Populate translation memories with approved content Key features: Automatic duplicate handling Field template support for metadata Configurable behavior for existing translations BCM fragment support for rich content BCM Fragments Many Translation API endpoints work with BCM (Binary Content Model) fragments. BCM is RWS's content model that preserves formatting, tags, and metadata within translation content. BCM advantages: Preserves inline formatting and tags Maintains content structure during translation Supports complex document elements Enables accurate translation memory matching For more information about BCM fragments, see the BCM documentation. Example of a BCM fragment: { \"sourceLanguageCode\": \"en-US\", \"targetLanguageCode\": \"fr-FR\", \"sourceContent\": { \"id\": \"166fbfdd-8e0a-46aa-97bf-7b2b62014e5f\", \"segmentNumber\": \"1\", \"confirmationLevel\": \"Translated\", \"type\": \"segment\", \"children\": [ { \"id\": \"c0cff9db-46e4-493d-b578-25e78d578ea7\", \"placeholderTagDefinitionId\": 1, \"tagNumber\": \"50\", \"type\": \"placeholderTag\", \"metadata\": { \"SDL:IsSoftBreak\": \"True\", \"SpecialCharacterPlaceholder\": \"\", \"frameworkOriginalTagId\": \"50\", \"SDL:IsWordStop\": \"False\" } }, { \"id\": \"4b5cbfc4-53b1-462c-86a4-dbc061b5f266\", \"text\": \"This is a sample text\", \"type\": \"text\" } ] }, \"targetContent\": { \"id\": \"166fbfdd-8e0a-46aa-97bf-7b2b62014e5f\", \"segmentNumber\": \"1\", \"confirmationLevel\": \"Translated\", \"translationOrigin\": { \"originType\": \"tm\", \"originSystem\": \"Example TM\", \"matchPercent\": 92, \"textContextMatchLevel\": \"None\", \"originalTranslationHash\": \"-377851791\", \"createdBy\": \"some-user-id\", \"createdOn\": \"2023-09-25T14:24:04.000Z\", \"modifiedBy\": \"some-user-id\", \"modifiedOn\": \"2025-02-12T09:25:57.000Z\", \"metadata\": { \"used_on\": \"04/01/2025 13:56:28\", \"used_by\": \"some-user-id\", \"use_count\": \"8\" } }, \"type\": \"segment\", \"metadata\": { \"Contexts\": [ { \"Context1\": 0, \"Context2\": 0, \"Segment1\": null, \"Segment2\": null, \"LeftSource\": 0, \"LeftTarget\": 0 } ] }, \"children\": [ { \"id\": \"6143602c-5548-43d0-a2fc-1a5a7f2aeb35\", \"text\": \"Ceci est un exemple de texte\", \"type\": \"text\" } ] } } Translation Memory Penalties The Translation API supports various penalty types to fine-tune translation matching: Standard Penalties Missing Formatting: Penalty for matches missing formatting tags Different Formatting: Penalty for matches with different formatting Multiple Translations: Penalty for segments with multiple translation options Translation Unit Status Penalties Translated: Penalty for translated but not reviewed segments Approved Translation: Penalty for approved translations Rejected Translation: Penalty for rejected translations Learn more about Translation Memory penalties and Translation Unit status penalties. Best Practices Performance Optimization Set appropriate minimum match values to reduce processing time Use reasonable penalty values to balance quality and performance Quality Management Configure penalties based on your quality requirements Regularly update translation units to maintain accuracy Translation Memory Maintenance Add high-quality translations to build reliable TMs Update outdated translations to keep content current Use appropriate field templates for metadata management Related APIs Translation Memory API: Bulk import/export of translation memories Translation Engine API: Manage translation engine configurations Termbase API: Manage terminology resources Examples and Use Cases Building a Translation Workflow Setup: Configure translation engine with TMs, MT, and termbases Lookup: Use /translations/lookup for translation suggestions Research: Use /translations/concordance for plain text research Quality: Add/update translation units with the updated BCM fragments retrieved from the previous requests to improve TM quality Maintenance: Regular TM updates and quality checks"
  },
  "articles/LCPublicAPI/docs/webhooks/Batched-webhooks.html": {
    "href": "articles/LCPublicAPI/docs/webhooks/Batched-webhooks.html",
    "title": "Batched Webhooks",
    "summary": "Batched Webhooks Webhooks can be batched to reduce the number of HTTP requests. Batched webhooks are sent as a single HTTP request to the configured webhook URL. The request body follows the Webhook Batch structure and contains a set of Trados Cloud Platform events. Considerations for Consuming Batched Webhooks Create the webhook endpoint to handle batched webhooks. The endpoint must be capable of processing multiple events in a single request. The same webhook authenticity rules apply to both batched and single webhooks. The same success/failure rules for webhook notifications apply, as described in notification responses. Note: A notification delivery is considered successful if the application responds with a 2xx status code within 20 seconds (compared to 3 seconds for individual webhooks). The retry policies and circuit breaker mechanisms for webhook notifications are the same as those described in notification responses. The same headers are included in batched webhooks as in single webhooks, as outlined in the reference. Example Request for a Batched Webhook { \"itemCount\": 42, \"items\": [ { \"eventId\": \"EVENT_ID\", \"eventType\": \"PROJECT.CREATED\", \"version\": \"1.0\", \"timestamp\": \"TIMESTAMP\", \"accountId\": \"ACCOUNT_ID\", \"data\": { ... } }, { \"eventId\": \"EVENT_ID\", \"eventType\": \"PROJECT.TASK.CREATED\", \"version\": \"1.0\", \"timestamp\": \"TIMESTAMP\", \"accountId\": \"ACCOUNT_ID\", \"data\": { ... } }, ... ] } Batch Size and Frequency Batched webhooks are sent when either the maximum batch size is reached or a predefined time interval elapses. The current configuration for the Trados Cloud Platform is: The maximum batch size is 100 events. The maximum time interval is 1 second. Note These values are subject to change without prior notice to enhance system efficiency and ensure platform stability. Key Considerations for Efficient Batching Ensure that a single URL is set for receiving batched webhooks in the Trados Cloud Platform. Create a single webhook under Webhooks Setup that subscribes to multiple event types."
  },
  "articles/LCPublicAPI/docs/webhooks/Webhooks-payload.html": {
    "href": "articles/LCPublicAPI/docs/webhooks/Webhooks-payload.html",
    "title": "Webhooks payload",
    "summary": "Webhooks payload The request body has the same standard JSON format for all Trados Cloud Platform events. An example of request for a PROJECT_CREATED event: { \"eventId\": \"EVENT_ID\", \"eventType\": \"PROJECT.CREATED\", \"version\": \"1.0\", \"timestamp\": \"TIMESTAMP\", \"accountId\": \"ACCOUNT_ID\", \"data\": { \"id\": \"DATA_ID\", \"name\": \"PROJECT_NAME\", \"description\": \"PROJECT_DESCRIPTION\", \"customFields\": [ { \"id\": \"CUSTOM_FIELD_ID1\", \"key\": \"CUSTOM_FIELD_KEY1\", \"value\": \"CUSTOM_FIELD_VALUE1\" }, { \"id\": \"CUSTOM_FIELD_ID2\", \"key\": \"CUSTOM_FIELD_KEY2\", \"value\": \"CUSTOM_FIELD_VALUE2\" } ] } } Note Depending on the event type, the data field will contain a different object, representing the Data Payload Object as mentioned in the next example. This will include different details relevant to that event type, please check the table below. This is the envelope that is common to all events, and only the < Data Payload Object part > is specific and depending on the event type. { \"eventId\": \"EVENT_ID\", \"eventType\": \"PROJECT.CREATED\", \"version\": \"1.0\", \"timestamp\": \"TIMESTAMP\", \"accountId\": \"ACCOUNT_ID\", \"data\": { < Data Payload Object part > } } Event Data payload object model Trigger operations in Trados Cloud Platform API Trigger operations in Trados UI PROJECT.TASK.ACCEPTED task-event Accept task Accept error task Accept task Accept error task PROJECT.TASK.CREATED task-event Generate task Generate task PROJECT.TASK.COMPLETED task-event Complete task Complete task PROJECT.TASK.UPDATED task-event Generate task Accept task Reject task Release task Assign task Reassign task Complete task Generate task Accept task Reject task Release task Assign task Reassign task Complete task PROJECT.TASK.DELETED task-event Delete project and its tasks Delete project and its tasks PROJECT.CREATED project-event Create project Create project PROJECT.STARTED project-event Start project Start project PROJECT.UPDATED project-event Start project (This event will also be emitted in addition to PROJECT.STARTED) Update project by changing any field Complete project Cancel source file Complete target file Start project (This event will also be emitted in addition to PROJECT.STARTED) Update project by changing the Project Information, Configuration or Custom Fields fields in the Settings tab Complete project Set project back in progress Cancel project Complete target file PROJECT.DELETED project-event Delete project Delete project PROJECT.TEMPLATE.CREATED project-template-event Create project template PROJECT.TEMPLATE.UPDATED project-template-event Create project template Update project template PROJECT.TEMPLATE.DELETED project-template-event Delete project template PROJECT.SOURCE.FILE.CREATED source-file-event Add source file to project Attach source files to project Add reference file to project Add translatable file to project PROJECT.SOURCE.FILE.UPDATED source-file-event Update source file by changing the name field Add source file version The project reaches the File Type Detection task The project reaches the File Format Conversion task Update source file by changing the fileType or fileRole fields Add source file version via Replace file action Delete source file version Cancel source file The project reaches the File Type Detection task The project reaches the File Format Conversion task PROJECT.SOURCE.FILE.DELETED source-file-event Delete project and its tasks Delete project and its tasks PROJECT.TARGET.FILE.CREATED target-file-event The project reaches the File Format Conversion task The project reaches the File Format Conversion task PROJECT.TARGET.FILE.UPDATED target-file-event Update source file by changing the name field Add target file version Import target file version The project reaches the File Format Conversion task The project reaches the Copy Source to Target task The project reaches the Machine Translation task The project reaches the Bilingual Engineering task The project reaches the Translation task The project reaches the Linguistic Review task The project reaches the Customer Review task The project reaches the Implement Customer Review task The project reaches the Target File Generation task Add target file version via Upload SDLXLIFF action Replace target file Delete target file version Cancel target file The project reaches the File Format Conversion task The project reaches the Copy Source to Target task The project reaches the Machine Translation task The project reaches the Bilingual Engineering task The project reaches the Translation task The project reaches the Linguistic Review task The project reaches the Customer Review task The project reaches the Implement Customer Review task The project reaches the Target File Generation task PROJECT.TARGET.FILE.DELETED target-file-event Delete project and its tasks Delete project and its tasks PROJECT.GROUP.PROJECT.MEMBERSHIP.CHANGE project-group-event Add project to project group Remove project from project group Add project to project group Remove project from project group PROJECT.ERROR.TASK.CREATED error-task-event Generate error task Generate error task PROJECT.ERROR.TASK.COMPLETED error-task-event Complete error task Complete error task PROJECT.ERROR.TASK.ACCEPTED error-task-event Accept error task Accept error task"
  },
  "articles/LCPublicAPI/docs/webhooks/Webhooks-setup.html": {
    "href": "articles/LCPublicAPI/docs/webhooks/Webhooks-setup.html",
    "title": "Webhooks Setup",
    "summary": "Webhooks Setup A webhook is a web callback by which Trados Cloud Platform notifies an external application when a specific event occurs in a specific account in Trados Cloud Platform. You can subscribe to events by registering webhooks from within the Trados UI. Event Ordering When integrating with our webhook service, please be aware that we cannot guarantee the order of webhook event deliveries. Notifications may arrive out of sequence, and consumers should not rely on receiving messages in a specific order. This is due to the following reasons: Webhooks are sent in parallel for performance reasons If your endpoint is temporarily unavailable, messages will be retried later (see Retry policies) Network conditions and other factors can affect delivery timing Recommended approach: Each webhook payload includes a timestamp field representing the actual moment when the event occurred (not when the webhook was sent). Use this timestamp to: Determine the correct chronological order of events Implement idempotent processing by tracking the last processed timestamp per entity Ignore webhooks for an entity if they have an older timestamp than the last successfully processed event for that entity This pattern ensures your integration handles events correctly regardless of delivery order. Subscribe to Webhook events You subscribe to Webhook events from the Trados UI by creating a Trados Cloud Platform custom application. Several prerequisites must be met so that you can configure the right webhooks for the right customer, namely: Create a Service User in the correct customer folder. Create an application based on the Service User created above. This means that the application is saved in the same customer folder as the Service User. Use the application to configure the webhooks for your customer. Here are the detailed steps: Log in to the Trados UI as a human Administrator user. Expand the account menu on the top right-hand corner and select Integrations. Select the Applications sub-tab. Select New Application and enter the following information: Name - Enter a unique name for your custom application. (Optional) URL - Enter your custom application URL. Service User - Select a service user from the dropdown list. To understand how service users are added in Trados Cloud Platform, check step 1 in the Authenticate topic. Select Add. Back in the Applications sub-tab, select the check box corresponding to your application. Select Edit. On the Overall Information page change any of the following, if necessary: name, URL, description. On the API Access page you can find your Client ID and Client Secret. On the Webhooks page: Enter a default callback URL for your application Webhooks (all Webhooks defined in Trados Cloud Platform). Enter a value for Webhook URL (this is your Webhook endpoint URL which you expose and which Trados Cloud Platform calls), select one or more event types, and hit Enter. You can create a separate webhook for every event you are interested in or combine notifications for multiple event types to one webhook. If you delete your application, all its associated webhooks are also deleted. Select Save. A webhook is triggered for all the projects located in the same folder as the selected service user. Note Similar to other resource types, webhooks are governed by inheritance, the propagation rule giving users visibility and work access with resources in the account hierarchy. Please be aware that the webhooks will be delivered only for the users having the READ permission on the resource triggering the webhook. For example, given there is a folder structure: Root Customer1 Customer2 Customer3 Let's say that: the Group1 has the location Customer1 the Group2 has the location Customer2 the Group3 has the location Customer3 Let's presume that: the service user S1, with the webhook WB1, is in the group Group1 the service user S2, with the webhook WB2, is in the group Group2 the service user S3, with the webhook WB3, is in the group Group3 The followings are true: if you create a project in Customer1: the webhook event is sent to WB1; if you create a project in Customer2: the webhook event is sent to WB1 url and WB2 url; if you create a project in Customer3: the webhook event is sent to WB1 url and WB3 url. Remember that each time events occur, Trados Cloud Platform will call your server on a POST request, on the URL you configured in the Trados Cloud Platform application, and the request body will emulate the Webhook object format. Validate the Webhook notifications In terms of security, you must ensure that Trados Cloud Platform is the system which sent the event. For this, webhook requests must be verified in terms of authenticity, integrity, and confidentiality. Webhook authenticity The webhook POST request sent by Trados Cloud Platform will include a digital signature which concatenates the following information: transmissionTime|applicationId|webhookId|crc32 . For more information on request headers, check the Reference section at the end. The crc32 component is a checksum for the HTTP request body. The signature is decrypted using your Public Key. You can get the Public Key as follows: Log in to the Trados UI as a human Administrator user. Expand the account menu on the top right-hand corner and select Integrations. Select the Applications sub-tab. Open your application and go to the Webhooks tab. Copy the value from the Secret Key field. This is the Public Key which validates and decrypts the signature sent by the header. The validation process mimics the generation sequence, where the recipient system use its Public Key to verify the received signature using the same concatenation: transmissionTime|applicationId|webhookId|crc32 . Here is a Java sample: //retrieve transmissionTime, applicationId, webhookId, signatureAlg & signature from request headers* // event = request message body //generate crc32 from the request body CRC32 checkSum = new CRC32(); checksum.update(event.getBytes(UTF_8)); long crc32Val = checksum.getValue(); //build the message String message = transmissionTime + | + applicationId + | + webhookId + | + crc32Val; //build PublicKey byte[] bytes = org.springframework.security.crypto.codec.Base64.decode(publicKeyAsString.getBytes()); X509EncodeKeySpec ks = new X509EncodeKeySpec(bytes); KeyFactory kf = KeyFactory.getInstance(RSA); PublicKey publicKey = kf.generatePublic(ks); //verify signature Signature publicSignature = Signature.getInstance(signatureAlg); publicSignature.initVerify(publicKey); publicSignature.update(message.getBytes(UTF_8)); byte[] signatureBytes = Base64.getDecoder().decode(signature); publicSignature.verify(signatureBytes); A valid message implies that the message was sent by Trados Cloud Platform. Webhook integrity The fact that the signature is created based on payload content ensures that the message is not altered (CRC32). Webhook confidentiality To ensure that the message cannot be read by 3rd-parties, Trados Cloud Platform Webhooks only accept the HTTPS communication protocol specified in the webhook URLs you provide. Return notification responses Success notifications A notification delivery is considered successful when applications respond with a 2xx status code within 3 seconds. Note It is recommended that applications perform little processing when receiving events and, for instance, that they make use of a queuing mechanism to perform further processing asynchronously after having acknowledged the event notification request. Trados Cloud Platform does not inspect the HTTP response body. Failure notifications Notifications will fail in the following scenarios: Response time: the response status code is 2xx, but the response is received after 3 seconds Response status code: 3xx: Trados Cloud Platform does not follow redirects 4xx 5xx Retry policies Trados Cloud Platform will try its best to redeliver the notification. Retries will include specific headers with information about the retry: X-LC-Retry-Num: header indicating the retry number (1, 2 or 3) X-LC-Retry-Reason: header indicating why the retry is sent Trados Cloud Platform will try to delivery the notification up to 8 times using an exponential back-off strategy (namely, it will delay the next delivery attempt exponentially with the number of retries already made). Retry No. Interval (relative to last retry)/ Minutes Interval (relative to original attempt)/ Minutes 1 5 5 2 10 15 3 30 45 4 120 (2h) 165 5 360 (6h) 525 6 600 (10h) 1125 7 960 (16h) 2085 8 1440 (24h) 3525 Circuit Breaker To protect the platform and ensure problems from one tenant do not affect other tenants, we have a circuit breaker that will stop sending webhook on URLs that do not respond within the allowed time (mentioned in Failure notifications section). The actual HTTP response code is not relevant since the connection is closed before the response is received. The circuit breaker is triggered when 3 calls to a URL fail within a short time window. The circuit breaker is opened for an hour only for that URL, not for the tenant. During that hour, any webhooks sent to that URL are scheduled for the next retry. Note Frequent timeouts may compromise the performance of our delivery system. We may need to remove your webhook from our database without advance notice if it is negatively impacting the platform. This action is reserved for cases of major incidents and is necessary to prevent potential issues that can arise from repeated delivery attempts. Reference The request headers are: X-LC-Signature: Contains the message digital signature (see section on Webhook authenticity above). X-LC-Signature-Algo: Contains the algorithm used for signing the message. Possible values: \"SHA256withRSA\". X-LC-Retry-Num: Contains the retry attempt counter. Initial value is 0, which will be increased with each attempt at redelivering the webhook message. X-LC-Retry-Reason: Contains a textual description of the previous error, which resulted in the current attempt to redeliver the webhook message. X-LC-Transmission-Time: Contains the date/time when the webhook message was delivered, in ISO 8601 date time format. X-LC-Application: Unique identifier of the Trados Cloud Platform application, which is the recipient of the webhook message. Every webhook has an application associated in Trados Cloud Platform, which can be found in the Trados UI, in the account dropdown menu from the top right corner, under the Applications tab, in Integrations. The configured webhooks for an application are listed on the Webhooks tab of the respective application. X-LC-Webhook: Unique identifier of the webhook defined for the LC application which is the recipient of the webhook message. It can be ignored because it is not exposed in the Trados UI. X-LC-Region: Region of the account of the user, which is the recipient of the webhook message."
  },
  "developer_license.html": {
    "href": "developer_license.html",
    "title": "Request a Developer License",
    "summary": "Request a Developer License Selecting the Right License Trados currently offers two primary license types for developers: Desktop License for Trados Studio Grants full functionality of Trados Studio on a single computer. Ideal for creating desktop-based integrations or customizations. Cloud License for Trados Team or Enterprise Provides access to Trados capabilities in a cloud-based environment. Best suited for solutions requiring team collaboration, centralized project management, and cloud workflows. Apply for a Developer License Send an email to app-signing@rws.com with the following information: Full name and address (for identification). Reason for requesting a developer license (e.g., custom integrations, automation scripts, Trados Studio plugin development, Trados Cloud add-on development, etc.). Affiliated company and contact person: If applicable, specify the company you are working for and who the contact person would be (especially if representing an existing customer). Intended solutions and pricing details: Indicate whether you plan to offer solutions developed with the dev license on the AppStore and if you intend to charge for them. Understanding the potential impact and reach of your solution helps RWS assess your request. Await Evaluation Our team reviews each request to ensure alignment with Trados licensing guidelines and to assess its potential value to the Trados community. Once approved, you will receive an email with additional instructions on how to proceed."
  },
  "index.html": {
    "href": "index.html",
    "title": "Access the Var:ProductName APIs",
    "summary": "Access the Var:ProductName APIs Var:ProductName is the platform on which RWS host a number of products. You're in the right place if you're looking for API documentation for any of the following: Trados Enterprise Trados Accelerate Trados Team Trados Ignite Trados Studio (cloud capabilities) Trados Go Integrating with Var:ProductName products To create an integration with any of the products listed above, you'll need to use the Public API. You can find the documentation for the API here. Note that the API is updated regularly so make sure that you check out the What's new section to find out information on recently added features. To enable RWS to extend and improve the API, and to support the latest features in the products, sometimes it's necessary to remove or change functionality. For that, you'll need to check the What's deprecated page where RWS will post advance notice of any API endpoints that will be removed or change in the future. Don't worry though because RWS will try and give six months notice of any breaking changes. Click here to find out more. Extending Var:ProductName products Var:ProductName products can be extended in a number of ways. For example, you may want to create an add-on to support a machine translation engine or you may want to create a custom workflow task. RWS provides an extensibility framework for the Var:ProductName suite of products. To get more information on what's required and how you can do this, visit the Var:ProductName extensibility documentation pages. Click here to find out more. Interacting with files Translatable content in Var:ProductName is held in a format called Bilingual Content Model, or BCM for short. You can find BCM reference documentation and samples on this site. Click here to find out more. Reporting API issues If you want to report an issue with the API, you can find information on how to do this here - How to report an issue Trados Cloud API and Customer Portal API Please be aware that Trados Cloud offers two different APIs. First is the modern Trados Cloud API described on this page. Then there is the second API that is the Mantra API. Trados Cloud API is the recommended option for new integrations as it is more modern and much effort is put into its continuous evolution along with Trados Enterprise. Please take care not to confuse the two of them as they are not interchangeable."
  }
}